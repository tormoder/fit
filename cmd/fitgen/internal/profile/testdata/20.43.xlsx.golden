// TYPES
// Code generated using the program found in 'cmd/fitgen/main.go'. DO NOT EDIT.

// SDK Version: 20.43

package fit

// ActivityClass represents the activity_class FIT type.
type ActivityClass byte

const (
	ActivityClassLevel    ActivityClass = 0x7F // 0 to 100
	ActivityClassLevelMax ActivityClass = 100
	ActivityClassAthlete  ActivityClass = 0x80
	ActivityClassInvalid  ActivityClass = 0xFF
)

// ActivityLevel represents the activity_level FIT type.
type ActivityLevel byte

const (
	ActivityLevelLow     ActivityLevel = 0
	ActivityLevelMedium  ActivityLevel = 1
	ActivityLevelHigh    ActivityLevel = 2
	ActivityLevelInvalid ActivityLevel = 0xFF
)

// ActivityMode represents the activity FIT type.
type ActivityMode byte

const (
	ActivityModeManual         ActivityMode = 0
	ActivityModeAutoMultiSport ActivityMode = 1
	ActivityModeInvalid        ActivityMode = 0xFF
)

// ActivitySubtype represents the activity_subtype FIT type.
type ActivitySubtype byte

const (
	ActivitySubtypeGeneric       ActivitySubtype = 0
	ActivitySubtypeTreadmill     ActivitySubtype = 1  // Run
	ActivitySubtypeStreet        ActivitySubtype = 2  // Run
	ActivitySubtypeTrail         ActivitySubtype = 3  // Run
	ActivitySubtypeTrack         ActivitySubtype = 4  // Run
	ActivitySubtypeSpin          ActivitySubtype = 5  // Cycling
	ActivitySubtypeIndoorCycling ActivitySubtype = 6  // Cycling
	ActivitySubtypeRoad          ActivitySubtype = 7  // Cycling
	ActivitySubtypeMountain      ActivitySubtype = 8  // Cycling
	ActivitySubtypeDownhill      ActivitySubtype = 9  // Cycling
	ActivitySubtypeRecumbent     ActivitySubtype = 10 // Cycling
	ActivitySubtypeCyclocross    ActivitySubtype = 11 // Cycling
	ActivitySubtypeHandCycling   ActivitySubtype = 12 // Cycling
	ActivitySubtypeTrackCycling  ActivitySubtype = 13 // Cycling
	ActivitySubtypeIndoorRowing  ActivitySubtype = 14 // Fitness Equipment
	ActivitySubtypeElliptical    ActivitySubtype = 15 // Fitness Equipment
	ActivitySubtypeStairClimbing ActivitySubtype = 16 // Fitness Equipment
	ActivitySubtypeLapSwimming   ActivitySubtype = 17 // Swimming
	ActivitySubtypeOpenWater     ActivitySubtype = 18 // Swimming
	ActivitySubtypeAll           ActivitySubtype = 254
	ActivitySubtypeInvalid       ActivitySubtype = 0xFF
)

// ActivityType represents the activity_type FIT type.
type ActivityType byte

const (
	ActivityTypeGeneric          ActivityType = 0
	ActivityTypeRunning          ActivityType = 1
	ActivityTypeCycling          ActivityType = 2
	ActivityTypeTransition       ActivityType = 3 // Mulitsport transition
	ActivityTypeFitnessEquipment ActivityType = 4
	ActivityTypeSwimming         ActivityType = 5
	ActivityTypeWalking          ActivityType = 6
	ActivityTypeSedentary        ActivityType = 8
	ActivityTypeAll              ActivityType = 254 // All is for goals only to include all sports.
	ActivityTypeInvalid          ActivityType = 0xFF
)

// AnalogWatchfaceLayout represents the analog_watchface_layout FIT type.
type AnalogWatchfaceLayout byte

const (
	AnalogWatchfaceLayoutMinimal     AnalogWatchfaceLayout = 0
	AnalogWatchfaceLayoutTraditional AnalogWatchfaceLayout = 1
	AnalogWatchfaceLayoutModern      AnalogWatchfaceLayout = 2
	AnalogWatchfaceLayoutInvalid     AnalogWatchfaceLayout = 0xFF
)

// AntNetwork represents the ant_network FIT type.
type AntNetwork byte

const (
	AntNetworkPublic  AntNetwork = 0
	AntNetworkAntplus AntNetwork = 1
	AntNetworkAntfs   AntNetwork = 2
	AntNetworkPrivate AntNetwork = 3
	AntNetworkInvalid AntNetwork = 0xFF
)

// AntplusDeviceType represents the antplus_device_type FIT type.
type AntplusDeviceType uint8

const (
	AntplusDeviceTypeAntfs                   AntplusDeviceType = 1
	AntplusDeviceTypeBikePower               AntplusDeviceType = 11
	AntplusDeviceTypeEnvironmentSensorLegacy AntplusDeviceType = 12
	AntplusDeviceTypeMultiSportSpeedDistance AntplusDeviceType = 15
	AntplusDeviceTypeControl                 AntplusDeviceType = 16
	AntplusDeviceTypeFitnessEquipment        AntplusDeviceType = 17
	AntplusDeviceTypeBloodPressure           AntplusDeviceType = 18
	AntplusDeviceTypeGeocacheNode            AntplusDeviceType = 19
	AntplusDeviceTypeLightElectricVehicle    AntplusDeviceType = 20
	AntplusDeviceTypeEnvSensor               AntplusDeviceType = 25
	AntplusDeviceTypeRacquet                 AntplusDeviceType = 26
	AntplusDeviceTypeControlHub              AntplusDeviceType = 27
	AntplusDeviceTypeMuscleOxygen            AntplusDeviceType = 31
	AntplusDeviceTypeBikeLightMain           AntplusDeviceType = 35
	AntplusDeviceTypeBikeLightShared         AntplusDeviceType = 36
	AntplusDeviceTypeExd                     AntplusDeviceType = 38
	AntplusDeviceTypeBikeRadar               AntplusDeviceType = 40
	AntplusDeviceTypeWeightScale             AntplusDeviceType = 119
	AntplusDeviceTypeHeartRate               AntplusDeviceType = 120
	AntplusDeviceTypeBikeSpeedCadence        AntplusDeviceType = 121
	AntplusDeviceTypeBikeCadence             AntplusDeviceType = 122
	AntplusDeviceTypeBikeSpeed               AntplusDeviceType = 123
	AntplusDeviceTypeStrideSpeedDistance     AntplusDeviceType = 124
	AntplusDeviceTypeInvalid                 AntplusDeviceType = 0xFF
)

// AttitudeStage represents the attitude_stage FIT type.
type AttitudeStage byte

const (
	AttitudeStageFailed   AttitudeStage = 0
	AttitudeStageAligning AttitudeStage = 1
	AttitudeStageDegraded AttitudeStage = 2
	AttitudeStageValid    AttitudeStage = 3
	AttitudeStageInvalid  AttitudeStage = 0xFF
)

// AttitudeValidity represents the attitude_validity FIT type.
type AttitudeValidity uint16

const (
	AttitudeValidityTrackAngleHeadingValid AttitudeValidity = 0x0001
	AttitudeValidityPitchValid             AttitudeValidity = 0x0002
	AttitudeValidityRollValid              AttitudeValidity = 0x0004
	AttitudeValidityLateralBodyAccelValid  AttitudeValidity = 0x0008
	AttitudeValidityNormalBodyAccelValid   AttitudeValidity = 0x0010
	AttitudeValidityTurnRateValid          AttitudeValidity = 0x0020
	AttitudeValidityHwFail                 AttitudeValidity = 0x0040
	AttitudeValidityMagInvalid             AttitudeValidity = 0x0080
	AttitudeValidityNoGps                  AttitudeValidity = 0x0100
	AttitudeValidityGpsInvalid             AttitudeValidity = 0x0200
	AttitudeValiditySolutionCoasting       AttitudeValidity = 0x0400
	AttitudeValidityTrueTrackAngle         AttitudeValidity = 0x0800
	AttitudeValidityMagneticHeading        AttitudeValidity = 0x1000
	AttitudeValidityInvalid                AttitudeValidity = 0xFFFF
)

// AutoActivityDetect represents the auto_activity_detect FIT type.
type AutoActivityDetect uint32

const (
	AutoActivityDetectNone       AutoActivityDetect = 0x00000000
	AutoActivityDetectRunning    AutoActivityDetect = 0x00000001
	AutoActivityDetectCycling    AutoActivityDetect = 0x00000002
	AutoActivityDetectSwimming   AutoActivityDetect = 0x00000004
	AutoActivityDetectWalking    AutoActivityDetect = 0x00000008
	AutoActivityDetectElliptical AutoActivityDetect = 0x00000020
	AutoActivityDetectSedentary  AutoActivityDetect = 0x00000400
	AutoActivityDetectInvalid    AutoActivityDetect = 0xFFFFFFFF
)

// AutoSyncFrequency represents the auto_sync_frequency FIT type.
type AutoSyncFrequency byte

const (
	AutoSyncFrequencyNever        AutoSyncFrequency = 0
	AutoSyncFrequencyOccasionally AutoSyncFrequency = 1
	AutoSyncFrequencyFrequent     AutoSyncFrequency = 2
	AutoSyncFrequencyOnceADay     AutoSyncFrequency = 3
	AutoSyncFrequencyRemote       AutoSyncFrequency = 4
	AutoSyncFrequencyInvalid      AutoSyncFrequency = 0xFF
)

// AutolapTrigger represents the autolap_trigger FIT type.
type AutolapTrigger byte

const (
	AutolapTriggerTime             AutolapTrigger = 0
	AutolapTriggerDistance         AutolapTrigger = 1
	AutolapTriggerPositionStart    AutolapTrigger = 2
	AutolapTriggerPositionLap      AutolapTrigger = 3
	AutolapTriggerPositionWaypoint AutolapTrigger = 4
	AutolapTriggerPositionMarked   AutolapTrigger = 5
	AutolapTriggerOff              AutolapTrigger = 6
	AutolapTriggerInvalid          AutolapTrigger = 0xFF
)

// Autoscroll represents the autoscroll FIT type.
type Autoscroll byte

const (
	AutoscrollNone    Autoscroll = 0
	AutoscrollSlow    Autoscroll = 1
	AutoscrollMedium  Autoscroll = 2
	AutoscrollFast    Autoscroll = 3
	AutoscrollInvalid Autoscroll = 0xFF
)

// BacklightMode represents the backlight_mode FIT type.
type BacklightMode byte

const (
	BacklightModeOff                                 BacklightMode = 0
	BacklightModeManual                              BacklightMode = 1
	BacklightModeKeyAndMessages                      BacklightMode = 2
	BacklightModeAutoBrightness                      BacklightMode = 3
	BacklightModeSmartNotifications                  BacklightMode = 4
	BacklightModeKeyAndMessagesNight                 BacklightMode = 5
	BacklightModeKeyAndMessagesAndSmartNotifications BacklightMode = 6
	BacklightModeInvalid                             BacklightMode = 0xFF
)

// BatteryStatus represents the battery_status FIT type.
type BatteryStatus uint8

const (
	BatteryStatusNew      BatteryStatus = 1
	BatteryStatusGood     BatteryStatus = 2
	BatteryStatusOk       BatteryStatus = 3
	BatteryStatusLow      BatteryStatus = 4
	BatteryStatusCritical BatteryStatus = 5
	BatteryStatusCharging BatteryStatus = 6
	BatteryStatusUnknown  BatteryStatus = 7
	BatteryStatusInvalid  BatteryStatus = 0xFF
)

// BikeLightBeamAngleMode represents the bike_light_beam_angle_mode FIT type.
type BikeLightBeamAngleMode uint8

const (
	BikeLightBeamAngleModeManual  BikeLightBeamAngleMode = 0
	BikeLightBeamAngleModeAuto    BikeLightBeamAngleMode = 1
	BikeLightBeamAngleModeInvalid BikeLightBeamAngleMode = 0xFF
)

// BikeLightNetworkConfigType represents the bike_light_network_config_type FIT type.
type BikeLightNetworkConfigType byte

const (
	BikeLightNetworkConfigTypeAuto           BikeLightNetworkConfigType = 0
	BikeLightNetworkConfigTypeIndividual     BikeLightNetworkConfigType = 4
	BikeLightNetworkConfigTypeHighVisibility BikeLightNetworkConfigType = 5
	BikeLightNetworkConfigTypeTrail          BikeLightNetworkConfigType = 6
	BikeLightNetworkConfigTypeInvalid        BikeLightNetworkConfigType = 0xFF
)

// BodyLocation represents the body_location FIT type.
type BodyLocation byte

const (
	BodyLocationLeftLeg               BodyLocation = 0
	BodyLocationLeftCalf              BodyLocation = 1
	BodyLocationLeftShin              BodyLocation = 2
	BodyLocationLeftHamstring         BodyLocation = 3
	BodyLocationLeftQuad              BodyLocation = 4
	BodyLocationLeftGlute             BodyLocation = 5
	BodyLocationRightLeg              BodyLocation = 6
	BodyLocationRightCalf             BodyLocation = 7
	BodyLocationRightShin             BodyLocation = 8
	BodyLocationRightHamstring        BodyLocation = 9
	BodyLocationRightQuad             BodyLocation = 10
	BodyLocationRightGlute            BodyLocation = 11
	BodyLocationTorsoBack             BodyLocation = 12
	BodyLocationLeftLowerBack         BodyLocation = 13
	BodyLocationLeftUpperBack         BodyLocation = 14
	BodyLocationRightLowerBack        BodyLocation = 15
	BodyLocationRightUpperBack        BodyLocation = 16
	BodyLocationTorsoFront            BodyLocation = 17
	BodyLocationLeftAbdomen           BodyLocation = 18
	BodyLocationLeftChest             BodyLocation = 19
	BodyLocationRightAbdomen          BodyLocation = 20
	BodyLocationRightChest            BodyLocation = 21
	BodyLocationLeftArm               BodyLocation = 22
	BodyLocationLeftShoulder          BodyLocation = 23
	BodyLocationLeftBicep             BodyLocation = 24
	BodyLocationLeftTricep            BodyLocation = 25
	BodyLocationLeftBrachioradialis   BodyLocation = 26 // Left anterior forearm
	BodyLocationLeftForearmExtensors  BodyLocation = 27 // Left posterior forearm
	BodyLocationRightArm              BodyLocation = 28
	BodyLocationRightShoulder         BodyLocation = 29
	BodyLocationRightBicep            BodyLocation = 30
	BodyLocationRightTricep           BodyLocation = 31
	BodyLocationRightBrachioradialis  BodyLocation = 32 // Right anterior forearm
	BodyLocationRightForearmExtensors BodyLocation = 33 // Right posterior forearm
	BodyLocationNeck                  BodyLocation = 34
	BodyLocationThroat                BodyLocation = 35
	BodyLocationWaistMidBack          BodyLocation = 36
	BodyLocationWaistFront            BodyLocation = 37
	BodyLocationWaistLeft             BodyLocation = 38
	BodyLocationWaistRight            BodyLocation = 39
	BodyLocationInvalid               BodyLocation = 0xFF
)

// BpStatus represents the bp_status FIT type.
type BpStatus byte

const (
	BpStatusNoError                 BpStatus = 0
	BpStatusErrorIncompleteData     BpStatus = 1
	BpStatusErrorNoMeasurement      BpStatus = 2
	BpStatusErrorDataOutOfRange     BpStatus = 3
	BpStatusErrorIrregularHeartRate BpStatus = 4
	BpStatusInvalid                 BpStatus = 0xFF
)

// CameraEventType represents the camera_event_type FIT type.
type CameraEventType byte

const (
	CameraEventTypeVideoStart                  CameraEventType = 0 // Start of video recording
	CameraEventTypeVideoSplit                  CameraEventType = 1 // Mark of video file split (end of one file, beginning of the other)
	CameraEventTypeVideoEnd                    CameraEventType = 2 // End of video recording
	CameraEventTypePhotoTaken                  CameraEventType = 3 // Still photo taken
	CameraEventTypeVideoSecondStreamStart      CameraEventType = 4
	CameraEventTypeVideoSecondStreamSplit      CameraEventType = 5
	CameraEventTypeVideoSecondStreamEnd        CameraEventType = 6
	CameraEventTypeVideoSplitStart             CameraEventType = 7 // Mark of video file split start
	CameraEventTypeVideoSecondStreamSplitStart CameraEventType = 8
	CameraEventTypeVideoPause                  CameraEventType = 11 // Mark when a video recording has been paused
	CameraEventTypeVideoSecondStreamPause      CameraEventType = 12
	CameraEventTypeVideoResume                 CameraEventType = 13 // Mark when a video recording has been resumed
	CameraEventTypeVideoSecondStreamResume     CameraEventType = 14
	CameraEventTypeInvalid                     CameraEventType = 0xFF
)

// CameraOrientationType represents the camera_orientation_type FIT type.
type CameraOrientationType byte

const (
	CameraOrientationTypeCameraOrientation0   CameraOrientationType = 0
	CameraOrientationTypeCameraOrientation90  CameraOrientationType = 1
	CameraOrientationTypeCameraOrientation180 CameraOrientationType = 2
	CameraOrientationTypeCameraOrientation270 CameraOrientationType = 3
	CameraOrientationTypeInvalid              CameraOrientationType = 0xFF
)

// Checksum represents the checksum FIT type.
type Checksum uint8

const (
	ChecksumClear   Checksum = 0 // Allows clear of checksum for flash memory where can only write 1 to 0 without erasing sector.
	ChecksumOk      Checksum = 1 // Set to mark checksum as valid if computes to invalid values 0 or 0xFF.  Checksum can also be set to ok to save encoding computation time.
	ChecksumInvalid Checksum = 0xFF
)

// CommTimeoutType represents the comm_timeout_type FIT type.
type CommTimeoutType uint16

const (
	CommTimeoutTypeWildcardPairingTimeout CommTimeoutType = 0 // Timeout pairing to any device
	CommTimeoutTypePairingTimeout         CommTimeoutType = 1 // Timeout pairing to previously paired device
	CommTimeoutTypeConnectionLost         CommTimeoutType = 2 // Temporary loss of communications
	CommTimeoutTypeConnectionTimeout      CommTimeoutType = 3 // Connection closed due to extended bad communications
	CommTimeoutTypeInvalid                CommTimeoutType = 0xFFFF
)

// ConnectivityCapabilities represents the connectivity_capabilities FIT type.
type ConnectivityCapabilities uint32

const (
	ConnectivityCapabilitiesBluetooth                       ConnectivityCapabilities = 0x00000001
	ConnectivityCapabilitiesBluetoothLe                     ConnectivityCapabilities = 0x00000002
	ConnectivityCapabilitiesAnt                             ConnectivityCapabilities = 0x00000004
	ConnectivityCapabilitiesActivityUpload                  ConnectivityCapabilities = 0x00000008
	ConnectivityCapabilitiesCourseDownload                  ConnectivityCapabilities = 0x00000010
	ConnectivityCapabilitiesWorkoutDownload                 ConnectivityCapabilities = 0x00000020
	ConnectivityCapabilitiesLiveTrack                       ConnectivityCapabilities = 0x00000040
	ConnectivityCapabilitiesWeatherConditions               ConnectivityCapabilities = 0x00000080
	ConnectivityCapabilitiesWeatherAlerts                   ConnectivityCapabilities = 0x00000100
	ConnectivityCapabilitiesGpsEphemerisDownload            ConnectivityCapabilities = 0x00000200
	ConnectivityCapabilitiesExplicitArchive                 ConnectivityCapabilities = 0x00000400
	ConnectivityCapabilitiesSetupIncomplete                 ConnectivityCapabilities = 0x00000800
	ConnectivityCapabilitiesContinueSyncAfterSoftwareUpdate ConnectivityCapabilities = 0x00001000
	ConnectivityCapabilitiesConnectIqAppDownload            ConnectivityCapabilities = 0x00002000
	ConnectivityCapabilitiesGolfCourseDownload              ConnectivityCapabilities = 0x00004000
	ConnectivityCapabilitiesDeviceInitiatesSync             ConnectivityCapabilities = 0x00008000 // Indicates device is in control of initiating all syncs
	ConnectivityCapabilitiesConnectIqWatchAppDownload       ConnectivityCapabilities = 0x00010000
	ConnectivityCapabilitiesConnectIqWidgetDownload         ConnectivityCapabilities = 0x00020000
	ConnectivityCapabilitiesConnectIqWatchFaceDownload      ConnectivityCapabilities = 0x00040000
	ConnectivityCapabilitiesConnectIqDataFieldDownload      ConnectivityCapabilities = 0x00080000
	ConnectivityCapabilitiesConnectIqAppManagment           ConnectivityCapabilities = 0x00100000 // Device supports delete and reorder of apps via GCM
	ConnectivityCapabilitiesSwingSensor                     ConnectivityCapabilities = 0x00200000
	ConnectivityCapabilitiesSwingSensorRemote               ConnectivityCapabilities = 0x00400000
	ConnectivityCapabilitiesIncidentDetection               ConnectivityCapabilities = 0x00800000 // Device supports incident detection
	ConnectivityCapabilitiesAudioPrompts                    ConnectivityCapabilities = 0x01000000
	ConnectivityCapabilitiesWifiVerification                ConnectivityCapabilities = 0x02000000 // Device supports reporting wifi verification via GCM
	ConnectivityCapabilitiesTrueUp                          ConnectivityCapabilities = 0x04000000 // Device supports True Up
	ConnectivityCapabilitiesFindMyWatch                     ConnectivityCapabilities = 0x08000000 // Device supports Find My Watch
	ConnectivityCapabilitiesRemoteManualSync                ConnectivityCapabilities = 0x10000000
	ConnectivityCapabilitiesLiveTrackAutoStart              ConnectivityCapabilities = 0x20000000 // Device supports LiveTrack auto start
	ConnectivityCapabilitiesLiveTrackMessaging              ConnectivityCapabilities = 0x40000000 // Device supports LiveTrack Messaging
	ConnectivityCapabilitiesInstantInput                    ConnectivityCapabilities = 0x80000000 // Device supports instant input feature
	ConnectivityCapabilitiesInvalid                         ConnectivityCapabilities = 0x00000000
)

// CourseCapabilities represents the course_capabilities FIT type.
type CourseCapabilities uint32

const (
	CourseCapabilitiesProcessed  CourseCapabilities = 0x00000001
	CourseCapabilitiesValid      CourseCapabilities = 0x00000002
	CourseCapabilitiesTime       CourseCapabilities = 0x00000004
	CourseCapabilitiesDistance   CourseCapabilities = 0x00000008
	CourseCapabilitiesPosition   CourseCapabilities = 0x00000010
	CourseCapabilitiesHeartRate  CourseCapabilities = 0x00000020
	CourseCapabilitiesPower      CourseCapabilities = 0x00000040
	CourseCapabilitiesCadence    CourseCapabilities = 0x00000080
	CourseCapabilitiesTraining   CourseCapabilities = 0x00000100
	CourseCapabilitiesNavigation CourseCapabilities = 0x00000200
	CourseCapabilitiesBikeway    CourseCapabilities = 0x00000400
	CourseCapabilitiesInvalid    CourseCapabilities = 0x00000000
)

// CoursePoint represents the course_point FIT type.
type CoursePoint byte

const (
	CoursePointGeneric        CoursePoint = 0
	CoursePointSummit         CoursePoint = 1
	CoursePointValley         CoursePoint = 2
	CoursePointWater          CoursePoint = 3
	CoursePointFood           CoursePoint = 4
	CoursePointDanger         CoursePoint = 5
	CoursePointLeft           CoursePoint = 6
	CoursePointRight          CoursePoint = 7
	CoursePointStraight       CoursePoint = 8
	CoursePointFirstAid       CoursePoint = 9
	CoursePointFourthCategory CoursePoint = 10
	CoursePointThirdCategory  CoursePoint = 11
	CoursePointSecondCategory CoursePoint = 12
	CoursePointFirstCategory  CoursePoint = 13
	CoursePointHorsCategory   CoursePoint = 14
	CoursePointSprint         CoursePoint = 15
	CoursePointLeftFork       CoursePoint = 16
	CoursePointRightFork      CoursePoint = 17
	CoursePointMiddleFork     CoursePoint = 18
	CoursePointSlightLeft     CoursePoint = 19
	CoursePointSharpLeft      CoursePoint = 20
	CoursePointSlightRight    CoursePoint = 21
	CoursePointSharpRight     CoursePoint = 22
	CoursePointUTurn          CoursePoint = 23
	CoursePointSegmentStart   CoursePoint = 24
	CoursePointSegmentEnd     CoursePoint = 25
	CoursePointInvalid        CoursePoint = 0xFF
)

// DateMode represents the date_mode FIT type.
type DateMode byte

const (
	DateModeDayMonth DateMode = 0
	DateModeMonthDay DateMode = 1
	DateModeInvalid  DateMode = 0xFF
)

// DayOfWeek represents the day_of_week FIT type.
type DayOfWeek byte

const (
	DayOfWeekSunday    DayOfWeek = 0
	DayOfWeekMonday    DayOfWeek = 1
	DayOfWeekTuesday   DayOfWeek = 2
	DayOfWeekWednesday DayOfWeek = 3
	DayOfWeekThursday  DayOfWeek = 4
	DayOfWeekFriday    DayOfWeek = 5
	DayOfWeekSaturday  DayOfWeek = 6
	DayOfWeekInvalid   DayOfWeek = 0xFF
)

// DeviceIndex represents the device_index FIT type.
type DeviceIndex uint8

const (
	DeviceIndexCreator DeviceIndex = 0 // Creator of the file is always device index 0.
	DeviceIndexInvalid DeviceIndex = 0xFF
)

// DigitalWatchfaceLayout represents the digital_watchface_layout FIT type.
type DigitalWatchfaceLayout byte

const (
	DigitalWatchfaceLayoutTraditional DigitalWatchfaceLayout = 0
	DigitalWatchfaceLayoutModern      DigitalWatchfaceLayout = 1
	DigitalWatchfaceLayoutBold        DigitalWatchfaceLayout = 2
	DigitalWatchfaceLayoutInvalid     DigitalWatchfaceLayout = 0xFF
)

// DisplayHeart represents the display_heart FIT type.
type DisplayHeart byte

const (
	DisplayHeartBpm     DisplayHeart = 0
	DisplayHeartMax     DisplayHeart = 1
	DisplayHeartReserve DisplayHeart = 2
	DisplayHeartInvalid DisplayHeart = 0xFF
)

// DisplayMeasure represents the display_measure FIT type.
type DisplayMeasure byte

const (
	DisplayMeasureMetric   DisplayMeasure = 0
	DisplayMeasureStatute  DisplayMeasure = 1
	DisplayMeasureNautical DisplayMeasure = 2
	DisplayMeasureInvalid  DisplayMeasure = 0xFF
)

// DisplayOrientation represents the display_orientation FIT type.
type DisplayOrientation byte

const (
	DisplayOrientationAuto             DisplayOrientation = 0 // automatic if the device supports it
	DisplayOrientationPortrait         DisplayOrientation = 1
	DisplayOrientationLandscape        DisplayOrientation = 2
	DisplayOrientationPortraitFlipped  DisplayOrientation = 3 // portrait mode but rotated 180 degrees
	DisplayOrientationLandscapeFlipped DisplayOrientation = 4 // landscape mode but rotated 180 degrees
	DisplayOrientationInvalid          DisplayOrientation = 0xFF
)

// DisplayPosition represents the display_position FIT type.
type DisplayPosition byte

const (
	DisplayPositionDegree               DisplayPosition = 0  // dd.dddddd
	DisplayPositionDegreeMinute         DisplayPosition = 1  // dddmm.mmm
	DisplayPositionDegreeMinuteSecond   DisplayPosition = 2  // dddmmss
	DisplayPositionAustrianGrid         DisplayPosition = 3  // Austrian Grid (BMN)
	DisplayPositionBritishGrid          DisplayPosition = 4  // British National Grid
	DisplayPositionDutchGrid            DisplayPosition = 5  // Dutch grid system
	DisplayPositionHungarianGrid        DisplayPosition = 6  // Hungarian grid system
	DisplayPositionFinnishGrid          DisplayPosition = 7  // Finnish grid system Zone3 KKJ27
	DisplayPositionGermanGrid           DisplayPosition = 8  // Gausss Krueger (German)
	DisplayPositionIcelandicGrid        DisplayPosition = 9  // Icelandic Grid
	DisplayPositionIndonesianEquatorial DisplayPosition = 10 // Indonesian Equatorial LCO
	DisplayPositionIndonesianIrian      DisplayPosition = 11 // Indonesian Irian LCO
	DisplayPositionIndonesianSouthern   DisplayPosition = 12 // Indonesian Southern LCO
	DisplayPositionIndiaZone0           DisplayPosition = 13 // India zone 0
	DisplayPositionIndiaZoneIA          DisplayPosition = 14 // India zone IA
	DisplayPositionIndiaZoneIB          DisplayPosition = 15 // India zone IB
	DisplayPositionIndiaZoneIIA         DisplayPosition = 16 // India zone IIA
	DisplayPositionIndiaZoneIIB         DisplayPosition = 17 // India zone IIB
	DisplayPositionIndiaZoneIIIA        DisplayPosition = 18 // India zone IIIA
	DisplayPositionIndiaZoneIIIB        DisplayPosition = 19 // India zone IIIB
	DisplayPositionIndiaZoneIVA         DisplayPosition = 20 // India zone IVA
	DisplayPositionIndiaZoneIVB         DisplayPosition = 21 // India zone IVB
	DisplayPositionIrishTransverse      DisplayPosition = 22 // Irish Transverse Mercator
	DisplayPositionIrishGrid            DisplayPosition = 23 // Irish Grid
	DisplayPositionLoran                DisplayPosition = 24 // Loran TD
	DisplayPositionMaidenheadGrid       DisplayPosition = 25 // Maidenhead grid system
	DisplayPositionMgrsGrid             DisplayPosition = 26 // MGRS grid system
	DisplayPositionNewZealandGrid       DisplayPosition = 27 // New Zealand grid system
	DisplayPositionNewZealandTransverse DisplayPosition = 28 // New Zealand Transverse Mercator
	DisplayPositionQatarGrid            DisplayPosition = 29 // Qatar National Grid
	DisplayPositionModifiedSwedishGrid  DisplayPosition = 30 // Modified RT-90 (Sweden)
	DisplayPositionSwedishGrid          DisplayPosition = 31 // RT-90 (Sweden)
	DisplayPositionSouthAfricanGrid     DisplayPosition = 32 // South African Grid
	DisplayPositionSwissGrid            DisplayPosition = 33 // Swiss CH-1903 grid
	DisplayPositionTaiwanGrid           DisplayPosition = 34 // Taiwan Grid
	DisplayPositionUnitedStatesGrid     DisplayPosition = 35 // United States National Grid
	DisplayPositionUtmUpsGrid           DisplayPosition = 36 // UTM/UPS grid system
	DisplayPositionWestMalayan          DisplayPosition = 37 // West Malayan RSO
	DisplayPositionBorneoRso            DisplayPosition = 38 // Borneo RSO
	DisplayPositionEstonianGrid         DisplayPosition = 39 // Estonian grid system
	DisplayPositionLatvianGrid          DisplayPosition = 40 // Latvian Transverse Mercator
	DisplayPositionSwedishRef99Grid     DisplayPosition = 41 // Reference Grid 99 TM (Swedish)
	DisplayPositionInvalid              DisplayPosition = 0xFF
)

// DisplayPower represents the display_power FIT type.
type DisplayPower byte

const (
	DisplayPowerWatts      DisplayPower = 0
	DisplayPowerPercentFtp DisplayPower = 1
	DisplayPowerInvalid    DisplayPower = 0xFF
)

// Event represents the event FIT type.
type Event byte

const (
	EventTimer                 Event = 0  // Group 0.  Start / stop_all
	EventWorkout               Event = 3  // start / stop
	EventWorkoutStep           Event = 4  // Start at beginning of workout.  Stop at end of each step.
	EventPowerDown             Event = 5  // stop_all group 0
	EventPowerUp               Event = 6  // stop_all group 0
	EventOffCourse             Event = 7  // start / stop group 0
	EventSession               Event = 8  // Stop at end of each session.
	EventLap                   Event = 9  // Stop at end of each lap.
	EventCoursePoint           Event = 10 // marker
	EventBattery               Event = 11 // marker
	EventVirtualPartnerPace    Event = 12 // Group 1. Start at beginning of activity if VP enabled, when VP pace is changed during activity or VP enabled mid activity.  stop_disable when VP disabled.
	EventHrHighAlert           Event = 13 // Group 0.  Start / stop when in alert condition.
	EventHrLowAlert            Event = 14 // Group 0.  Start / stop when in alert condition.
	EventSpeedHighAlert        Event = 15 // Group 0.  Start / stop when in alert condition.
	EventSpeedLowAlert         Event = 16 // Group 0.  Start / stop when in alert condition.
	EventCadHighAlert          Event = 17 // Group 0.  Start / stop when in alert condition.
	EventCadLowAlert           Event = 18 // Group 0.  Start / stop when in alert condition.
	EventPowerHighAlert        Event = 19 // Group 0.  Start / stop when in alert condition.
	EventPowerLowAlert         Event = 20 // Group 0.  Start / stop when in alert condition.
	EventRecoveryHr            Event = 21 // marker
	EventBatteryLow            Event = 22 // marker
	EventTimeDurationAlert     Event = 23 // Group 1.  Start if enabled mid activity (not required at start of activity). Stop when duration is reached.  stop_disable if disabled.
	EventDistanceDurationAlert Event = 24 // Group 1.  Start if enabled mid activity (not required at start of activity). Stop when duration is reached.  stop_disable if disabled.
	EventCalorieDurationAlert  Event = 25 // Group 1.  Start if enabled mid activity (not required at start of activity). Stop when duration is reached.  stop_disable if disabled.
	EventActivity              Event = 26 // Group 1..  Stop at end of activity.
	EventFitnessEquipment      Event = 27 // marker
	EventLength                Event = 28 // Stop at end of each length.
	EventUserMarker            Event = 32 // marker
	EventSportPoint            Event = 33 // marker
	EventCalibration           Event = 36 // start/stop/marker
	EventFrontGearChange       Event = 42 // marker
	EventRearGearChange        Event = 43 // marker
	EventRiderPositionChange   Event = 44 // marker
	EventElevHighAlert         Event = 45 // Group 0.  Start / stop when in alert condition.
	EventElevLowAlert          Event = 46 // Group 0.  Start / stop when in alert condition.
	EventCommTimeout           Event = 47 // marker
	EventInvalid               Event = 0xFF
)

// EventType represents the event_type FIT type.
type EventType byte

const (
	EventTypeStart                  EventType = 0
	EventTypeStop                   EventType = 1
	EventTypeConsecutiveDepreciated EventType = 2
	EventTypeMarker                 EventType = 3
	EventTypeStopAll                EventType = 4
	EventTypeBeginDepreciated       EventType = 5
	EventTypeEndDepreciated         EventType = 6
	EventTypeEndAllDepreciated      EventType = 7
	EventTypeStopDisable            EventType = 8
	EventTypeStopDisableAll         EventType = 9
	EventTypeInvalid                EventType = 0xFF
)

// ExdDataUnits represents the exd_data_units FIT type.
type ExdDataUnits byte

const (
	ExdDataUnitsNoUnits                        ExdDataUnits = 0
	ExdDataUnitsLaps                           ExdDataUnits = 1
	ExdDataUnitsMilesPerHour                   ExdDataUnits = 2
	ExdDataUnitsKilometersPerHour              ExdDataUnits = 3
	ExdDataUnitsFeetPerHour                    ExdDataUnits = 4
	ExdDataUnitsMetersPerHour                  ExdDataUnits = 5
	ExdDataUnitsDegreesCelsius                 ExdDataUnits = 6
	ExdDataUnitsDegreesFarenheit               ExdDataUnits = 7
	ExdDataUnitsZone                           ExdDataUnits = 8
	ExdDataUnitsGear                           ExdDataUnits = 9
	ExdDataUnitsRpm                            ExdDataUnits = 10
	ExdDataUnitsBpm                            ExdDataUnits = 11
	ExdDataUnitsDegrees                        ExdDataUnits = 12
	ExdDataUnitsMillimeters                    ExdDataUnits = 13
	ExdDataUnitsMeters                         ExdDataUnits = 14
	ExdDataUnitsKilometers                     ExdDataUnits = 15
	ExdDataUnitsFeet                           ExdDataUnits = 16
	ExdDataUnitsYards                          ExdDataUnits = 17
	ExdDataUnitsKilofeet                       ExdDataUnits = 18
	ExdDataUnitsMiles                          ExdDataUnits = 19
	ExdDataUnitsTime                           ExdDataUnits = 20
	ExdDataUnitsEnumTurnType                   ExdDataUnits = 21
	ExdDataUnitsPercent                        ExdDataUnits = 22
	ExdDataUnitsWatts                          ExdDataUnits = 23
	ExdDataUnitsWattsPerKilogram               ExdDataUnits = 24
	ExdDataUnitsEnumBatteryStatus              ExdDataUnits = 25
	ExdDataUnitsEnumBikeLightBeamAngleMode     ExdDataUnits = 26
	ExdDataUnitsEnumBikeLightBatteryStatus     ExdDataUnits = 27
	ExdDataUnitsEnumBikeLightNetworkConfigType ExdDataUnits = 28
	ExdDataUnitsLights                         ExdDataUnits = 29
	ExdDataUnitsSeconds                        ExdDataUnits = 30
	ExdDataUnitsMinutes                        ExdDataUnits = 31
	ExdDataUnitsHours                          ExdDataUnits = 32
	ExdDataUnitsCalories                       ExdDataUnits = 33
	ExdDataUnitsKilojoules                     ExdDataUnits = 34
	ExdDataUnitsMilliseconds                   ExdDataUnits = 35
	ExdDataUnitsSecondPerMile                  ExdDataUnits = 36
	ExdDataUnitsSecondPerKilometer             ExdDataUnits = 37
	ExdDataUnitsCentimeter                     ExdDataUnits = 38
	ExdDataUnitsEnumCoursePoint                ExdDataUnits = 39
	ExdDataUnitsBradians                       ExdDataUnits = 40
	ExdDataUnitsEnumSport                      ExdDataUnits = 41
	ExdDataUnitsInchesHg                       ExdDataUnits = 42
	ExdDataUnitsMmHg                           ExdDataUnits = 43
	ExdDataUnitsMbars                          ExdDataUnits = 44
	ExdDataUnitsHectoPascals                   ExdDataUnits = 45
	ExdDataUnitsFeetPerMin                     ExdDataUnits = 46
	ExdDataUnitsMetersPerMin                   ExdDataUnits = 47
	ExdDataUnitsMetersPerSec                   ExdDataUnits = 48
	ExdDataUnitsEightCardinal                  ExdDataUnits = 49
	ExdDataUnitsInvalid                        ExdDataUnits = 0xFF
)

// ExdDescriptors represents the exd_descriptors FIT type.
type ExdDescriptors byte

const (
	ExdDescriptorsBikeLightBatteryStatus           ExdDescriptors = 0
	ExdDescriptorsBeamAngleStatus                  ExdDescriptors = 1
	ExdDescriptorsBateryLevel                      ExdDescriptors = 2
	ExdDescriptorsLightNetworkMode                 ExdDescriptors = 3
	ExdDescriptorsNumberLightsConnected            ExdDescriptors = 4
	ExdDescriptorsCadence                          ExdDescriptors = 5
	ExdDescriptorsDistance                         ExdDescriptors = 6
	ExdDescriptorsEstimatedTimeOfArrival           ExdDescriptors = 7
	ExdDescriptorsHeading                          ExdDescriptors = 8
	ExdDescriptorsTime                             ExdDescriptors = 9
	ExdDescriptorsBatteryLevel                     ExdDescriptors = 10
	ExdDescriptorsTrainerResistance                ExdDescriptors = 11
	ExdDescriptorsTrainerTargetPower               ExdDescriptors = 12
	ExdDescriptorsTimeSeated                       ExdDescriptors = 13
	ExdDescriptorsTimeStanding                     ExdDescriptors = 14
	ExdDescriptorsElevation                        ExdDescriptors = 15
	ExdDescriptorsGrade                            ExdDescriptors = 16
	ExdDescriptorsAscent                           ExdDescriptors = 17
	ExdDescriptorsDescent                          ExdDescriptors = 18
	ExdDescriptorsVerticalSpeed                    ExdDescriptors = 19
	ExdDescriptorsDi2BatteryLevel                  ExdDescriptors = 20
	ExdDescriptorsFrontGear                        ExdDescriptors = 21
	ExdDescriptorsRearGear                         ExdDescriptors = 22
	ExdDescriptorsGearRatio                        ExdDescriptors = 23
	ExdDescriptorsHeartRate                        ExdDescriptors = 24
	ExdDescriptorsHeartRateZone                    ExdDescriptors = 25
	ExdDescriptorsTimeInHeartRateZone              ExdDescriptors = 26
	ExdDescriptorsHeartRateReserve                 ExdDescriptors = 27
	ExdDescriptorsCalories                         ExdDescriptors = 28
	ExdDescriptorsGpsAccuracy                      ExdDescriptors = 29
	ExdDescriptorsGpsSignalStrength                ExdDescriptors = 30
	ExdDescriptorsTemperature                      ExdDescriptors = 31
	ExdDescriptorsTimeOfDay                        ExdDescriptors = 32
	ExdDescriptorsBalance                          ExdDescriptors = 33
	ExdDescriptorsPedalSmoothness                  ExdDescriptors = 34
	ExdDescriptorsPower                            ExdDescriptors = 35
	ExdDescriptorsFunctionalThresholdPower         ExdDescriptors = 36
	ExdDescriptorsIntensityFactor                  ExdDescriptors = 37
	ExdDescriptorsWork                             ExdDescriptors = 38
	ExdDescriptorsPowerRatio                       ExdDescriptors = 39
	ExdDescriptorsNormalizedPower                  ExdDescriptors = 40
	ExdDescriptorsTrainingStressScore              ExdDescriptors = 41
	ExdDescriptorsTimeOnZone                       ExdDescriptors = 42
	ExdDescriptorsSpeed                            ExdDescriptors = 43
	ExdDescriptorsLaps                             ExdDescriptors = 44
	ExdDescriptorsReps                             ExdDescriptors = 45
	ExdDescriptorsWorkoutStep                      ExdDescriptors = 46
	ExdDescriptorsCourseDistance                   ExdDescriptors = 47
	ExdDescriptorsNavigationDistance               ExdDescriptors = 48
	ExdDescriptorsCourseEstimatedTimeOfArrival     ExdDescriptors = 49
	ExdDescriptorsNavigationEstimatedTimeOfArrival ExdDescriptors = 50
	ExdDescriptorsCourseTime                       ExdDescriptors = 51
	ExdDescriptorsNavigationTime                   ExdDescriptors = 52
	ExdDescriptorsCourseHeading                    ExdDescriptors = 53
	ExdDescriptorsNavigationHeading                ExdDescriptors = 54
	ExdDescriptorsPowerZone                        ExdDescriptors = 55
	ExdDescriptorsTorqueEffectiveness              ExdDescriptors = 56
	ExdDescriptorsTimerTime                        ExdDescriptors = 57
	ExdDescriptorsPowerWeightRatio                 ExdDescriptors = 58
	ExdDescriptorsLeftPlatformCenterOffset         ExdDescriptors = 59
	ExdDescriptorsRightPlatformCenterOffset        ExdDescriptors = 60
	ExdDescriptorsLeftPowerPhaseStartAngle         ExdDescriptors = 61
	ExdDescriptorsRightPowerPhaseStartAngle        ExdDescriptors = 62
	ExdDescriptorsLeftPowerPhaseFinishAngle        ExdDescriptors = 63
	ExdDescriptorsRightPowerPhaseFinishAngle       ExdDescriptors = 64
	ExdDescriptorsGears                            ExdDescriptors = 65 // Combined gear information
	ExdDescriptorsPace                             ExdDescriptors = 66
	ExdDescriptorsTrainingEffect                   ExdDescriptors = 67
	ExdDescriptorsVerticalOscillation              ExdDescriptors = 68
	ExdDescriptorsVerticalRatio                    ExdDescriptors = 69
	ExdDescriptorsGroundContactTime                ExdDescriptors = 70
	ExdDescriptorsLeftGroundContactTimeBalance     ExdDescriptors = 71
	ExdDescriptorsRightGroundContactTimeBalance    ExdDescriptors = 72
	ExdDescriptorsStrideLength                     ExdDescriptors = 73
	ExdDescriptorsRunningCadence                   ExdDescriptors = 74
	ExdDescriptorsPerformanceCondition             ExdDescriptors = 75
	ExdDescriptorsCourseType                       ExdDescriptors = 76
	ExdDescriptorsTimeInPowerZone                  ExdDescriptors = 77
	ExdDescriptorsNavigationTurn                   ExdDescriptors = 78
	ExdDescriptorsCourseLocation                   ExdDescriptors = 79
	ExdDescriptorsNavigationLocation               ExdDescriptors = 80
	ExdDescriptorsCompass                          ExdDescriptors = 81
	ExdDescriptorsGearCombo                        ExdDescriptors = 82
	ExdDescriptorsMuscleOxygen                     ExdDescriptors = 83
	ExdDescriptorsIcon                             ExdDescriptors = 84
	ExdDescriptorsCompassHeading                   ExdDescriptors = 85
	ExdDescriptorsGpsHeading                       ExdDescriptors = 86
	ExdDescriptorsGpsElevation                     ExdDescriptors = 87
	ExdDescriptorsAnaerobicTrainingEffect          ExdDescriptors = 88
	ExdDescriptorsCourse                           ExdDescriptors = 89
	ExdDescriptorsOffCourse                        ExdDescriptors = 90
	ExdDescriptorsGlideRatio                       ExdDescriptors = 91
	ExdDescriptorsVerticalDistance                 ExdDescriptors = 92
	ExdDescriptorsVmg                              ExdDescriptors = 93
	ExdDescriptorsAmbientPressure                  ExdDescriptors = 94
	ExdDescriptorsPressure                         ExdDescriptors = 95
	ExdDescriptorsVam                              ExdDescriptors = 96
	ExdDescriptorsInvalid                          ExdDescriptors = 0xFF
)

// ExdDisplayType represents the exd_display_type FIT type.
type ExdDisplayType byte

const (
	ExdDisplayTypeNumerical         ExdDisplayType = 0
	ExdDisplayTypeSimple            ExdDisplayType = 1
	ExdDisplayTypeGraph             ExdDisplayType = 2
	ExdDisplayTypeBar               ExdDisplayType = 3
	ExdDisplayTypeCircleGraph       ExdDisplayType = 4
	ExdDisplayTypeVirtualPartner    ExdDisplayType = 5
	ExdDisplayTypeBalance           ExdDisplayType = 6
	ExdDisplayTypeStringList        ExdDisplayType = 7
	ExdDisplayTypeString            ExdDisplayType = 8
	ExdDisplayTypeSimpleDynamicIcon ExdDisplayType = 9
	ExdDisplayTypeGauge             ExdDisplayType = 10
	ExdDisplayTypeInvalid           ExdDisplayType = 0xFF
)

// ExdLayout represents the exd_layout FIT type.
type ExdLayout byte

const (
	ExdLayoutFullScreen                ExdLayout = 0
	ExdLayoutHalfVertical              ExdLayout = 1
	ExdLayoutHalfHorizontal            ExdLayout = 2
	ExdLayoutHalfVerticalRightSplit    ExdLayout = 3
	ExdLayoutHalfHorizontalBottomSplit ExdLayout = 4
	ExdLayoutFullQuarterSplit          ExdLayout = 5
	ExdLayoutHalfVerticalLeftSplit     ExdLayout = 6
	ExdLayoutHalfHorizontalTopSplit    ExdLayout = 7
	ExdLayoutInvalid                   ExdLayout = 0xFF
)

// ExdQualifiers represents the exd_qualifiers FIT type.
type ExdQualifiers byte

const (
	ExdQualifiersNoQualifier              ExdQualifiers = 0
	ExdQualifiersInstantaneous            ExdQualifiers = 1
	ExdQualifiersAverage                  ExdQualifiers = 2
	ExdQualifiersLap                      ExdQualifiers = 3
	ExdQualifiersMaximum                  ExdQualifiers = 4
	ExdQualifiersMaximumAverage           ExdQualifiers = 5
	ExdQualifiersMaximumLap               ExdQualifiers = 6
	ExdQualifiersLastLap                  ExdQualifiers = 7
	ExdQualifiersAverageLap               ExdQualifiers = 8
	ExdQualifiersToDestination            ExdQualifiers = 9
	ExdQualifiersToGo                     ExdQualifiers = 10
	ExdQualifiersToNext                   ExdQualifiers = 11
	ExdQualifiersNextCoursePoint          ExdQualifiers = 12
	ExdQualifiersTotal                    ExdQualifiers = 13
	ExdQualifiersThreeSecondAverage       ExdQualifiers = 14
	ExdQualifiersTenSecondAverage         ExdQualifiers = 15
	ExdQualifiersThirtySecondAverage      ExdQualifiers = 16
	ExdQualifiersPercentMaximum           ExdQualifiers = 17
	ExdQualifiersPercentMaximumAverage    ExdQualifiers = 18
	ExdQualifiersLapPercentMaximum        ExdQualifiers = 19
	ExdQualifiersElapsed                  ExdQualifiers = 20
	ExdQualifiersSunrise                  ExdQualifiers = 21
	ExdQualifiersSunset                   ExdQualifiers = 22
	ExdQualifiersComparedToVirtualPartner ExdQualifiers = 23
	ExdQualifiersMaximum24h               ExdQualifiers = 24
	ExdQualifiersMinimum24h               ExdQualifiers = 25
	ExdQualifiersMinimum                  ExdQualifiers = 26
	ExdQualifiersFirst                    ExdQualifiers = 27
	ExdQualifiersSecond                   ExdQualifiers = 28
	ExdQualifiersThird                    ExdQualifiers = 29
	ExdQualifiersShifter                  ExdQualifiers = 30
	ExdQualifiersLastSport                ExdQualifiers = 31
	ExdQualifiersMoving                   ExdQualifiers = 32
	ExdQualifiersStopped                  ExdQualifiers = 33
	ExdQualifiersZone9                    ExdQualifiers = 242
	ExdQualifiersZone8                    ExdQualifiers = 243
	ExdQualifiersZone7                    ExdQualifiers = 244
	ExdQualifiersZone6                    ExdQualifiers = 245
	ExdQualifiersZone5                    ExdQualifiers = 246
	ExdQualifiersZone4                    ExdQualifiers = 247
	ExdQualifiersZone3                    ExdQualifiers = 248
	ExdQualifiersZone2                    ExdQualifiers = 249
	ExdQualifiersZone1                    ExdQualifiers = 250
	ExdQualifiersInvalid                  ExdQualifiers = 0xFF
)

// FileFlags represents the file_flags FIT type.
type FileFlags uint8

const (
	FileFlagsRead    FileFlags = 0x02
	FileFlagsWrite   FileFlags = 0x04
	FileFlagsErase   FileFlags = 0x08
	FileFlagsInvalid FileFlags = 0x00
)

// FileType represents the file FIT type.
type FileType byte

const (
	FileTypeDevice           FileType = 1  // Read only, single file. Must be in root directory.
	FileTypeSettings         FileType = 2  // Read/write, single file. Directory=Settings
	FileTypeSport            FileType = 3  // Read/write, multiple files, file number = sport type. Directory=Sports
	FileTypeActivity         FileType = 4  // Read/erase, multiple files. Directory=Activities
	FileTypeWorkout          FileType = 5  // Read/write/erase, multiple files. Directory=Workouts
	FileTypeCourse           FileType = 6  // Read/write/erase, multiple files. Directory=Courses
	FileTypeSchedules        FileType = 7  // Read/write, single file. Directory=Schedules
	FileTypeWeight           FileType = 9  // Read only, single file. Circular buffer. All message definitions at start of file. Directory=Weight
	FileTypeTotals           FileType = 10 // Read only, single file. Directory=Totals
	FileTypeGoals            FileType = 11 // Read/write, single file. Directory=Goals
	FileTypeBloodPressure    FileType = 14 // Read only. Directory=Blood Pressure
	FileTypeMonitoringA      FileType = 15 // Read only. Directory=Monitoring. File number=sub type.
	FileTypeActivitySummary  FileType = 20 // Read/erase, multiple files. Directory=Activities
	FileTypeMonitoringDaily  FileType = 28
	FileTypeMonitoringB      FileType = 32   // Read only. Directory=Monitoring. File number=identifier
	FileTypeSegment          FileType = 34   // Read/write/erase. Multiple Files.  Directory=Segments
	FileTypeSegmentList      FileType = 35   // Read/write/erase. Single File.  Directory=Segments
	FileTypeExdConfiguration FileType = 40   // Read/write/erase. Single File. Directory=Settings
	FileTypeMfgRangeMin      FileType = 0xF7 // 0xF7 - 0xFE reserved for manufacturer specific file types
	FileTypeMfgRangeMax      FileType = 0xFE // 0xF7 - 0xFE reserved for manufacturer specific file types
	FileTypeInvalid          FileType = 0xFF
)

// FitBaseType represents the fit_base_type FIT type.
type FitBaseType uint8

const (
	FitBaseTypeEnum    FitBaseType = 0
	FitBaseTypeSint8   FitBaseType = 1
	FitBaseTypeUint8   FitBaseType = 2
	FitBaseTypeSint16  FitBaseType = 131
	FitBaseTypeUint16  FitBaseType = 132
	FitBaseTypeSint32  FitBaseType = 133
	FitBaseTypeUint32  FitBaseType = 134
	FitBaseTypeString  FitBaseType = 7
	FitBaseTypeFloat32 FitBaseType = 136
	FitBaseTypeFloat64 FitBaseType = 137
	FitBaseTypeUint8z  FitBaseType = 10
	FitBaseTypeUint16z FitBaseType = 139
	FitBaseTypeUint32z FitBaseType = 140
	FitBaseTypeByte    FitBaseType = 13
	FitBaseTypeSint64  FitBaseType = 142
	FitBaseTypeUint64  FitBaseType = 143
	FitBaseTypeUint64z FitBaseType = 144
	FitBaseTypeInvalid FitBaseType = 0xFF
)

// FitBaseUnit represents the fit_base_unit FIT type.
type FitBaseUnit uint16

const (
	FitBaseUnitOther    FitBaseUnit = 0
	FitBaseUnitKilogram FitBaseUnit = 1
	FitBaseUnitPound    FitBaseUnit = 2
	FitBaseUnitInvalid  FitBaseUnit = 0xFFFF
)

// FitnessEquipmentState represents the fitness_equipment_state FIT type.
type FitnessEquipmentState byte

const (
	FitnessEquipmentStateReady   FitnessEquipmentState = 0
	FitnessEquipmentStateInUse   FitnessEquipmentState = 1
	FitnessEquipmentStatePaused  FitnessEquipmentState = 2
	FitnessEquipmentStateUnknown FitnessEquipmentState = 3 // lost connection to fitness equipment
	FitnessEquipmentStateInvalid FitnessEquipmentState = 0xFF
)

// GarminProduct represents the garmin_product FIT type.
type GarminProduct uint16

const (
	GarminProductHrm1                      GarminProduct = 1
	GarminProductAxh01                     GarminProduct = 2 // AXH01 HRM chipset
	GarminProductAxb01                     GarminProduct = 3
	GarminProductAxb02                     GarminProduct = 4
	GarminProductHrm2ss                    GarminProduct = 5
	GarminProductDsiAlf02                  GarminProduct = 6
	GarminProductHrm3ss                    GarminProduct = 7
	GarminProductHrmRunSingleByteProductId GarminProduct = 8  // hrm_run model for HRM ANT+ messaging
	GarminProductBsm                       GarminProduct = 9  // BSM model for ANT+ messaging
	GarminProductBcm                       GarminProduct = 10 // BCM model for ANT+ messaging
	GarminProductAxs01                     GarminProduct = 11 // AXS01 HRM Bike Chipset model for ANT+ messaging
	GarminProductHrmTriSingleByteProductId GarminProduct = 12 // hrm_tri model for HRM ANT+ messaging
	GarminProductFr225SingleByteProductId  GarminProduct = 14 // fr225 model for HRM ANT+ messaging
	GarminProductFr301China                GarminProduct = 473
	GarminProductFr301Japan                GarminProduct = 474
	GarminProductFr301Korea                GarminProduct = 475
	GarminProductFr301Taiwan               GarminProduct = 494
	GarminProductFr405                     GarminProduct = 717 // Forerunner 405
	GarminProductFr50                      GarminProduct = 782 // Forerunner 50
	GarminProductFr405Japan                GarminProduct = 987
	GarminProductFr60                      GarminProduct = 988 // Forerunner 60
	GarminProductDsiAlf01                  GarminProduct = 1011
	GarminProductFr310xt                   GarminProduct = 1018 // Forerunner 310
	GarminProductEdge500                   GarminProduct = 1036
	GarminProductFr110                     GarminProduct = 1124 // Forerunner 110
	GarminProductEdge800                   GarminProduct = 1169
	GarminProductEdge500Taiwan             GarminProduct = 1199
	GarminProductEdge500Japan              GarminProduct = 1213
	GarminProductChirp                     GarminProduct = 1253
	GarminProductFr110Japan                GarminProduct = 1274
	GarminProductEdge200                   GarminProduct = 1325
	GarminProductFr910xt                   GarminProduct = 1328
	GarminProductEdge800Taiwan             GarminProduct = 1333
	GarminProductEdge800Japan              GarminProduct = 1334
	GarminProductAlf04                     GarminProduct = 1341
	GarminProductFr610                     GarminProduct = 1345
	GarminProductFr210Japan                GarminProduct = 1360
	GarminProductVectorSs                  GarminProduct = 1380
	GarminProductVectorCp                  GarminProduct = 1381
	GarminProductEdge800China              GarminProduct = 1386
	GarminProductEdge500China              GarminProduct = 1387
	GarminProductFr610Japan                GarminProduct = 1410
	GarminProductEdge500Korea              GarminProduct = 1422
	GarminProductFr70                      GarminProduct = 1436
	GarminProductFr310xt4t                 GarminProduct = 1446
	GarminProductAmx                       GarminProduct = 1461
	GarminProductFr10                      GarminProduct = 1482
	GarminProductEdge800Korea              GarminProduct = 1497
	GarminProductSwim                      GarminProduct = 1499
	GarminProductFr910xtChina              GarminProduct = 1537
	GarminProductFenix                     GarminProduct = 1551
	GarminProductEdge200Taiwan             GarminProduct = 1555
	GarminProductEdge510                   GarminProduct = 1561
	GarminProductEdge810                   GarminProduct = 1567
	GarminProductTempe                     GarminProduct = 1570
	GarminProductFr910xtJapan              GarminProduct = 1600
	GarminProductFr620                     GarminProduct = 1623
	GarminProductFr220                     GarminProduct = 1632
	GarminProductFr910xtKorea              GarminProduct = 1664
	GarminProductFr10Japan                 GarminProduct = 1688
	GarminProductEdge810Japan              GarminProduct = 1721
	GarminProductVirbElite                 GarminProduct = 1735
	GarminProductEdgeTouring               GarminProduct = 1736 // Also Edge Touring Plus
	GarminProductEdge510Japan              GarminProduct = 1742
	GarminProductHrmTri                    GarminProduct = 1743
	GarminProductHrmRun                    GarminProduct = 1752
	GarminProductFr920xt                   GarminProduct = 1765
	GarminProductEdge510Asia               GarminProduct = 1821
	GarminProductEdge810China              GarminProduct = 1822
	GarminProductEdge810Taiwan             GarminProduct = 1823
	GarminProductEdge1000                  GarminProduct = 1836
	GarminProductVivoFit                   GarminProduct = 1837
	GarminProductVirbRemote                GarminProduct = 1853
	GarminProductVivoKi                    GarminProduct = 1885
	GarminProductFr15                      GarminProduct = 1903
	GarminProductVivoActive                GarminProduct = 1907
	GarminProductEdge510Korea              GarminProduct = 1918
	GarminProductFr620Japan                GarminProduct = 1928
	GarminProductFr620China                GarminProduct = 1929
	GarminProductFr220Japan                GarminProduct = 1930
	GarminProductFr220China                GarminProduct = 1931
	GarminProductApproachS6                GarminProduct = 1936
	GarminProductVivoSmart                 GarminProduct = 1956
	GarminProductFenix2                    GarminProduct = 1967
	GarminProductEpix                      GarminProduct = 1988
	GarminProductFenix3                    GarminProduct = 2050
	GarminProductEdge1000Taiwan            GarminProduct = 2052
	GarminProductEdge1000Japan             GarminProduct = 2053
	GarminProductFr15Japan                 GarminProduct = 2061
	GarminProductEdge520                   GarminProduct = 2067
	GarminProductEdge1000China             GarminProduct = 2070
	GarminProductFr620Russia               GarminProduct = 2072
	GarminProductFr220Russia               GarminProduct = 2073
	GarminProductVectorS                   GarminProduct = 2079
	GarminProductEdge1000Korea             GarminProduct = 2100
	GarminProductFr920xtTaiwan             GarminProduct = 2130
	GarminProductFr920xtChina              GarminProduct = 2131
	GarminProductFr920xtJapan              GarminProduct = 2132
	GarminProductVirbx                     GarminProduct = 2134
	GarminProductVivoSmartApac             GarminProduct = 2135
	GarminProductEtrexTouch                GarminProduct = 2140
	GarminProductEdge25                    GarminProduct = 2147
	GarminProductFr25                      GarminProduct = 2148
	GarminProductVivoFit2                  GarminProduct = 2150
	GarminProductFr225                     GarminProduct = 2153
	GarminProductFr630                     GarminProduct = 2156
	GarminProductFr230                     GarminProduct = 2157
	GarminProductVivoActiveApac            GarminProduct = 2160
	GarminProductVector2                   GarminProduct = 2161
	GarminProductVector2s                  GarminProduct = 2162
	GarminProductVirbxe                    GarminProduct = 2172
	GarminProductFr620Taiwan               GarminProduct = 2173
	GarminProductFr220Taiwan               GarminProduct = 2174
	GarminProductTruswing                  GarminProduct = 2175
	GarminProductFenix3China               GarminProduct = 2188
	GarminProductFenix3Twn                 GarminProduct = 2189
	GarminProductVariaHeadlight            GarminProduct = 2192
	GarminProductVariaTaillightOld         GarminProduct = 2193
	GarminProductEdgeExplore1000           GarminProduct = 2204
	GarminProductFr225Asia                 GarminProduct = 2219
	GarminProductVariaRadarTaillight       GarminProduct = 2225
	GarminProductVariaRadarDisplay         GarminProduct = 2226
	GarminProductEdge20                    GarminProduct = 2238
	GarminProductD2Bravo                   GarminProduct = 2262
	GarminProductApproachS20               GarminProduct = 2266
	GarminProductVariaRemote               GarminProduct = 2276
	GarminProductHrm4Run                   GarminProduct = 2327
	GarminProductVivoActiveHr              GarminProduct = 2337
	GarminProductVivoSmartGpsHr            GarminProduct = 2347
	GarminProductVivoSmartHr               GarminProduct = 2348
	GarminProductVivoMove                  GarminProduct = 2368
	GarminProductVariaVision               GarminProduct = 2398
	GarminProductVivoFit3                  GarminProduct = 2406
	GarminProductFenix3Hr                  GarminProduct = 2413
	GarminProductVirbUltra30               GarminProduct = 2417
	GarminProductIndexSmartScale           GarminProduct = 2429
	GarminProductFr235                     GarminProduct = 2431
	GarminProductFenix3Chronos             GarminProduct = 2432
	GarminProductOregon7xx                 GarminProduct = 2441
	GarminProductRino7xx                   GarminProduct = 2444
	GarminProductNautix                    GarminProduct = 2496
	GarminProductEdge820                   GarminProduct = 2530
	GarminProductEdgeExplore820            GarminProduct = 2531
	GarminProductFenix5s                   GarminProduct = 2544
	GarminProductD2BravoTitanium           GarminProduct = 2547
	GarminProductRunningDynamicsPod        GarminProduct = 2593
	GarminProductFenix5x                   GarminProduct = 2604
	GarminProductVivoFitJr                 GarminProduct = 2606
	GarminProductFr935                     GarminProduct = 2691
	GarminProductFenix5                    GarminProduct = 2697
	GarminProductSdm4                      GarminProduct = 10007 // SDM4 footpod
	GarminProductEdgeRemote                GarminProduct = 10014
	GarminProductTrainingCenter            GarminProduct = 20119
	GarminProductConnectiqSimulator        GarminProduct = 65531
	GarminProductAndroidAntplusPlugin      GarminProduct = 65532
	GarminProductConnect                   GarminProduct = 65534 // Garmin Connect website
	GarminProductInvalid                   GarminProduct = 0xFFFF
)

// Gender represents the gender FIT type.
type Gender byte

const (
	GenderFemale  Gender = 0
	GenderMale    Gender = 1
	GenderInvalid Gender = 0xFF
)

// Goal represents the goal FIT type.
type Goal byte

const (
	GoalTime          Goal = 0
	GoalDistance      Goal = 1
	GoalCalories      Goal = 2
	GoalFrequency     Goal = 3
	GoalSteps         Goal = 4
	GoalAscent        Goal = 5
	GoalActiveMinutes Goal = 6
	GoalInvalid       Goal = 0xFF
)

// GoalRecurrence represents the goal_recurrence FIT type.
type GoalRecurrence byte

const (
	GoalRecurrenceOff     GoalRecurrence = 0
	GoalRecurrenceDaily   GoalRecurrence = 1
	GoalRecurrenceWeekly  GoalRecurrence = 2
	GoalRecurrenceMonthly GoalRecurrence = 3
	GoalRecurrenceYearly  GoalRecurrence = 4
	GoalRecurrenceCustom  GoalRecurrence = 5
	GoalRecurrenceInvalid GoalRecurrence = 0xFF
)

// GoalSource represents the goal_source FIT type.
type GoalSource byte

const (
	GoalSourceAuto      GoalSource = 0 // Device generated
	GoalSourceCommunity GoalSource = 1 // Social network sourced goal
	GoalSourceUser      GoalSource = 2 // Manually generated
	GoalSourceInvalid   GoalSource = 0xFF
)

// HrType represents the hr_type FIT type.
type HrType byte

const (
	HrTypeNormal    HrType = 0
	HrTypeIrregular HrType = 1
	HrTypeInvalid   HrType = 0xFF
)

// HrZoneCalc represents the hr_zone_calc FIT type.
type HrZoneCalc byte

const (
	HrZoneCalcCustom       HrZoneCalc = 0
	HrZoneCalcPercentMaxHr HrZoneCalc = 1
	HrZoneCalcPercentHrr   HrZoneCalc = 2
	HrZoneCalcInvalid      HrZoneCalc = 0xFF
)

// Intensity represents the intensity FIT type.
type Intensity byte

const (
	IntensityActive   Intensity = 0
	IntensityRest     Intensity = 1
	IntensityWarmup   Intensity = 2
	IntensityCooldown Intensity = 3
	IntensityInvalid  Intensity = 0xFF
)

// Language represents the language FIT type.
type Language byte

const (
	LanguageEnglish             Language = 0
	LanguageFrench              Language = 1
	LanguageItalian             Language = 2
	LanguageGerman              Language = 3
	LanguageSpanish             Language = 4
	LanguageCroatian            Language = 5
	LanguageCzech               Language = 6
	LanguageDanish              Language = 7
	LanguageDutch               Language = 8
	LanguageFinnish             Language = 9
	LanguageGreek               Language = 10
	LanguageHungarian           Language = 11
	LanguageNorwegian           Language = 12
	LanguagePolish              Language = 13
	LanguagePortuguese          Language = 14
	LanguageSlovakian           Language = 15
	LanguageSlovenian           Language = 16
	LanguageSwedish             Language = 17
	LanguageRussian             Language = 18
	LanguageTurkish             Language = 19
	LanguageLatvian             Language = 20
	LanguageUkrainian           Language = 21
	LanguageArabic              Language = 22
	LanguageFarsi               Language = 23
	LanguageBulgarian           Language = 24
	LanguageRomanian            Language = 25
	LanguageChinese             Language = 26
	LanguageJapanese            Language = 27
	LanguageKorean              Language = 28
	LanguageTaiwanese           Language = 29
	LanguageThai                Language = 30
	LanguageHebrew              Language = 31
	LanguageBrazilianPortuguese Language = 32
	LanguageIndonesian          Language = 33
	LanguageMalaysian           Language = 34
	LanguageVietnamese          Language = 35
	LanguageBurmese             Language = 36
	LanguageMongolian           Language = 37
	LanguageCustom              Language = 254
	LanguageInvalid             Language = 0xFF
)

// LanguageBits0 represents the language_bits_0 FIT type.
type LanguageBits0 uint8

const (
	LanguageBits0English  LanguageBits0 = 0x01
	LanguageBits0French   LanguageBits0 = 0x02
	LanguageBits0Italian  LanguageBits0 = 0x04
	LanguageBits0German   LanguageBits0 = 0x08
	LanguageBits0Spanish  LanguageBits0 = 0x10
	LanguageBits0Croatian LanguageBits0 = 0x20
	LanguageBits0Czech    LanguageBits0 = 0x40
	LanguageBits0Danish   LanguageBits0 = 0x80
	LanguageBits0Invalid  LanguageBits0 = 0x00
)

// LanguageBits1 represents the language_bits_1 FIT type.
type LanguageBits1 uint8

const (
	LanguageBits1Dutch      LanguageBits1 = 0x01
	LanguageBits1Finnish    LanguageBits1 = 0x02
	LanguageBits1Greek      LanguageBits1 = 0x04
	LanguageBits1Hungarian  LanguageBits1 = 0x08
	LanguageBits1Norwegian  LanguageBits1 = 0x10
	LanguageBits1Polish     LanguageBits1 = 0x20
	LanguageBits1Portuguese LanguageBits1 = 0x40
	LanguageBits1Slovakian  LanguageBits1 = 0x80
	LanguageBits1Invalid    LanguageBits1 = 0x00
)

// LanguageBits2 represents the language_bits_2 FIT type.
type LanguageBits2 uint8

const (
	LanguageBits2Slovenian LanguageBits2 = 0x01
	LanguageBits2Swedish   LanguageBits2 = 0x02
	LanguageBits2Russian   LanguageBits2 = 0x04
	LanguageBits2Turkish   LanguageBits2 = 0x08
	LanguageBits2Latvian   LanguageBits2 = 0x10
	LanguageBits2Ukrainian LanguageBits2 = 0x20
	LanguageBits2Arabic    LanguageBits2 = 0x40
	LanguageBits2Farsi     LanguageBits2 = 0x80
	LanguageBits2Invalid   LanguageBits2 = 0x00
)

// LanguageBits3 represents the language_bits_3 FIT type.
type LanguageBits3 uint8

const (
	LanguageBits3Bulgarian LanguageBits3 = 0x01
	LanguageBits3Romanian  LanguageBits3 = 0x02
	LanguageBits3Chinese   LanguageBits3 = 0x04
	LanguageBits3Japanese  LanguageBits3 = 0x08
	LanguageBits3Korean    LanguageBits3 = 0x10
	LanguageBits3Taiwanese LanguageBits3 = 0x20
	LanguageBits3Thai      LanguageBits3 = 0x40
	LanguageBits3Hebrew    LanguageBits3 = 0x80
	LanguageBits3Invalid   LanguageBits3 = 0x00
)

// LanguageBits4 represents the language_bits_4 FIT type.
type LanguageBits4 uint8

const (
	LanguageBits4BrazilianPortuguese LanguageBits4 = 0x01
	LanguageBits4Indonesian          LanguageBits4 = 0x02
	LanguageBits4Malaysian           LanguageBits4 = 0x04
	LanguageBits4Vietnamese          LanguageBits4 = 0x08
	LanguageBits4Burmese             LanguageBits4 = 0x10
	LanguageBits4Mongolian           LanguageBits4 = 0x20
	LanguageBits4Invalid             LanguageBits4 = 0x00
)

// LapTrigger represents the lap_trigger FIT type.
type LapTrigger byte

const (
	LapTriggerManual           LapTrigger = 0
	LapTriggerTime             LapTrigger = 1
	LapTriggerDistance         LapTrigger = 2
	LapTriggerPositionStart    LapTrigger = 3
	LapTriggerPositionLap      LapTrigger = 4
	LapTriggerPositionWaypoint LapTrigger = 5
	LapTriggerPositionMarked   LapTrigger = 6
	LapTriggerSessionEnd       LapTrigger = 7
	LapTriggerFitnessEquipment LapTrigger = 8
	LapTriggerInvalid          LapTrigger = 0xFF
)

// LeftRightBalance represents the left_right_balance FIT type.
type LeftRightBalance uint8

const (
	LeftRightBalanceMask    LeftRightBalance = 0x7F // % contribution
	LeftRightBalanceRight   LeftRightBalance = 0x80 // data corresponds to right if set, otherwise unknown
	LeftRightBalanceInvalid LeftRightBalance = 0xFF
)

// LeftRightBalance100 represents the left_right_balance_100 FIT type.
type LeftRightBalance100 uint16

const (
	LeftRightBalance100Mask    LeftRightBalance100 = 0x3FFF // % contribution scaled by 100
	LeftRightBalance100Right   LeftRightBalance100 = 0x8000 // data corresponds to right if set, otherwise unknown
	LeftRightBalance100Invalid LeftRightBalance100 = 0xFFFF
)

// LengthType represents the length_type FIT type.
type LengthType byte

const (
	LengthTypeIdle    LengthType = 0 // Rest period. Length with no strokes
	LengthTypeActive  LengthType = 1 // Length with strokes.
	LengthTypeInvalid LengthType = 0xFF
)

// LocaltimeIntoDay represents the localtime_into_day FIT type.
type LocaltimeIntoDay uint32

const (
	LocaltimeIntoDayInvalid LocaltimeIntoDay = 0xFFFFFFFF
)

// Manufacturer represents the manufacturer FIT type.
type Manufacturer uint16

const (
	ManufacturerGarmin                 Manufacturer = 1
	ManufacturerGarminFr405Antfs       Manufacturer = 2 // Do not use.  Used by FR405 for ANTFS man id.
	ManufacturerZephyr                 Manufacturer = 3
	ManufacturerDayton                 Manufacturer = 4
	ManufacturerIdt                    Manufacturer = 5
	ManufacturerSrm                    Manufacturer = 6
	ManufacturerQuarq                  Manufacturer = 7
	ManufacturerIbike                  Manufacturer = 8
	ManufacturerSaris                  Manufacturer = 9
	ManufacturerSparkHk                Manufacturer = 10
	ManufacturerTanita                 Manufacturer = 11
	ManufacturerEchowell               Manufacturer = 12
	ManufacturerDynastreamOem          Manufacturer = 13
	ManufacturerNautilus               Manufacturer = 14
	ManufacturerDynastream             Manufacturer = 15
	ManufacturerTimex                  Manufacturer = 16
	ManufacturerMetrigear              Manufacturer = 17
	ManufacturerXelic                  Manufacturer = 18
	ManufacturerBeurer                 Manufacturer = 19
	ManufacturerCardiosport            Manufacturer = 20
	ManufacturerAAndD                  Manufacturer = 21
	ManufacturerHmm                    Manufacturer = 22
	ManufacturerSuunto                 Manufacturer = 23
	ManufacturerThitaElektronik        Manufacturer = 24
	ManufacturerGpulse                 Manufacturer = 25
	ManufacturerCleanMobile            Manufacturer = 26
	ManufacturerPedalBrain             Manufacturer = 27
	ManufacturerPeaksware              Manufacturer = 28
	ManufacturerSaxonar                Manufacturer = 29
	ManufacturerLemondFitness          Manufacturer = 30
	ManufacturerDexcom                 Manufacturer = 31
	ManufacturerWahooFitness           Manufacturer = 32
	ManufacturerOctaneFitness          Manufacturer = 33
	ManufacturerArchinoetics           Manufacturer = 34
	ManufacturerTheHurtBox             Manufacturer = 35
	ManufacturerCitizenSystems         Manufacturer = 36
	ManufacturerMagellan               Manufacturer = 37
	ManufacturerOsynce                 Manufacturer = 38
	ManufacturerHolux                  Manufacturer = 39
	ManufacturerConcept2               Manufacturer = 40
	ManufacturerOneGiantLeap           Manufacturer = 42
	ManufacturerAceSensor              Manufacturer = 43
	ManufacturerBrimBrothers           Manufacturer = 44
	ManufacturerXplova                 Manufacturer = 45
	ManufacturerPerceptionDigital      Manufacturer = 46
	ManufacturerBf1systems             Manufacturer = 47
	ManufacturerPioneer                Manufacturer = 48
	ManufacturerSpantec                Manufacturer = 49
	ManufacturerMetalogics             Manufacturer = 50
	Manufacturer4iiiis                 Manufacturer = 51
	ManufacturerSeikoEpson             Manufacturer = 52
	ManufacturerSeikoEpsonOem          Manufacturer = 53
	ManufacturerIforPowell             Manufacturer = 54
	ManufacturerMaxwellGuider          Manufacturer = 55
	ManufacturerStarTrac               Manufacturer = 56
	ManufacturerBreakaway              Manufacturer = 57
	ManufacturerAlatechTechnologyLtd   Manufacturer = 58
	ManufacturerMioTechnologyEurope    Manufacturer = 59
	ManufacturerRotor                  Manufacturer = 60
	ManufacturerGeonaute               Manufacturer = 61
	ManufacturerIdBike                 Manufacturer = 62
	ManufacturerSpecialized            Manufacturer = 63
	ManufacturerWtek                   Manufacturer = 64
	ManufacturerPhysicalEnterprises    Manufacturer = 65
	ManufacturerNorthPoleEngineering   Manufacturer = 66
	ManufacturerBkool                  Manufacturer = 67
	ManufacturerCateye                 Manufacturer = 68
	ManufacturerStagesCycling          Manufacturer = 69
	ManufacturerSigmasport             Manufacturer = 70
	ManufacturerTomtom                 Manufacturer = 71
	ManufacturerPeripedal              Manufacturer = 72
	ManufacturerWattbike               Manufacturer = 73
	ManufacturerMoxy                   Manufacturer = 76
	ManufacturerCiclosport             Manufacturer = 77
	ManufacturerPowerbahn              Manufacturer = 78
	ManufacturerAcornProjectsAps       Manufacturer = 79
	ManufacturerLifebeam               Manufacturer = 80
	ManufacturerBontrager              Manufacturer = 81
	ManufacturerWellgo                 Manufacturer = 82
	ManufacturerScosche                Manufacturer = 83
	ManufacturerMagura                 Manufacturer = 84
	ManufacturerWoodway                Manufacturer = 85
	ManufacturerElite                  Manufacturer = 86
	ManufacturerNielsenKellerman       Manufacturer = 87
	ManufacturerDkCity                 Manufacturer = 88
	ManufacturerTacx                   Manufacturer = 89
	ManufacturerDirectionTechnology    Manufacturer = 90
	ManufacturerMagtonic               Manufacturer = 91
	Manufacturer1partcarbon            Manufacturer = 92
	ManufacturerInsideRideTechnologies Manufacturer = 93
	ManufacturerSoundOfMotion          Manufacturer = 94
	ManufacturerStryd                  Manufacturer = 95
	ManufacturerIcg                    Manufacturer = 96 // Indoorcycling Group
	ManufacturerMiPulse                Manufacturer = 97
	ManufacturerBsxAthletics           Manufacturer = 98
	ManufacturerLook                   Manufacturer = 99
	ManufacturerCampagnoloSrl          Manufacturer = 100
	ManufacturerBodyBikeSmart          Manufacturer = 101
	ManufacturerPraxisworks            Manufacturer = 102
	ManufacturerLimitsTechnology       Manufacturer = 103 // Limits Technology Ltd.
	ManufacturerTopactionTechnology    Manufacturer = 104 // TopAction Technology Inc.
	ManufacturerCosinuss               Manufacturer = 105
	ManufacturerFitcare                Manufacturer = 106
	ManufacturerMagene                 Manufacturer = 107
	ManufacturerGiantManufacturingCo   Manufacturer = 108
	ManufacturerTigrasport             Manufacturer = 109 // Tigrasport
	ManufacturerSalutron               Manufacturer = 110
	ManufacturerTechnogym              Manufacturer = 111
	ManufacturerBrytonSensors          Manufacturer = 112
	ManufacturerLatitudeLimited        Manufacturer = 113
	ManufacturerSoaringTechnology      Manufacturer = 114
	ManufacturerIgpsport               Manufacturer = 115
	ManufacturerDevelopment            Manufacturer = 255
	ManufacturerHealthandlife          Manufacturer = 257
	ManufacturerLezyne                 Manufacturer = 258
	ManufacturerScribeLabs             Manufacturer = 259
	ManufacturerZwift                  Manufacturer = 260
	ManufacturerWatteam                Manufacturer = 261
	ManufacturerRecon                  Manufacturer = 262
	ManufacturerFaveroElectronics      Manufacturer = 263
	ManufacturerDynovelo               Manufacturer = 264
	ManufacturerStrava                 Manufacturer = 265
	ManufacturerPrecor                 Manufacturer = 266 // Amer Sports
	ManufacturerBryton                 Manufacturer = 267
	ManufacturerSram                   Manufacturer = 268
	ManufacturerNavman                 Manufacturer = 269 // MiTAC Global Corporation (Mio Technology)
	ManufacturerCobi                   Manufacturer = 270 // COBI GmbH
	ManufacturerSpivi                  Manufacturer = 271
	ManufacturerMioMagellan            Manufacturer = 272
	ManufacturerEvesports              Manufacturer = 273
	ManufacturerSensitivusGauge        Manufacturer = 274
	ManufacturerPodoon                 Manufacturer = 275
	ManufacturerLifeTimeFitness        Manufacturer = 276
	ManufacturerFalcoEMotors           Manufacturer = 277 // Falco eMotors Inc.
	ManufacturerMinoura                Manufacturer = 278
	ManufacturerCycliq                 Manufacturer = 279
	ManufacturerLuxottica              Manufacturer = 280
	ManufacturerTrainerRoad            Manufacturer = 281
	ManufacturerTheSufferfest          Manufacturer = 282
	ManufacturerFullspeedahead         Manufacturer = 283
	ManufacturerActigraphcorp          Manufacturer = 5759
	ManufacturerInvalid                Manufacturer = 0xFFFF
)

// MesgCount represents the mesg_count FIT type.
type MesgCount byte

const (
	MesgCountNumPerFile     MesgCount = 0
	MesgCountMaxPerFile     MesgCount = 1
	MesgCountMaxPerFileType MesgCount = 2
	MesgCountInvalid        MesgCount = 0xFF
)

// MesgNum represents the mesg_num FIT type.
type MesgNum uint16

const (
	MesgNumFileId                      MesgNum = 0
	MesgNumCapabilities                MesgNum = 1
	MesgNumDeviceSettings              MesgNum = 2
	MesgNumUserProfile                 MesgNum = 3
	MesgNumHrmProfile                  MesgNum = 4
	MesgNumSdmProfile                  MesgNum = 5
	MesgNumBikeProfile                 MesgNum = 6
	MesgNumZonesTarget                 MesgNum = 7
	MesgNumHrZone                      MesgNum = 8
	MesgNumPowerZone                   MesgNum = 9
	MesgNumMetZone                     MesgNum = 10
	MesgNumSport                       MesgNum = 12
	MesgNumGoal                        MesgNum = 15
	MesgNumSession                     MesgNum = 18
	MesgNumLap                         MesgNum = 19
	MesgNumRecord                      MesgNum = 20
	MesgNumEvent                       MesgNum = 21
	MesgNumDeviceInfo                  MesgNum = 23
	MesgNumWorkout                     MesgNum = 26
	MesgNumWorkoutStep                 MesgNum = 27
	MesgNumSchedule                    MesgNum = 28
	MesgNumWeightScale                 MesgNum = 30
	MesgNumCourse                      MesgNum = 31
	MesgNumCoursePoint                 MesgNum = 32
	MesgNumTotals                      MesgNum = 33
	MesgNumActivity                    MesgNum = 34
	MesgNumSoftware                    MesgNum = 35
	MesgNumFileCapabilities            MesgNum = 37
	MesgNumMesgCapabilities            MesgNum = 38
	MesgNumFieldCapabilities           MesgNum = 39
	MesgNumFileCreator                 MesgNum = 49
	MesgNumBloodPressure               MesgNum = 51
	MesgNumSpeedZone                   MesgNum = 53
	MesgNumMonitoring                  MesgNum = 55
	MesgNumTrainingFile                MesgNum = 72
	MesgNumHrv                         MesgNum = 78
	MesgNumAntRx                       MesgNum = 80
	MesgNumAntTx                       MesgNum = 81
	MesgNumAntChannelId                MesgNum = 82
	MesgNumLength                      MesgNum = 101
	MesgNumMonitoringInfo              MesgNum = 103
	MesgNumPad                         MesgNum = 105
	MesgNumSlaveDevice                 MesgNum = 106
	MesgNumConnectivity                MesgNum = 127
	MesgNumWeatherConditions           MesgNum = 128
	MesgNumWeatherAlert                MesgNum = 129
	MesgNumCadenceZone                 MesgNum = 131
	MesgNumHr                          MesgNum = 132
	MesgNumSegmentLap                  MesgNum = 142
	MesgNumMemoGlob                    MesgNum = 145
	MesgNumSegmentId                   MesgNum = 148
	MesgNumSegmentLeaderboardEntry     MesgNum = 149
	MesgNumSegmentPoint                MesgNum = 150
	MesgNumSegmentFile                 MesgNum = 151
	MesgNumWorkoutSession              MesgNum = 158
	MesgNumWatchfaceSettings           MesgNum = 159
	MesgNumGpsMetadata                 MesgNum = 160
	MesgNumCameraEvent                 MesgNum = 161
	MesgNumTimestampCorrelation        MesgNum = 162
	MesgNumGyroscopeData               MesgNum = 164
	MesgNumAccelerometerData           MesgNum = 165
	MesgNumThreeDSensorCalibration     MesgNum = 167
	MesgNumVideoFrame                  MesgNum = 169
	MesgNumObdiiData                   MesgNum = 174
	MesgNumNmeaSentence                MesgNum = 177
	MesgNumAviationAttitude            MesgNum = 178
	MesgNumVideo                       MesgNum = 184
	MesgNumVideoTitle                  MesgNum = 185
	MesgNumVideoDescription            MesgNum = 186
	MesgNumVideoClip                   MesgNum = 187
	MesgNumOhrSettings                 MesgNum = 188
	MesgNumExdScreenConfiguration      MesgNum = 200
	MesgNumExdDataFieldConfiguration   MesgNum = 201
	MesgNumExdDataConceptConfiguration MesgNum = 202
	MesgNumFieldDescription            MesgNum = 206
	MesgNumDeveloperDataId             MesgNum = 207
	MesgNumMagnetometerData            MesgNum = 208
	MesgNumMfgRangeMin                 MesgNum = 0xFF00 // 0xFF00 - 0xFFFE reserved for manufacturer specific messages
	MesgNumMfgRangeMax                 MesgNum = 0xFFFE // 0xFF00 - 0xFFFE reserved for manufacturer specific messages
	MesgNumInvalid                     MesgNum = 0xFFFF
)

// MessageIndex represents the message_index FIT type.
type MessageIndex uint16

const (
	MessageIndexSelected MessageIndex = 0x8000 // message is selected if set
	MessageIndexReserved MessageIndex = 0x7000 // reserved (default 0)
	MessageIndexMask     MessageIndex = 0x0FFF // index
	MessageIndexInvalid  MessageIndex = 0xFFFF
)

// PowerPhaseType represents the power_phase_type FIT type.
type PowerPhaseType byte

const (
	PowerPhaseTypePowerPhaseStartAngle PowerPhaseType = 0
	PowerPhaseTypePowerPhaseEndAngle   PowerPhaseType = 1
	PowerPhaseTypePowerPhaseArcLength  PowerPhaseType = 2
	PowerPhaseTypePowerPhaseCenter     PowerPhaseType = 3
	PowerPhaseTypeInvalid              PowerPhaseType = 0xFF
)

// PwrZoneCalc represents the pwr_zone_calc FIT type.
type PwrZoneCalc byte

const (
	PwrZoneCalcCustom     PwrZoneCalc = 0
	PwrZoneCalcPercentFtp PwrZoneCalc = 1
	PwrZoneCalcInvalid    PwrZoneCalc = 0xFF
)

// RiderPositionType represents the rider_position_type FIT type.
type RiderPositionType byte

const (
	RiderPositionTypeSeated               RiderPositionType = 0
	RiderPositionTypeStanding             RiderPositionType = 1
	RiderPositionTypeTransitionToSeated   RiderPositionType = 2
	RiderPositionTypeTransitionToStanding RiderPositionType = 3
	RiderPositionTypeInvalid              RiderPositionType = 0xFF
)

// Schedule represents the schedule FIT type.
type Schedule byte

const (
	ScheduleWorkout Schedule = 0
	ScheduleCourse  Schedule = 1
	ScheduleInvalid Schedule = 0xFF
)

// SegmentDeleteStatus represents the segment_delete_status FIT type.
type SegmentDeleteStatus byte

const (
	SegmentDeleteStatusDoNotDelete SegmentDeleteStatus = 0
	SegmentDeleteStatusDeleteOne   SegmentDeleteStatus = 1
	SegmentDeleteStatusDeleteAll   SegmentDeleteStatus = 2
	SegmentDeleteStatusInvalid     SegmentDeleteStatus = 0xFF
)

// SegmentLapStatus represents the segment_lap_status FIT type.
type SegmentLapStatus byte

const (
	SegmentLapStatusEnd     SegmentLapStatus = 0
	SegmentLapStatusFail    SegmentLapStatus = 1
	SegmentLapStatusInvalid SegmentLapStatus = 0xFF
)

// SegmentLeaderboardType represents the segment_leaderboard_type FIT type.
type SegmentLeaderboardType byte

const (
	SegmentLeaderboardTypeOverall      SegmentLeaderboardType = 0
	SegmentLeaderboardTypePersonalBest SegmentLeaderboardType = 1
	SegmentLeaderboardTypeConnections  SegmentLeaderboardType = 2
	SegmentLeaderboardTypeGroup        SegmentLeaderboardType = 3
	SegmentLeaderboardTypeChallenger   SegmentLeaderboardType = 4
	SegmentLeaderboardTypeKom          SegmentLeaderboardType = 5
	SegmentLeaderboardTypeQom          SegmentLeaderboardType = 6
	SegmentLeaderboardTypePr           SegmentLeaderboardType = 7
	SegmentLeaderboardTypeGoal         SegmentLeaderboardType = 8
	SegmentLeaderboardTypeRival        SegmentLeaderboardType = 9
	SegmentLeaderboardTypeClubLeader   SegmentLeaderboardType = 10
	SegmentLeaderboardTypeInvalid      SegmentLeaderboardType = 0xFF
)

// SegmentSelectionType represents the segment_selection_type FIT type.
type SegmentSelectionType byte

const (
	SegmentSelectionTypeStarred   SegmentSelectionType = 0
	SegmentSelectionTypeSuggested SegmentSelectionType = 1
	SegmentSelectionTypeInvalid   SegmentSelectionType = 0xFF
)

// SensorType represents the sensor_type FIT type.
type SensorType byte

const (
	SensorTypeAccelerometer SensorType = 0
	SensorTypeGyroscope     SensorType = 1
	SensorTypeCompass       SensorType = 2 // Magnetometer
	SensorTypeInvalid       SensorType = 0xFF
)

// SessionTrigger represents the session_trigger FIT type.
type SessionTrigger byte

const (
	SessionTriggerActivityEnd      SessionTrigger = 0
	SessionTriggerManual           SessionTrigger = 1 // User changed sport.
	SessionTriggerAutoMultiSport   SessionTrigger = 2 // Auto multi-sport feature is enabled and user pressed lap button to advance session.
	SessionTriggerFitnessEquipment SessionTrigger = 3 // Auto sport change caused by user linking to fitness equipment.
	SessionTriggerInvalid          SessionTrigger = 0xFF
)

// Side represents the side FIT type.
type Side byte

const (
	SideRight   Side = 0
	SideLeft    Side = 1
	SideInvalid Side = 0xFF
)

// SourceType represents the source_type FIT type.
type SourceType byte

const (
	SourceTypeAnt                SourceType = 0 // External device connected with ANT
	SourceTypeAntplus            SourceType = 1 // External device connected with ANT+
	SourceTypeBluetooth          SourceType = 2 // External device connected with BT
	SourceTypeBluetoothLowEnergy SourceType = 3 // External device connected with BLE
	SourceTypeWifi               SourceType = 4 // External device connected with Wifi
	SourceTypeLocal              SourceType = 5 // Onboard device
	SourceTypeInvalid            SourceType = 0xFF
)

// Sport represents the sport FIT type.
type Sport byte

const (
	SportGeneric               Sport = 0
	SportRunning               Sport = 1
	SportCycling               Sport = 2
	SportTransition            Sport = 3 // Mulitsport transition
	SportFitnessEquipment      Sport = 4
	SportSwimming              Sport = 5
	SportBasketball            Sport = 6
	SportSoccer                Sport = 7
	SportTennis                Sport = 8
	SportAmericanFootball      Sport = 9
	SportTraining              Sport = 10
	SportWalking               Sport = 11
	SportCrossCountrySkiing    Sport = 12
	SportAlpineSkiing          Sport = 13
	SportSnowboarding          Sport = 14
	SportRowing                Sport = 15
	SportMountaineering        Sport = 16
	SportHiking                Sport = 17
	SportMultisport            Sport = 18
	SportPaddling              Sport = 19
	SportFlying                Sport = 20
	SportEBiking               Sport = 21
	SportMotorcycling          Sport = 22
	SportBoating               Sport = 23
	SportDriving               Sport = 24
	SportGolf                  Sport = 25
	SportHangGliding           Sport = 26
	SportHorsebackRiding       Sport = 27
	SportHunting               Sport = 28
	SportFishing               Sport = 29
	SportInlineSkating         Sport = 30
	SportRockClimbing          Sport = 31
	SportSailing               Sport = 32
	SportIceSkating            Sport = 33
	SportSkyDiving             Sport = 34
	SportSnowshoeing           Sport = 35
	SportSnowmobiling          Sport = 36
	SportStandUpPaddleboarding Sport = 37
	SportSurfing               Sport = 38
	SportWakeboarding          Sport = 39
	SportWaterSkiing           Sport = 40
	SportKayaking              Sport = 41
	SportRafting               Sport = 42
	SportWindsurfing           Sport = 43
	SportKitesurfing           Sport = 44
	SportTactical              Sport = 45
	SportJumpmaster            Sport = 46
	SportBoxing                Sport = 47
	SportFloorClimbing         Sport = 48
	SportAll                   Sport = 254 // All is for goals only to include all sports.
	SportInvalid               Sport = 0xFF
)

// SportBits0 represents the sport_bits_0 FIT type.
type SportBits0 uint8

const (
	SportBits0Generic          SportBits0 = 0x01
	SportBits0Running          SportBits0 = 0x02
	SportBits0Cycling          SportBits0 = 0x04
	SportBits0Transition       SportBits0 = 0x08 // Mulitsport transition
	SportBits0FitnessEquipment SportBits0 = 0x10
	SportBits0Swimming         SportBits0 = 0x20
	SportBits0Basketball       SportBits0 = 0x40
	SportBits0Soccer           SportBits0 = 0x80
	SportBits0Invalid          SportBits0 = 0x00
)

// SportBits1 represents the sport_bits_1 FIT type.
type SportBits1 uint8

const (
	SportBits1Tennis             SportBits1 = 0x01
	SportBits1AmericanFootball   SportBits1 = 0x02
	SportBits1Training           SportBits1 = 0x04
	SportBits1Walking            SportBits1 = 0x08
	SportBits1CrossCountrySkiing SportBits1 = 0x10
	SportBits1AlpineSkiing       SportBits1 = 0x20
	SportBits1Snowboarding       SportBits1 = 0x40
	SportBits1Rowing             SportBits1 = 0x80
	SportBits1Invalid            SportBits1 = 0x00
)

// SportBits2 represents the sport_bits_2 FIT type.
type SportBits2 uint8

const (
	SportBits2Mountaineering SportBits2 = 0x01
	SportBits2Hiking         SportBits2 = 0x02
	SportBits2Multisport     SportBits2 = 0x04
	SportBits2Paddling       SportBits2 = 0x08
	SportBits2Flying         SportBits2 = 0x10
	SportBits2EBiking        SportBits2 = 0x20
	SportBits2Motorcycling   SportBits2 = 0x40
	SportBits2Boating        SportBits2 = 0x80
	SportBits2Invalid        SportBits2 = 0x00
)

// SportBits3 represents the sport_bits_3 FIT type.
type SportBits3 uint8

const (
	SportBits3Driving         SportBits3 = 0x01
	SportBits3Golf            SportBits3 = 0x02
	SportBits3HangGliding     SportBits3 = 0x04
	SportBits3HorsebackRiding SportBits3 = 0x08
	SportBits3Hunting         SportBits3 = 0x10
	SportBits3Fishing         SportBits3 = 0x20
	SportBits3InlineSkating   SportBits3 = 0x40
	SportBits3RockClimbing    SportBits3 = 0x80
	SportBits3Invalid         SportBits3 = 0x00
)

// SportBits4 represents the sport_bits_4 FIT type.
type SportBits4 uint8

const (
	SportBits4Sailing               SportBits4 = 0x01
	SportBits4IceSkating            SportBits4 = 0x02
	SportBits4SkyDiving             SportBits4 = 0x04
	SportBits4Snowshoeing           SportBits4 = 0x08
	SportBits4Snowmobiling          SportBits4 = 0x10
	SportBits4StandUpPaddleboarding SportBits4 = 0x20
	SportBits4Surfing               SportBits4 = 0x40
	SportBits4Wakeboarding          SportBits4 = 0x80
	SportBits4Invalid               SportBits4 = 0x00
)

// SportBits5 represents the sport_bits_5 FIT type.
type SportBits5 uint8

const (
	SportBits5WaterSkiing SportBits5 = 0x01
	SportBits5Kayaking    SportBits5 = 0x02
	SportBits5Rafting     SportBits5 = 0x04
	SportBits5Windsurfing SportBits5 = 0x08
	SportBits5Kitesurfing SportBits5 = 0x10
	SportBits5Tactical    SportBits5 = 0x20
	SportBits5Jumpmaster  SportBits5 = 0x40
	SportBits5Boxing      SportBits5 = 0x80
	SportBits5Invalid     SportBits5 = 0x00
)

// SportBits6 represents the sport_bits_6 FIT type.
type SportBits6 uint8

const (
	SportBits6FloorClimbing SportBits6 = 0x01
	SportBits6Invalid       SportBits6 = 0x00
)

// SportEvent represents the sport_event FIT type.
type SportEvent byte

const (
	SportEventUncategorized  SportEvent = 0
	SportEventGeocaching     SportEvent = 1
	SportEventFitness        SportEvent = 2
	SportEventRecreation     SportEvent = 3
	SportEventRace           SportEvent = 4
	SportEventSpecialEvent   SportEvent = 5
	SportEventTraining       SportEvent = 6
	SportEventTransportation SportEvent = 7
	SportEventTouring        SportEvent = 8
	SportEventInvalid        SportEvent = 0xFF
)

// StrokeType represents the stroke_type FIT type.
type StrokeType byte

const (
	StrokeTypeNoEvent  StrokeType = 0
	StrokeTypeOther    StrokeType = 1 // stroke was detected but cannot be identified
	StrokeTypeServe    StrokeType = 2
	StrokeTypeForehand StrokeType = 3
	StrokeTypeBackhand StrokeType = 4
	StrokeTypeSmash    StrokeType = 5
	StrokeTypeInvalid  StrokeType = 0xFF
)

// SubSport represents the sub_sport FIT type.
type SubSport byte

const (
	SubSportGeneric              SubSport = 0
	SubSportTreadmill            SubSport = 1  // Run/Fitness Equipment
	SubSportStreet               SubSport = 2  // Run
	SubSportTrail                SubSport = 3  // Run
	SubSportTrack                SubSport = 4  // Run
	SubSportSpin                 SubSport = 5  // Cycling
	SubSportIndoorCycling        SubSport = 6  // Cycling/Fitness Equipment
	SubSportRoad                 SubSport = 7  // Cycling
	SubSportMountain             SubSport = 8  // Cycling
	SubSportDownhill             SubSport = 9  // Cycling
	SubSportRecumbent            SubSport = 10 // Cycling
	SubSportCyclocross           SubSport = 11 // Cycling
	SubSportHandCycling          SubSport = 12 // Cycling
	SubSportTrackCycling         SubSport = 13 // Cycling
	SubSportIndoorRowing         SubSport = 14 // Fitness Equipment
	SubSportElliptical           SubSport = 15 // Fitness Equipment
	SubSportStairClimbing        SubSport = 16 // Fitness Equipment
	SubSportLapSwimming          SubSport = 17 // Swimming
	SubSportOpenWater            SubSport = 18 // Swimming
	SubSportFlexibilityTraining  SubSport = 19 // Training
	SubSportStrengthTraining     SubSport = 20 // Training
	SubSportWarmUp               SubSport = 21 // Tennis
	SubSportMatch                SubSport = 22 // Tennis
	SubSportExercise             SubSport = 23 // Tennis
	SubSportChallenge            SubSport = 24 // Tennis
	SubSportIndoorSkiing         SubSport = 25 // Fitness Equipment
	SubSportCardioTraining       SubSport = 26 // Training
	SubSportIndoorWalking        SubSport = 27 // Walking/Fitness Equipment
	SubSportEBikeFitness         SubSport = 28 // E-Biking
	SubSportBmx                  SubSport = 29 // Cycling
	SubSportCasualWalking        SubSport = 30 // Walking
	SubSportSpeedWalking         SubSport = 31 // Walking
	SubSportBikeToRunTransition  SubSport = 32 // Transition
	SubSportRunToBikeTransition  SubSport = 33 // Transition
	SubSportSwimToBikeTransition SubSport = 34 // Transition
	SubSportAtv                  SubSport = 35 // Motorcycling
	SubSportMotocross            SubSport = 36 // Motorcycling
	SubSportBackcountry          SubSport = 37 // Alpine Skiing/Snowboarding
	SubSportResort               SubSport = 38 // Alpine Skiing/Snowboarding
	SubSportRcDrone              SubSport = 39 // Flying
	SubSportWingsuit             SubSport = 40 // Flying
	SubSportWhitewater           SubSport = 41 // Kayaking/Rafting
	SubSportSkateSkiing          SubSport = 42 // Cross Country Skiing
	SubSportYoga                 SubSport = 43 // Training
	SubSportPilates              SubSport = 44 // Training
	SubSportIndoorRunning        SubSport = 45 // Run
	SubSportGravelCycling        SubSport = 46 // Cycling
	SubSportEBikeMountain        SubSport = 47 // Cycling
	SubSportCommuting            SubSport = 48 // Cycling
	SubSportMixedSurface         SubSport = 49 // Cycling
	SubSportNavigate             SubSport = 50
	SubSportTrackMe              SubSport = 51
	SubSportMap                  SubSport = 52
	SubSportVirtualActivity      SubSport = 58
	SubSportObstacle             SubSport = 59 // Used for events where participants run, crawl through mud, climb over walls, etc.
	SubSportAll                  SubSport = 254
	SubSportInvalid              SubSport = 0xFF
)

// SupportedExdScreenLayouts represents the supported_exd_screen_layouts FIT type.
type SupportedExdScreenLayouts uint32

const (
	SupportedExdScreenLayoutsFullScreen                SupportedExdScreenLayouts = 0x00000001
	SupportedExdScreenLayoutsHalfVertical              SupportedExdScreenLayouts = 0x00000002
	SupportedExdScreenLayoutsHalfHorizontal            SupportedExdScreenLayouts = 0x00000004
	SupportedExdScreenLayoutsHalfVerticalRightSplit    SupportedExdScreenLayouts = 0x00000008
	SupportedExdScreenLayoutsHalfHorizontalBottomSplit SupportedExdScreenLayouts = 0x00000010
	SupportedExdScreenLayoutsFullQuarterSplit          SupportedExdScreenLayouts = 0x00000020
	SupportedExdScreenLayoutsHalfVerticalLeftSplit     SupportedExdScreenLayouts = 0x00000040
	SupportedExdScreenLayoutsHalfHorizontalTopSplit    SupportedExdScreenLayouts = 0x00000080
	SupportedExdScreenLayoutsInvalid                   SupportedExdScreenLayouts = 0x00000000
)

// SwimStroke represents the swim_stroke FIT type.
type SwimStroke byte

const (
	SwimStrokeFreestyle    SwimStroke = 0
	SwimStrokeBackstroke   SwimStroke = 1
	SwimStrokeBreaststroke SwimStroke = 2
	SwimStrokeButterfly    SwimStroke = 3
	SwimStrokeDrill        SwimStroke = 4
	SwimStrokeMixed        SwimStroke = 5
	SwimStrokeIm           SwimStroke = 6 // IM is a mixed interval containing the same number of lengths for each of: Butterfly, Backstroke, Breaststroke, Freestyle, swam in that order.
	SwimStrokeInvalid      SwimStroke = 0xFF
)

// Switch represents the switch FIT type.
type Switch byte

const (
	SwitchOff     Switch = 0
	SwitchOn      Switch = 1
	SwitchAuto    Switch = 2
	SwitchInvalid Switch = 0xFF
)

// TimeIntoDay represents the time_into_day FIT type.
type TimeIntoDay uint32

const (
	TimeIntoDayInvalid TimeIntoDay = 0xFFFFFFFF
)

// TimeMode represents the time_mode FIT type.
type TimeMode byte

const (
	TimeModeHour12            TimeMode = 0
	TimeModeHour24            TimeMode = 1 // Does not use a leading zero and has a colon
	TimeModeMilitary          TimeMode = 2 // Uses a leading zero and does not have a colon
	TimeModeHour12WithSeconds TimeMode = 3
	TimeModeHour24WithSeconds TimeMode = 4
	TimeModeUtc               TimeMode = 5
	TimeModeInvalid           TimeMode = 0xFF
)

// TimeZone represents the time_zone FIT type.
type TimeZone byte

const (
	TimeZoneAlmaty                   TimeZone = 0
	TimeZoneBangkok                  TimeZone = 1
	TimeZoneBombay                   TimeZone = 2
	TimeZoneBrasilia                 TimeZone = 3
	TimeZoneCairo                    TimeZone = 4
	TimeZoneCapeVerdeIs              TimeZone = 5
	TimeZoneDarwin                   TimeZone = 6
	TimeZoneEniwetok                 TimeZone = 7
	TimeZoneFiji                     TimeZone = 8
	TimeZoneHongKong                 TimeZone = 9
	TimeZoneIslamabad                TimeZone = 10
	TimeZoneKabul                    TimeZone = 11
	TimeZoneMagadan                  TimeZone = 12
	TimeZoneMidAtlantic              TimeZone = 13
	TimeZoneMoscow                   TimeZone = 14
	TimeZoneMuscat                   TimeZone = 15
	TimeZoneNewfoundland             TimeZone = 16
	TimeZoneSamoa                    TimeZone = 17
	TimeZoneSydney                   TimeZone = 18
	TimeZoneTehran                   TimeZone = 19
	TimeZoneTokyo                    TimeZone = 20
	TimeZoneUsAlaska                 TimeZone = 21
	TimeZoneUsAtlantic               TimeZone = 22
	TimeZoneUsCentral                TimeZone = 23
	TimeZoneUsEastern                TimeZone = 24
	TimeZoneUsHawaii                 TimeZone = 25
	TimeZoneUsMountain               TimeZone = 26
	TimeZoneUsPacific                TimeZone = 27
	TimeZoneOther                    TimeZone = 28
	TimeZoneAuckland                 TimeZone = 29
	TimeZoneKathmandu                TimeZone = 30
	TimeZoneEuropeWesternWet         TimeZone = 31
	TimeZoneEuropeCentralCet         TimeZone = 32
	TimeZoneEuropeEasternEet         TimeZone = 33
	TimeZoneJakarta                  TimeZone = 34
	TimeZonePerth                    TimeZone = 35
	TimeZoneAdelaide                 TimeZone = 36
	TimeZoneBrisbane                 TimeZone = 37
	TimeZoneTasmania                 TimeZone = 38
	TimeZoneIceland                  TimeZone = 39
	TimeZoneAmsterdam                TimeZone = 40
	TimeZoneAthens                   TimeZone = 41
	TimeZoneBarcelona                TimeZone = 42
	TimeZoneBerlin                   TimeZone = 43
	TimeZoneBrussels                 TimeZone = 44
	TimeZoneBudapest                 TimeZone = 45
	TimeZoneCopenhagen               TimeZone = 46
	TimeZoneDublin                   TimeZone = 47
	TimeZoneHelsinki                 TimeZone = 48
	TimeZoneLisbon                   TimeZone = 49
	TimeZoneLondon                   TimeZone = 50
	TimeZoneMadrid                   TimeZone = 51
	TimeZoneMunich                   TimeZone = 52
	TimeZoneOslo                     TimeZone = 53
	TimeZoneParis                    TimeZone = 54
	TimeZonePrague                   TimeZone = 55
	TimeZoneReykjavik                TimeZone = 56
	TimeZoneRome                     TimeZone = 57
	TimeZoneStockholm                TimeZone = 58
	TimeZoneVienna                   TimeZone = 59
	TimeZoneWarsaw                   TimeZone = 60
	TimeZoneZurich                   TimeZone = 61
	TimeZoneQuebec                   TimeZone = 62
	TimeZoneOntario                  TimeZone = 63
	TimeZoneManitoba                 TimeZone = 64
	TimeZoneSaskatchewan             TimeZone = 65
	TimeZoneAlberta                  TimeZone = 66
	TimeZoneBritishColumbia          TimeZone = 67
	TimeZoneBoise                    TimeZone = 68
	TimeZoneBoston                   TimeZone = 69
	TimeZoneChicago                  TimeZone = 70
	TimeZoneDallas                   TimeZone = 71
	TimeZoneDenver                   TimeZone = 72
	TimeZoneKansasCity               TimeZone = 73
	TimeZoneLasVegas                 TimeZone = 74
	TimeZoneLosAngeles               TimeZone = 75
	TimeZoneMiami                    TimeZone = 76
	TimeZoneMinneapolis              TimeZone = 77
	TimeZoneNewYork                  TimeZone = 78
	TimeZoneNewOrleans               TimeZone = 79
	TimeZonePhoenix                  TimeZone = 80
	TimeZoneSantaFe                  TimeZone = 81
	TimeZoneSeattle                  TimeZone = 82
	TimeZoneWashingtonDc             TimeZone = 83
	TimeZoneUsArizona                TimeZone = 84
	TimeZoneChita                    TimeZone = 85
	TimeZoneEkaterinburg             TimeZone = 86
	TimeZoneIrkutsk                  TimeZone = 87
	TimeZoneKaliningrad              TimeZone = 88
	TimeZoneKrasnoyarsk              TimeZone = 89
	TimeZoneNovosibirsk              TimeZone = 90
	TimeZonePetropavlovskKamchatskiy TimeZone = 91
	TimeZoneSamara                   TimeZone = 92
	TimeZoneVladivostok              TimeZone = 93
	TimeZoneMexicoCentral            TimeZone = 94
	TimeZoneMexicoMountain           TimeZone = 95
	TimeZoneMexicoPacific            TimeZone = 96
	TimeZoneCapeTown                 TimeZone = 97
	TimeZoneWinkhoek                 TimeZone = 98
	TimeZoneLagos                    TimeZone = 99
	TimeZoneRiyahd                   TimeZone = 100
	TimeZoneVenezuela                TimeZone = 101
	TimeZoneAustraliaLh              TimeZone = 102
	TimeZoneSantiago                 TimeZone = 103
	TimeZoneManual                   TimeZone = 253
	TimeZoneAutomatic                TimeZone = 254
	TimeZoneInvalid                  TimeZone = 0xFF
)

// TimerTrigger represents the timer_trigger FIT type.
type TimerTrigger byte

const (
	TimerTriggerManual           TimerTrigger = 0
	TimerTriggerAuto             TimerTrigger = 1
	TimerTriggerFitnessEquipment TimerTrigger = 2
	TimerTriggerInvalid          TimerTrigger = 0xFF
)

// TurnType represents the turn_type FIT type.
type TurnType byte

const (
	TurnTypeArrivingIdx             TurnType = 0
	TurnTypeArrivingLeftIdx         TurnType = 1
	TurnTypeArrivingRightIdx        TurnType = 2
	TurnTypeArrivingViaIdx          TurnType = 3
	TurnTypeArrivingViaLeftIdx      TurnType = 4
	TurnTypeArrivingViaRightIdx     TurnType = 5
	TurnTypeBearKeepLeftIdx         TurnType = 6
	TurnTypeBearKeepRightIdx        TurnType = 7
	TurnTypeContinueIdx             TurnType = 8
	TurnTypeExitLeftIdx             TurnType = 9
	TurnTypeExitRightIdx            TurnType = 10
	TurnTypeFerryIdx                TurnType = 11
	TurnTypeRoundabout45Idx         TurnType = 12
	TurnTypeRoundabout90Idx         TurnType = 13
	TurnTypeRoundabout135Idx        TurnType = 14
	TurnTypeRoundabout180Idx        TurnType = 15
	TurnTypeRoundabout225Idx        TurnType = 16
	TurnTypeRoundabout270Idx        TurnType = 17
	TurnTypeRoundabout315Idx        TurnType = 18
	TurnTypeRoundabout360Idx        TurnType = 19
	TurnTypeRoundaboutNeg45Idx      TurnType = 20
	TurnTypeRoundaboutNeg90Idx      TurnType = 21
	TurnTypeRoundaboutNeg135Idx     TurnType = 22
	TurnTypeRoundaboutNeg180Idx     TurnType = 23
	TurnTypeRoundaboutNeg225Idx     TurnType = 24
	TurnTypeRoundaboutNeg270Idx     TurnType = 25
	TurnTypeRoundaboutNeg315Idx     TurnType = 26
	TurnTypeRoundaboutNeg360Idx     TurnType = 27
	TurnTypeRoundaboutGenericIdx    TurnType = 28
	TurnTypeRoundaboutNegGenericIdx TurnType = 29
	TurnTypeSharpTurnLeftIdx        TurnType = 30
	TurnTypeSharpTurnRightIdx       TurnType = 31
	TurnTypeTurnLeftIdx             TurnType = 32
	TurnTypeTurnRightIdx            TurnType = 33
	TurnTypeUturnLeftIdx            TurnType = 34
	TurnTypeUturnRightIdx           TurnType = 35
	TurnTypeIconInvIdx              TurnType = 36
	TurnTypeIconIdxCnt              TurnType = 37
	TurnTypeInvalid                 TurnType = 0xFF
)

// UserLocalId represents the user_local_id FIT type.
type UserLocalId uint16

const (
	UserLocalIdLocalMin      UserLocalId = 0x0000
	UserLocalIdLocalMax      UserLocalId = 0x000F
	UserLocalIdStationaryMin UserLocalId = 0x0010
	UserLocalIdStationaryMax UserLocalId = 0x00FF
	UserLocalIdPortableMin   UserLocalId = 0x0100
	UserLocalIdPortableMax   UserLocalId = 0xFFFE
	UserLocalIdInvalid       UserLocalId = 0xFFFF
)

// WatchfaceMode represents the watchface_mode FIT type.
type WatchfaceMode byte

const (
	WatchfaceModeDigital   WatchfaceMode = 0
	WatchfaceModeAnalog    WatchfaceMode = 1
	WatchfaceModeConnectIq WatchfaceMode = 2
	WatchfaceModeDisabled  WatchfaceMode = 3
	WatchfaceModeInvalid   WatchfaceMode = 0xFF
)

// WeatherReport represents the weather_report FIT type.
type WeatherReport byte

const (
	WeatherReportCurrent        WeatherReport = 0
	WeatherReportForecast       WeatherReport = 1 // Deprecated use hourly_forecast instead
	WeatherReportHourlyForecast WeatherReport = 1
	WeatherReportDailyForecast  WeatherReport = 2
	WeatherReportInvalid        WeatherReport = 0xFF
)

// WeatherSevereType represents the weather_severe_type FIT type.
type WeatherSevereType byte

const (
	WeatherSevereTypeUnspecified             WeatherSevereType = 0
	WeatherSevereTypeTornado                 WeatherSevereType = 1
	WeatherSevereTypeTsunami                 WeatherSevereType = 2
	WeatherSevereTypeHurricane               WeatherSevereType = 3
	WeatherSevereTypeExtremeWind             WeatherSevereType = 4
	WeatherSevereTypeTyphoon                 WeatherSevereType = 5
	WeatherSevereTypeInlandHurricane         WeatherSevereType = 6
	WeatherSevereTypeHurricaneForceWind      WeatherSevereType = 7
	WeatherSevereTypeWaterspout              WeatherSevereType = 8
	WeatherSevereTypeSevereThunderstorm      WeatherSevereType = 9
	WeatherSevereTypeWreckhouseWinds         WeatherSevereType = 10
	WeatherSevereTypeLesSuetesWind           WeatherSevereType = 11
	WeatherSevereTypeAvalanche               WeatherSevereType = 12
	WeatherSevereTypeFlashFlood              WeatherSevereType = 13
	WeatherSevereTypeTropicalStorm           WeatherSevereType = 14
	WeatherSevereTypeInlandTropicalStorm     WeatherSevereType = 15
	WeatherSevereTypeBlizzard                WeatherSevereType = 16
	WeatherSevereTypeIceStorm                WeatherSevereType = 17
	WeatherSevereTypeFreezingRain            WeatherSevereType = 18
	WeatherSevereTypeDebrisFlow              WeatherSevereType = 19
	WeatherSevereTypeFlashFreeze             WeatherSevereType = 20
	WeatherSevereTypeDustStorm               WeatherSevereType = 21
	WeatherSevereTypeHighWind                WeatherSevereType = 22
	WeatherSevereTypeWinterStorm             WeatherSevereType = 23
	WeatherSevereTypeHeavyFreezingSpray      WeatherSevereType = 24
	WeatherSevereTypeExtremeCold             WeatherSevereType = 25
	WeatherSevereTypeWindChill               WeatherSevereType = 26
	WeatherSevereTypeColdWave                WeatherSevereType = 27
	WeatherSevereTypeHeavySnowAlert          WeatherSevereType = 28
	WeatherSevereTypeLakeEffectBlowingSnow   WeatherSevereType = 29
	WeatherSevereTypeSnowSquall              WeatherSevereType = 30
	WeatherSevereTypeLakeEffectSnow          WeatherSevereType = 31
	WeatherSevereTypeWinterWeather           WeatherSevereType = 32
	WeatherSevereTypeSleet                   WeatherSevereType = 33
	WeatherSevereTypeSnowfall                WeatherSevereType = 34
	WeatherSevereTypeSnowAndBlowingSnow      WeatherSevereType = 35
	WeatherSevereTypeBlowingSnow             WeatherSevereType = 36
	WeatherSevereTypeSnowAlert               WeatherSevereType = 37
	WeatherSevereTypeArcticOutflow           WeatherSevereType = 38
	WeatherSevereTypeFreezingDrizzle         WeatherSevereType = 39
	WeatherSevereTypeStorm                   WeatherSevereType = 40
	WeatherSevereTypeStormSurge              WeatherSevereType = 41
	WeatherSevereTypeRainfall                WeatherSevereType = 42
	WeatherSevereTypeArealFlood              WeatherSevereType = 43
	WeatherSevereTypeCoastalFlood            WeatherSevereType = 44
	WeatherSevereTypeLakeshoreFlood          WeatherSevereType = 45
	WeatherSevereTypeExcessiveHeat           WeatherSevereType = 46
	WeatherSevereTypeHeat                    WeatherSevereType = 47
	WeatherSevereTypeWeather                 WeatherSevereType = 48
	WeatherSevereTypeHighHeatAndHumidity     WeatherSevereType = 49
	WeatherSevereTypeHumidexAndHealth        WeatherSevereType = 50
	WeatherSevereTypeHumidex                 WeatherSevereType = 51
	WeatherSevereTypeGale                    WeatherSevereType = 52
	WeatherSevereTypeFreezingSpray           WeatherSevereType = 53
	WeatherSevereTypeSpecialMarine           WeatherSevereType = 54
	WeatherSevereTypeSquall                  WeatherSevereType = 55
	WeatherSevereTypeStrongWind              WeatherSevereType = 56
	WeatherSevereTypeLakeWind                WeatherSevereType = 57
	WeatherSevereTypeMarineWeather           WeatherSevereType = 58
	WeatherSevereTypeWind                    WeatherSevereType = 59
	WeatherSevereTypeSmallCraftHazardousSeas WeatherSevereType = 60
	WeatherSevereTypeHazardousSeas           WeatherSevereType = 61
	WeatherSevereTypeSmallCraft              WeatherSevereType = 62
	WeatherSevereTypeSmallCraftWinds         WeatherSevereType = 63
	WeatherSevereTypeSmallCraftRoughBar      WeatherSevereType = 64
	WeatherSevereTypeHighWaterLevel          WeatherSevereType = 65
	WeatherSevereTypeAshfall                 WeatherSevereType = 66
	WeatherSevereTypeFreezingFog             WeatherSevereType = 67
	WeatherSevereTypeDenseFog                WeatherSevereType = 68
	WeatherSevereTypeDenseSmoke              WeatherSevereType = 69
	WeatherSevereTypeBlowingDust             WeatherSevereType = 70
	WeatherSevereTypeHardFreeze              WeatherSevereType = 71
	WeatherSevereTypeFreeze                  WeatherSevereType = 72
	WeatherSevereTypeFrost                   WeatherSevereType = 73
	WeatherSevereTypeFireWeather             WeatherSevereType = 74
	WeatherSevereTypeFlood                   WeatherSevereType = 75
	WeatherSevereTypeRipTide                 WeatherSevereType = 76
	WeatherSevereTypeHighSurf                WeatherSevereType = 77
	WeatherSevereTypeSmog                    WeatherSevereType = 78
	WeatherSevereTypeAirQuality              WeatherSevereType = 79
	WeatherSevereTypeBriskWind               WeatherSevereType = 80
	WeatherSevereTypeAirStagnation           WeatherSevereType = 81
	WeatherSevereTypeLowWater                WeatherSevereType = 82
	WeatherSevereTypeHydrological            WeatherSevereType = 83
	WeatherSevereTypeSpecialWeather          WeatherSevereType = 84
	WeatherSevereTypeInvalid                 WeatherSevereType = 0xFF
)

// WeatherSeverity represents the weather_severity FIT type.
type WeatherSeverity byte

const (
	WeatherSeverityUnknown   WeatherSeverity = 0
	WeatherSeverityWarning   WeatherSeverity = 1
	WeatherSeverityWatch     WeatherSeverity = 2
	WeatherSeverityAdvisory  WeatherSeverity = 3
	WeatherSeverityStatement WeatherSeverity = 4
	WeatherSeverityInvalid   WeatherSeverity = 0xFF
)

// WeatherStatus represents the weather_status FIT type.
type WeatherStatus byte

const (
	WeatherStatusClear                  WeatherStatus = 0
	WeatherStatusPartlyCloudy           WeatherStatus = 1
	WeatherStatusMostlyCloudy           WeatherStatus = 2
	WeatherStatusRain                   WeatherStatus = 3
	WeatherStatusSnow                   WeatherStatus = 4
	WeatherStatusWindy                  WeatherStatus = 5
	WeatherStatusThunderstorms          WeatherStatus = 6
	WeatherStatusWintryMix              WeatherStatus = 7
	WeatherStatusFog                    WeatherStatus = 8
	WeatherStatusHazy                   WeatherStatus = 11
	WeatherStatusHail                   WeatherStatus = 12
	WeatherStatusScatteredShowers       WeatherStatus = 13
	WeatherStatusScatteredThunderstorms WeatherStatus = 14
	WeatherStatusUnknownPrecipitation   WeatherStatus = 15
	WeatherStatusLightRain              WeatherStatus = 16
	WeatherStatusHeavyRain              WeatherStatus = 17
	WeatherStatusLightSnow              WeatherStatus = 18
	WeatherStatusHeavySnow              WeatherStatus = 19
	WeatherStatusLightRainSnow          WeatherStatus = 20
	WeatherStatusHeavyRainSnow          WeatherStatus = 21
	WeatherStatusCloudy                 WeatherStatus = 22
	WeatherStatusInvalid                WeatherStatus = 0xFF
)

// Weight represents the weight FIT type.
type Weight uint16

const (
	WeightCalculating Weight = 0xFFFE
	WeightInvalid     Weight = 0xFFFF
)

// WktStepDuration represents the wkt_step_duration FIT type.
type WktStepDuration byte

const (
	WktStepDurationTime                               WktStepDuration = 0
	WktStepDurationDistance                           WktStepDuration = 1
	WktStepDurationHrLessThan                         WktStepDuration = 2
	WktStepDurationHrGreaterThan                      WktStepDuration = 3
	WktStepDurationCalories                           WktStepDuration = 4
	WktStepDurationOpen                               WktStepDuration = 5
	WktStepDurationRepeatUntilStepsCmplt              WktStepDuration = 6
	WktStepDurationRepeatUntilTime                    WktStepDuration = 7
	WktStepDurationRepeatUntilDistance                WktStepDuration = 8
	WktStepDurationRepeatUntilCalories                WktStepDuration = 9
	WktStepDurationRepeatUntilHrLessThan              WktStepDuration = 10
	WktStepDurationRepeatUntilHrGreaterThan           WktStepDuration = 11
	WktStepDurationRepeatUntilPowerLessThan           WktStepDuration = 12
	WktStepDurationRepeatUntilPowerGreaterThan        WktStepDuration = 13
	WktStepDurationPowerLessThan                      WktStepDuration = 14
	WktStepDurationPowerGreaterThan                   WktStepDuration = 15
	WktStepDurationTrainingPeaksTss                   WktStepDuration = 16
	WktStepDurationRepeatUntilPowerLastLapLessThan    WktStepDuration = 17
	WktStepDurationRepeatUntilMaxPowerLastLapLessThan WktStepDuration = 18
	WktStepDurationPower3sLessThan                    WktStepDuration = 19
	WktStepDurationPower10sLessThan                   WktStepDuration = 20
	WktStepDurationPower30sLessThan                   WktStepDuration = 21
	WktStepDurationPower3sGreaterThan                 WktStepDuration = 22
	WktStepDurationPower10sGreaterThan                WktStepDuration = 23
	WktStepDurationPower30sGreaterThan                WktStepDuration = 24
	WktStepDurationPowerLapLessThan                   WktStepDuration = 25
	WktStepDurationPowerLapGreaterThan                WktStepDuration = 26
	WktStepDurationRepeatUntilTrainingPeaksTss        WktStepDuration = 27
	WktStepDurationRepetitionTime                     WktStepDuration = 28
	WktStepDurationInvalid                            WktStepDuration = 0xFF
)

// WktStepTarget represents the wkt_step_target FIT type.
type WktStepTarget byte

const (
	WktStepTargetSpeed        WktStepTarget = 0
	WktStepTargetHeartRate    WktStepTarget = 1
	WktStepTargetOpen         WktStepTarget = 2
	WktStepTargetCadence      WktStepTarget = 3
	WktStepTargetPower        WktStepTarget = 4
	WktStepTargetGrade        WktStepTarget = 5
	WktStepTargetResistance   WktStepTarget = 6
	WktStepTargetPower3s      WktStepTarget = 7
	WktStepTargetPower10s     WktStepTarget = 8
	WktStepTargetPower30s     WktStepTarget = 9
	WktStepTargetPowerLap     WktStepTarget = 10
	WktStepTargetSwimStroke   WktStepTarget = 11
	WktStepTargetSpeedLap     WktStepTarget = 12
	WktStepTargetHeartRateLap WktStepTarget = 13
	WktStepTargetInvalid      WktStepTarget = 0xFF
)

// WorkoutCapabilities represents the workout_capabilities FIT type.
type WorkoutCapabilities uint32

const (
	WorkoutCapabilitiesInterval         WorkoutCapabilities = 0x00000001
	WorkoutCapabilitiesCustom           WorkoutCapabilities = 0x00000002
	WorkoutCapabilitiesFitnessEquipment WorkoutCapabilities = 0x00000004
	WorkoutCapabilitiesFirstbeat        WorkoutCapabilities = 0x00000008
	WorkoutCapabilitiesNewLeaf          WorkoutCapabilities = 0x00000010
	WorkoutCapabilitiesTcx              WorkoutCapabilities = 0x00000020 // For backwards compatibility.  Watch should add missing id fields then clear flag.
	WorkoutCapabilitiesSpeed            WorkoutCapabilities = 0x00000080 // Speed source required for workout step.
	WorkoutCapabilitiesHeartRate        WorkoutCapabilities = 0x00000100 // Heart rate source required for workout step.
	WorkoutCapabilitiesDistance         WorkoutCapabilities = 0x00000200 // Distance source required for workout step.
	WorkoutCapabilitiesCadence          WorkoutCapabilities = 0x00000400 // Cadence source required for workout step.
	WorkoutCapabilitiesPower            WorkoutCapabilities = 0x00000800 // Power source required for workout step.
	WorkoutCapabilitiesGrade            WorkoutCapabilities = 0x00001000 // Grade source required for workout step.
	WorkoutCapabilitiesResistance       WorkoutCapabilities = 0x00002000 // Resistance source required for workout step.
	WorkoutCapabilitiesProtected        WorkoutCapabilities = 0x00004000
	WorkoutCapabilitiesInvalid          WorkoutCapabilities = 0x00000000
)

// WorkoutEquipment represents the workout_equipment FIT type.
type WorkoutEquipment byte

const (
	WorkoutEquipmentNone          WorkoutEquipment = 0
	WorkoutEquipmentSwimFins      WorkoutEquipment = 1
	WorkoutEquipmentSwimKickboard WorkoutEquipment = 2
	WorkoutEquipmentSwimPaddles   WorkoutEquipment = 3
	WorkoutEquipmentSwimPullBuoy  WorkoutEquipment = 4
	WorkoutEquipmentSwimSnorkel   WorkoutEquipment = 5
	WorkoutEquipmentInvalid       WorkoutEquipment = 0xFF
)

// WorkoutHr represents the workout_hr FIT type.
type WorkoutHr uint32

const (
	WorkoutHrBpmOffset WorkoutHr = 100
	WorkoutHrInvalid   WorkoutHr = 0xFFFFFFFF
)

// WorkoutPower represents the workout_power FIT type.
type WorkoutPower uint32

const (
	WorkoutPowerWattsOffset WorkoutPower = 1000
	WorkoutPowerInvalid     WorkoutPower = 0xFFFFFFFF
)
// MESSAGES
// Code generated using the program found in 'cmd/fitgen/main.go'. DO NOT EDIT.

// SDK Version: 20.43

package fit

import (
	"math"
	"time"
)

// FileIdMsg represents the file_id FIT message type.
type FileIdMsg struct {
	Type         FileType
	Manufacturer Manufacturer
	Product      uint16
	SerialNumber uint32
	TimeCreated  time.Time // Only set for files that are can be created/erased.
	Number       uint16    // Only set for files that are not created/erased.
	ProductName  string    // Optional free form string to indicate the devices name or model
}

// NewFileIdMsg returns a file_id FIT message
// initialized to all-invalid values.
func NewFileIdMsg() *FileIdMsg {
	return &FileIdMsg{
		Type:         0xFF,
		Manufacturer: 0xFFFF,
		Product:      0xFFFF,
		SerialNumber: 0x00000000,
		TimeCreated:  timeBase,
		Number:       0xFFFF,
		ProductName:  "",
	}
}

// GetProduct returns the appropriate Product
// subfield if a matching reference field/value combination is found.
// If none of the reference field/value combinations are true
// then the main field is returned.
func (x *FileIdMsg) GetProduct() interface{} {
	switch x.Manufacturer {
	case ManufacturerGarmin, ManufacturerDynastream, ManufacturerDynastreamOem:
		return GarminProduct(x.Product)
	default:
		return x.Product
	}
}

// FileCreatorMsg represents the file_creator FIT message type.
type FileCreatorMsg struct {
	SoftwareVersion uint16
	HardwareVersion uint8
}

// NewFileCreatorMsg returns a file_creator FIT message
// initialized to all-invalid values.
func NewFileCreatorMsg() *FileCreatorMsg {
	return &FileCreatorMsg{
		SoftwareVersion: 0xFFFF,
		HardwareVersion: 0xFF,
	}
}

// TimestampCorrelationMsg represents the timestamp_correlation FIT message type.
type TimestampCorrelationMsg struct {
}

// NewTimestampCorrelationMsg returns a timestamp_correlation FIT message
// initialized to all-invalid values.
func NewTimestampCorrelationMsg() *TimestampCorrelationMsg {
	return &TimestampCorrelationMsg{}
}

// SoftwareMsg represents the software FIT message type.
type SoftwareMsg struct {
	MessageIndex MessageIndex
	Version      uint16
	PartNumber   string
}

// NewSoftwareMsg returns a software FIT message
// initialized to all-invalid values.
func NewSoftwareMsg() *SoftwareMsg {
	return &SoftwareMsg{
		MessageIndex: 0xFFFF,
		Version:      0xFFFF,
		PartNumber:   "",
	}
}

// GetVersionScaled returns Version
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
func (x *SoftwareMsg) GetVersionScaled() float64 {
	if x.Version == 0xFFFF {
		return math.NaN()
	}
	return float64(x.Version) / 100
}

// SlaveDeviceMsg represents the slave_device FIT message type.
type SlaveDeviceMsg struct {
	Manufacturer Manufacturer
	Product      uint16
}

// NewSlaveDeviceMsg returns a slave_device FIT message
// initialized to all-invalid values.
func NewSlaveDeviceMsg() *SlaveDeviceMsg {
	return &SlaveDeviceMsg{
		Manufacturer: 0xFFFF,
		Product:      0xFFFF,
	}
}

// GetProduct returns the appropriate Product
// subfield if a matching reference field/value combination is found.
// If none of the reference field/value combinations are true
// then the main field is returned.
func (x *SlaveDeviceMsg) GetProduct() interface{} {
	switch x.Manufacturer {
	case ManufacturerGarmin, ManufacturerDynastream, ManufacturerDynastreamOem:
		return GarminProduct(x.Product)
	default:
		return x.Product
	}
}

// CapabilitiesMsg represents the capabilities FIT message type.
type CapabilitiesMsg struct {
	Languages             []uint8      // Use language_bits_x types where x is index of array.
	Sports                []SportBits0 // Use sport_bits_x types where x is index of array.
	WorkoutsSupported     WorkoutCapabilities
	ConnectivitySupported ConnectivityCapabilities
}

// NewCapabilitiesMsg returns a capabilities FIT message
// initialized to all-invalid values.
func NewCapabilitiesMsg() *CapabilitiesMsg {
	return &CapabilitiesMsg{
		Languages:             nil,
		Sports:                nil,
		WorkoutsSupported:     0x00000000,
		ConnectivitySupported: 0x00000000,
	}
}

// FileCapabilitiesMsg represents the file_capabilities FIT message type.
type FileCapabilitiesMsg struct {
	MessageIndex MessageIndex
	Type         FileType
	Flags        FileFlags
	Directory    string
	MaxCount     uint16
	MaxSize      uint32
}

// NewFileCapabilitiesMsg returns a file_capabilities FIT message
// initialized to all-invalid values.
func NewFileCapabilitiesMsg() *FileCapabilitiesMsg {
	return &FileCapabilitiesMsg{
		MessageIndex: 0xFFFF,
		Type:         0xFF,
		Flags:        0x00,
		Directory:    "",
		MaxCount:     0xFFFF,
		MaxSize:      0xFFFFFFFF,
	}
}

// MesgCapabilitiesMsg represents the mesg_capabilities FIT message type.
type MesgCapabilitiesMsg struct {
	MessageIndex MessageIndex
	File         FileType
	MesgNum      MesgNum
	CountType    MesgCount
	Count        uint16
}

// NewMesgCapabilitiesMsg returns a mesg_capabilities FIT message
// initialized to all-invalid values.
func NewMesgCapabilitiesMsg() *MesgCapabilitiesMsg {
	return &MesgCapabilitiesMsg{
		MessageIndex: 0xFFFF,
		File:         0xFF,
		MesgNum:      0xFFFF,
		CountType:    0xFF,
		Count:        0xFFFF,
	}
}

// GetCount returns the appropriate Count
// subfield if a matching reference field/value combination is found.
// If none of the reference field/value combinations are true
// then the main field is returned.
func (x *MesgCapabilitiesMsg) GetCount() interface{} {
	switch x.CountType {
	case MesgCountNumPerFile:
		return uint16(x.Count)
	case MesgCountMaxPerFile:
		return uint16(x.Count)
	case MesgCountMaxPerFileType:
		return uint16(x.Count)
	default:
		return x.Count
	}
}

// FieldCapabilitiesMsg represents the field_capabilities FIT message type.
type FieldCapabilitiesMsg struct {
	MessageIndex MessageIndex
	File         FileType
	MesgNum      MesgNum
	FieldNum     uint8
	Count        uint16
}

// NewFieldCapabilitiesMsg returns a field_capabilities FIT message
// initialized to all-invalid values.
func NewFieldCapabilitiesMsg() *FieldCapabilitiesMsg {
	return &FieldCapabilitiesMsg{
		MessageIndex: 0xFFFF,
		File:         0xFF,
		MesgNum:      0xFFFF,
		FieldNum:     0xFF,
		Count:        0xFFFF,
	}
}

// DeviceSettingsMsg represents the device_settings FIT message type.
type DeviceSettingsMsg struct {
	ActiveTimeZone         uint8         // Index into time zone arrays.
	UtcOffset              uint32        // Offset from system time. Required to convert timestamp from system time to UTC.
	TimeOffset             []uint32      // Offset from system time.
	TimeMode               []TimeMode    // Display mode for the time
	TimeZoneOffset         []int8        // timezone offset in 1/4 hour increments
	BacklightMode          BacklightMode // Mode for backlight
	ActivityTrackerEnabled Bool          // Enabled state of the activity tracker functionality
	ClockTime              time.Time     // UTC timestamp used to set the devices clock and date
	PagesEnabled           []uint16      // Bitfield  to configure enabled screens for each supported loop
	MoveAlertEnabled       Bool          // Enabled state of the move alert
	DateMode               DateMode      // Display mode for the date
	DisplayOrientation     DisplayOrientation
	MountingSide           Side
	DefaultPage            []uint16 // Bitfield to indicate one page as default for each supported loop
	AutosyncMinSteps       uint16   // Minimum steps before an autosync can occur
	AutosyncMinTime        uint16   // Minimum minutes before an autosync can occur
}

// NewDeviceSettingsMsg returns a device_settings FIT message
// initialized to all-invalid values.
func NewDeviceSettingsMsg() *DeviceSettingsMsg {
	return &DeviceSettingsMsg{
		ActiveTimeZone:         0xFF,
		UtcOffset:              0xFFFFFFFF,
		TimeOffset:             nil,
		TimeMode:               nil,
		TimeZoneOffset:         nil,
		BacklightMode:          0xFF,
		ActivityTrackerEnabled: 0xFF,
		ClockTime:              timeBase,
		PagesEnabled:           nil,
		MoveAlertEnabled:       0xFF,
		DateMode:               0xFF,
		DisplayOrientation:     0xFF,
		MountingSide:           0xFF,
		DefaultPage:            nil,
		AutosyncMinSteps:       0xFFFF,
		AutosyncMinTime:        0xFFFF,
	}
}

// GetTimeZoneOffsetScaled returns TimeZoneOffset
// as a slice with scale and any offset applied to every element.
// Units: hr
func (x *DeviceSettingsMsg) GetTimeZoneOffsetScaled() []float64 {
	if len(x.TimeZoneOffset) == 0 {
		return nil
	}
	s := make([]float64, len(x.TimeZoneOffset))
	for i, v := range x.TimeZoneOffset {
		s[i] = float64(v) / 4
	}
	return s
}

// UserProfileMsg represents the user_profile FIT message type.
type UserProfileMsg struct {
	MessageIndex               MessageIndex
	FriendlyName               string
	Gender                     Gender
	Age                        uint8
	Height                     uint8
	Weight                     uint16
	Language                   Language
	ElevSetting                DisplayMeasure
	WeightSetting              DisplayMeasure
	RestingHeartRate           uint8
	DefaultMaxRunningHeartRate uint8
	DefaultMaxBikingHeartRate  uint8
	DefaultMaxHeartRate        uint8
	HrSetting                  DisplayHeart
	SpeedSetting               DisplayMeasure
	DistSetting                DisplayMeasure
	PowerSetting               DisplayPower
	ActivityClass              ActivityClass
	PositionSetting            DisplayPosition
	TemperatureSetting         DisplayMeasure
	LocalId                    UserLocalId
	GlobalId                   []byte
	HeightSetting              DisplayMeasure
	UserRunningStepLength      uint16 // User defined running step length set to 0 for auto length
	UserWalkingStepLength      uint16 // User defined walking step length set to 0 for auto length
}

// NewUserProfileMsg returns a user_profile FIT message
// initialized to all-invalid values.
func NewUserProfileMsg() *UserProfileMsg {
	return &UserProfileMsg{
		MessageIndex:               0xFFFF,
		FriendlyName:               "",
		Gender:                     0xFF,
		Age:                        0xFF,
		Height:                     0xFF,
		Weight:                     0xFFFF,
		Language:                   0xFF,
		ElevSetting:                0xFF,
		WeightSetting:              0xFF,
		RestingHeartRate:           0xFF,
		DefaultMaxRunningHeartRate: 0xFF,
		DefaultMaxBikingHeartRate:  0xFF,
		DefaultMaxHeartRate:        0xFF,
		HrSetting:                  0xFF,
		SpeedSetting:               0xFF,
		DistSetting:                0xFF,
		PowerSetting:               0xFF,
		ActivityClass:              0xFF,
		PositionSetting:            0xFF,
		TemperatureSetting:         0xFF,
		LocalId:                    0xFFFF,
		GlobalId:                   nil,
		HeightSetting:              0xFF,
		UserRunningStepLength:      0xFFFF,
		UserWalkingStepLength:      0xFFFF,
	}
}

// GetHeightScaled returns Height
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m
func (x *UserProfileMsg) GetHeightScaled() float64 {
	if x.Height == 0xFF {
		return math.NaN()
	}
	return float64(x.Height) / 100
}

// GetWeightScaled returns Weight
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: kg
func (x *UserProfileMsg) GetWeightScaled() float64 {
	if x.Weight == 0xFFFF {
		return math.NaN()
	}
	return float64(x.Weight) / 10
}

// GetUserRunningStepLengthScaled returns UserRunningStepLength
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m
func (x *UserProfileMsg) GetUserRunningStepLengthScaled() float64 {
	if x.UserRunningStepLength == 0xFFFF {
		return math.NaN()
	}
	return float64(x.UserRunningStepLength) / 1000
}

// GetUserWalkingStepLengthScaled returns UserWalkingStepLength
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m
func (x *UserProfileMsg) GetUserWalkingStepLengthScaled() float64 {
	if x.UserWalkingStepLength == 0xFFFF {
		return math.NaN()
	}
	return float64(x.UserWalkingStepLength) / 1000
}

// HrmProfileMsg represents the hrm_profile FIT message type.
type HrmProfileMsg struct {
	MessageIndex      MessageIndex
	Enabled           Bool
	HrmAntId          uint16
	LogHrv            Bool
	HrmAntIdTransType uint8
}

// NewHrmProfileMsg returns a hrm_profile FIT message
// initialized to all-invalid values.
func NewHrmProfileMsg() *HrmProfileMsg {
	return &HrmProfileMsg{
		MessageIndex:      0xFFFF,
		Enabled:           0xFF,
		HrmAntId:          0x0000,
		LogHrv:            0xFF,
		HrmAntIdTransType: 0x00,
	}
}

// SdmProfileMsg represents the sdm_profile FIT message type.
type SdmProfileMsg struct {
	MessageIndex      MessageIndex
	Enabled           Bool
	SdmAntId          uint16
	SdmCalFactor      uint16
	Odometer          uint32
	SpeedSource       Bool // Use footpod for speed source instead of GPS
	SdmAntIdTransType uint8
	OdometerRollover  uint8 // Rollover counter that can be used to extend the odometer
}

// NewSdmProfileMsg returns a sdm_profile FIT message
// initialized to all-invalid values.
func NewSdmProfileMsg() *SdmProfileMsg {
	return &SdmProfileMsg{
		MessageIndex:      0xFFFF,
		Enabled:           0xFF,
		SdmAntId:          0x0000,
		SdmCalFactor:      0xFFFF,
		Odometer:          0xFFFFFFFF,
		SpeedSource:       0xFF,
		SdmAntIdTransType: 0x00,
		OdometerRollover:  0xFF,
	}
}

// GetSdmCalFactorScaled returns SdmCalFactor
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: %
func (x *SdmProfileMsg) GetSdmCalFactorScaled() float64 {
	if x.SdmCalFactor == 0xFFFF {
		return math.NaN()
	}
	return float64(x.SdmCalFactor) / 10
}

// GetOdometerScaled returns Odometer
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m
func (x *SdmProfileMsg) GetOdometerScaled() float64 {
	if x.Odometer == 0xFFFFFFFF {
		return math.NaN()
	}
	return float64(x.Odometer) / 100
}

// BikeProfileMsg represents the bike_profile FIT message type.
type BikeProfileMsg struct {
	MessageIndex             MessageIndex
	Name                     string
	Sport                    Sport
	SubSport                 SubSport
	Odometer                 uint32
	BikeSpdAntId             uint16
	BikeCadAntId             uint16
	BikeSpdcadAntId          uint16
	BikePowerAntId           uint16
	CustomWheelsize          uint16
	AutoWheelsize            uint16
	BikeWeight               uint16
	PowerCalFactor           uint16
	AutoWheelCal             Bool
	AutoPowerZero            Bool
	Id                       uint8
	SpdEnabled               Bool
	CadEnabled               Bool
	SpdcadEnabled            Bool
	PowerEnabled             Bool
	CrankLength              uint8
	Enabled                  Bool
	BikeSpdAntIdTransType    uint8
	BikeCadAntIdTransType    uint8
	BikeSpdcadAntIdTransType uint8
	BikePowerAntIdTransType  uint8
	OdometerRollover         uint8   // Rollover counter that can be used to extend the odometer
	FrontGearNum             uint8   // Number of front gears
	FrontGear                []uint8 // Number of teeth on each gear 0 is innermost
	RearGearNum              uint8   // Number of rear gears
	RearGear                 []uint8 // Number of teeth on each gear 0 is innermost
	ShimanoDi2Enabled        Bool
}

// NewBikeProfileMsg returns a bike_profile FIT message
// initialized to all-invalid values.
func NewBikeProfileMsg() *BikeProfileMsg {
	return &BikeProfileMsg{
		MessageIndex:             0xFFFF,
		Name:                     "",
		Sport:                    0xFF,
		SubSport:                 0xFF,
		Odometer:                 0xFFFFFFFF,
		BikeSpdAntId:             0x0000,
		BikeCadAntId:             0x0000,
		BikeSpdcadAntId:          0x0000,
		BikePowerAntId:           0x0000,
		CustomWheelsize:          0xFFFF,
		AutoWheelsize:            0xFFFF,
		BikeWeight:               0xFFFF,
		PowerCalFactor:           0xFFFF,
		AutoWheelCal:             0xFF,
		AutoPowerZero:            0xFF,
		Id:                       0xFF,
		SpdEnabled:               0xFF,
		CadEnabled:               0xFF,
		SpdcadEnabled:            0xFF,
		PowerEnabled:             0xFF,
		CrankLength:              0xFF,
		Enabled:                  0xFF,
		BikeSpdAntIdTransType:    0x00,
		BikeCadAntIdTransType:    0x00,
		BikeSpdcadAntIdTransType: 0x00,
		BikePowerAntIdTransType:  0x00,
		OdometerRollover:         0xFF,
		FrontGearNum:             0x00,
		FrontGear:                nil,
		RearGearNum:              0x00,
		RearGear:                 nil,
		ShimanoDi2Enabled:        0xFF,
	}
}

// GetOdometerScaled returns Odometer
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m
func (x *BikeProfileMsg) GetOdometerScaled() float64 {
	if x.Odometer == 0xFFFFFFFF {
		return math.NaN()
	}
	return float64(x.Odometer) / 100
}

// GetCustomWheelsizeScaled returns CustomWheelsize
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m
func (x *BikeProfileMsg) GetCustomWheelsizeScaled() float64 {
	if x.CustomWheelsize == 0xFFFF {
		return math.NaN()
	}
	return float64(x.CustomWheelsize) / 1000
}

// GetAutoWheelsizeScaled returns AutoWheelsize
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m
func (x *BikeProfileMsg) GetAutoWheelsizeScaled() float64 {
	if x.AutoWheelsize == 0xFFFF {
		return math.NaN()
	}
	return float64(x.AutoWheelsize) / 1000
}

// GetBikeWeightScaled returns BikeWeight
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: kg
func (x *BikeProfileMsg) GetBikeWeightScaled() float64 {
	if x.BikeWeight == 0xFFFF {
		return math.NaN()
	}
	return float64(x.BikeWeight) / 10
}

// GetPowerCalFactorScaled returns PowerCalFactor
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: %
func (x *BikeProfileMsg) GetPowerCalFactorScaled() float64 {
	if x.PowerCalFactor == 0xFFFF {
		return math.NaN()
	}
	return float64(x.PowerCalFactor) / 10
}

// GetCrankLengthScaled returns CrankLength
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: mm
func (x *BikeProfileMsg) GetCrankLengthScaled() float64 {
	if x.CrankLength == 0xFF {
		return math.NaN()
	}
	return float64(x.CrankLength)/2 - -110
}

// ConnectivityMsg represents the connectivity FIT message type.
type ConnectivityMsg struct {
	BluetoothEnabled            Bool // Use Bluetooth for connectivity features
	BluetoothLeEnabled          Bool // Use Bluetooth Low Energy for connectivity features
	AntEnabled                  Bool // Use ANT for connectivity features
	Name                        string
	LiveTrackingEnabled         Bool
	WeatherConditionsEnabled    Bool
	WeatherAlertsEnabled        Bool
	AutoActivityUploadEnabled   Bool
	CourseDownloadEnabled       Bool
	WorkoutDownloadEnabled      Bool
	GpsEphemerisDownloadEnabled Bool
	IncidentDetectionEnabled    Bool
	GrouptrackEnabled           Bool
}

// NewConnectivityMsg returns a connectivity FIT message
// initialized to all-invalid values.
func NewConnectivityMsg() *ConnectivityMsg {
	return &ConnectivityMsg{
		BluetoothEnabled:            0xFF,
		BluetoothLeEnabled:          0xFF,
		AntEnabled:                  0xFF,
		Name:                        "",
		LiveTrackingEnabled:         0xFF,
		WeatherConditionsEnabled:    0xFF,
		WeatherAlertsEnabled:        0xFF,
		AutoActivityUploadEnabled:   0xFF,
		CourseDownloadEnabled:       0xFF,
		WorkoutDownloadEnabled:      0xFF,
		GpsEphemerisDownloadEnabled: 0xFF,
		IncidentDetectionEnabled:    0xFF,
		GrouptrackEnabled:           0xFF,
	}
}

// WatchfaceSettingsMsg represents the watchface_settings FIT message type.
type WatchfaceSettingsMsg struct {
}

// NewWatchfaceSettingsMsg returns a watchface_settings FIT message
// initialized to all-invalid values.
func NewWatchfaceSettingsMsg() *WatchfaceSettingsMsg {
	return &WatchfaceSettingsMsg{}
}

// OhrSettingsMsg represents the ohr_settings FIT message type.
type OhrSettingsMsg struct {
}

// NewOhrSettingsMsg returns a ohr_settings FIT message
// initialized to all-invalid values.
func NewOhrSettingsMsg() *OhrSettingsMsg {
	return &OhrSettingsMsg{}
}

// ZonesTargetMsg represents the zones_target FIT message type.
type ZonesTargetMsg struct {
	MaxHeartRate             uint8
	ThresholdHeartRate       uint8
	FunctionalThresholdPower uint16
	HrCalcType               HrZoneCalc
	PwrCalcType              PwrZoneCalc
}

// NewZonesTargetMsg returns a zones_target FIT message
// initialized to all-invalid values.
func NewZonesTargetMsg() *ZonesTargetMsg {
	return &ZonesTargetMsg{
		MaxHeartRate:             0xFF,
		ThresholdHeartRate:       0xFF,
		FunctionalThresholdPower: 0xFFFF,
		HrCalcType:               0xFF,
		PwrCalcType:              0xFF,
	}
}

// SportMsg represents the sport FIT message type.
type SportMsg struct {
	Sport    Sport
	SubSport SubSport
	Name     string
}

// NewSportMsg returns a sport FIT message
// initialized to all-invalid values.
func NewSportMsg() *SportMsg {
	return &SportMsg{
		Sport:    0xFF,
		SubSport: 0xFF,
		Name:     "",
	}
}

// HrZoneMsg represents the hr_zone FIT message type.
type HrZoneMsg struct {
	MessageIndex MessageIndex
	HighBpm      uint8
	Name         string
}

// NewHrZoneMsg returns a hr_zone FIT message
// initialized to all-invalid values.
func NewHrZoneMsg() *HrZoneMsg {
	return &HrZoneMsg{
		MessageIndex: 0xFFFF,
		HighBpm:      0xFF,
		Name:         "",
	}
}

// SpeedZoneMsg represents the speed_zone FIT message type.
type SpeedZoneMsg struct {
	MessageIndex MessageIndex
	HighValue    uint16
	Name         string
}

// NewSpeedZoneMsg returns a speed_zone FIT message
// initialized to all-invalid values.
func NewSpeedZoneMsg() *SpeedZoneMsg {
	return &SpeedZoneMsg{
		MessageIndex: 0xFFFF,
		HighValue:    0xFFFF,
		Name:         "",
	}
}

// GetHighValueScaled returns HighValue
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m/s
func (x *SpeedZoneMsg) GetHighValueScaled() float64 {
	if x.HighValue == 0xFFFF {
		return math.NaN()
	}
	return float64(x.HighValue) / 1000
}

// CadenceZoneMsg represents the cadence_zone FIT message type.
type CadenceZoneMsg struct {
	MessageIndex MessageIndex
	HighValue    uint8
	Name         string
}

// NewCadenceZoneMsg returns a cadence_zone FIT message
// initialized to all-invalid values.
func NewCadenceZoneMsg() *CadenceZoneMsg {
	return &CadenceZoneMsg{
		MessageIndex: 0xFFFF,
		HighValue:    0xFF,
		Name:         "",
	}
}

// PowerZoneMsg represents the power_zone FIT message type.
type PowerZoneMsg struct {
	MessageIndex MessageIndex
	HighValue    uint16
	Name         string
}

// NewPowerZoneMsg returns a power_zone FIT message
// initialized to all-invalid values.
func NewPowerZoneMsg() *PowerZoneMsg {
	return &PowerZoneMsg{
		MessageIndex: 0xFFFF,
		HighValue:    0xFFFF,
		Name:         "",
	}
}

// MetZoneMsg represents the met_zone FIT message type.
type MetZoneMsg struct {
	MessageIndex MessageIndex
	HighBpm      uint8
	Calories     uint16
	FatCalories  uint8
}

// NewMetZoneMsg returns a met_zone FIT message
// initialized to all-invalid values.
func NewMetZoneMsg() *MetZoneMsg {
	return &MetZoneMsg{
		MessageIndex: 0xFFFF,
		HighBpm:      0xFF,
		Calories:     0xFFFF,
		FatCalories:  0xFF,
	}
}

// GetCaloriesScaled returns Calories
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: kcal / min
func (x *MetZoneMsg) GetCaloriesScaled() float64 {
	if x.Calories == 0xFFFF {
		return math.NaN()
	}
	return float64(x.Calories) / 10
}

// GetFatCaloriesScaled returns FatCalories
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: kcal / min
func (x *MetZoneMsg) GetFatCaloriesScaled() float64 {
	if x.FatCalories == 0xFF {
		return math.NaN()
	}
	return float64(x.FatCalories) / 10
}

// GoalMsg represents the goal FIT message type.
type GoalMsg struct {
	MessageIndex    MessageIndex
	Sport           Sport
	SubSport        SubSport
	StartDate       time.Time
	EndDate         time.Time
	Type            Goal
	Value           uint32
	Repeat          Bool
	TargetValue     uint32
	Recurrence      GoalRecurrence
	RecurrenceValue uint16
	Enabled         Bool
	Source          GoalSource
}

// NewGoalMsg returns a goal FIT message
// initialized to all-invalid values.
func NewGoalMsg() *GoalMsg {
	return &GoalMsg{
		MessageIndex:    0xFFFF,
		Sport:           0xFF,
		SubSport:        0xFF,
		StartDate:       timeBase,
		EndDate:         timeBase,
		Type:            0xFF,
		Value:           0xFFFFFFFF,
		Repeat:          0xFF,
		TargetValue:     0xFFFFFFFF,
		Recurrence:      0xFF,
		RecurrenceValue: 0xFFFF,
		Enabled:         0xFF,
		Source:          0xFF,
	}
}

// ActivityMsg represents the activity FIT message type.
type ActivityMsg struct {
	Timestamp      time.Time
	TotalTimerTime uint32 // Exclude pauses
	NumSessions    uint16
	Type           ActivityMode
	Event          Event
	EventType      EventType
	LocalTimestamp time.Time // timestamp epoch expressed in local time, used to convert activity timestamps to local time
	EventGroup     uint8
}

// NewActivityMsg returns a activity FIT message
// initialized to all-invalid values.
func NewActivityMsg() *ActivityMsg {
	return &ActivityMsg{
		Timestamp:      timeBase,
		TotalTimerTime: 0xFFFFFFFF,
		NumSessions:    0xFFFF,
		Type:           0xFF,
		Event:          0xFF,
		EventType:      0xFF,
		LocalTimestamp: timeBase,
		EventGroup:     0xFF,
	}
}

// GetTotalTimerTimeScaled returns TotalTimerTime
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: s
func (x *ActivityMsg) GetTotalTimerTimeScaled() float64 {
	if x.TotalTimerTime == 0xFFFFFFFF {
		return math.NaN()
	}
	return float64(x.TotalTimerTime) / 1000
}

// SessionMsg represents the session FIT message type.
type SessionMsg struct {
	MessageIndex                 MessageIndex // Selected bit is set for the current session.
	Timestamp                    time.Time    // Sesson end time.
	Event                        Event        // session
	EventType                    EventType    // stop
	StartTime                    time.Time
	StartPositionLat             Latitude
	StartPositionLong            Longitude
	Sport                        Sport
	SubSport                     SubSport
	TotalElapsedTime             uint32 // Time (includes pauses)
	TotalTimerTime               uint32 // Timer Time (excludes pauses)
	TotalDistance                uint32
	TotalCycles                  uint32
	TotalCalories                uint16
	TotalFatCalories             uint16
	AvgSpeed                     uint16 // total_distance / total_timer_time
	MaxSpeed                     uint16
	AvgHeartRate                 uint8 // average heart rate (excludes pause time)
	MaxHeartRate                 uint8
	AvgCadence                   uint8 // total_cycles / total_timer_time if non_zero_avg_cadence otherwise total_cycles / total_elapsed_time
	MaxCadence                   uint8
	AvgPower                     uint16 // total_power / total_timer_time if non_zero_avg_power otherwise total_power / total_elapsed_time
	MaxPower                     uint16
	TotalAscent                  uint16
	TotalDescent                 uint16
	TotalTrainingEffect          uint8
	FirstLapIndex                uint16
	NumLaps                      uint16
	EventGroup                   uint8
	Trigger                      SessionTrigger
	NecLat                       Latitude
	NecLong                      Longitude
	SwcLat                       Latitude
	SwcLong                      Longitude
	NormalizedPower              uint16
	TrainingStressScore          uint16
	IntensityFactor              uint16
	LeftRightBalance             LeftRightBalance100
	AvgStrokeCount               uint32
	AvgStrokeDistance            uint16
	SwimStroke                   SwimStroke
	PoolLength                   uint16
	ThresholdPower               uint16
	PoolLengthUnit               DisplayMeasure
	NumActiveLengths             uint16 // # of active lengths of swim pool
	TotalWork                    uint32
	AvgAltitude                  uint16
	MaxAltitude                  uint16
	GpsAccuracy                  uint8
	AvgGrade                     int16
	AvgPosGrade                  int16
	AvgNegGrade                  int16
	MaxPosGrade                  int16
	MaxNegGrade                  int16
	AvgTemperature               int8
	MaxTemperature               int8
	TotalMovingTime              uint32
	AvgPosVerticalSpeed          int16
	AvgNegVerticalSpeed          int16
	MaxPosVerticalSpeed          int16
	MaxNegVerticalSpeed          int16
	MinHeartRate                 uint8
	TimeInHrZone                 []uint32
	TimeInSpeedZone              []uint32
	TimeInCadenceZone            []uint32
	TimeInPowerZone              []uint32
	AvgLapTime                   uint32
	BestLapIndex                 uint16
	MinAltitude                  uint16
	PlayerScore                  uint16
	OpponentScore                uint16
	OpponentName                 string
	StrokeCount                  []uint16 // stroke_type enum used as the index
	ZoneCount                    []uint16 // zone number used as the index
	MaxBallSpeed                 uint16
	AvgBallSpeed                 uint16
	AvgVerticalOscillation       uint16
	AvgStanceTimePercent         uint16
	AvgStanceTime                uint16
	AvgFractionalCadence         uint8 // fractional part of the avg_cadence
	MaxFractionalCadence         uint8 // fractional part of the max_cadence
	TotalFractionalCycles        uint8 // fractional part of the total_cycles
	SportIndex                   uint8
	EnhancedAvgSpeed             uint32 // total_distance / total_timer_time
	EnhancedMaxSpeed             uint32
	EnhancedAvgAltitude          uint32
	EnhancedMinAltitude          uint32
	EnhancedMaxAltitude          uint32
	TotalAnaerobicTrainingEffect uint8
	AvgVam                       uint16
}

// NewSessionMsg returns a session FIT message
// initialized to all-invalid values.
func NewSessionMsg() *SessionMsg {
	return &SessionMsg{
		MessageIndex:                 0xFFFF,
		Timestamp:                    timeBase,
		Event:                        0xFF,
		EventType:                    0xFF,
		StartTime:                    timeBase,
		StartPositionLat:             NewLatitudeInvalid(),
		StartPositionLong:            NewLongitudeInvalid(),
		Sport:                        0xFF,
		SubSport:                     0xFF,
		TotalElapsedTime:             0xFFFFFFFF,
		TotalTimerTime:               0xFFFFFFFF,
		TotalDistance:                0xFFFFFFFF,
		TotalCycles:                  0xFFFFFFFF,
		TotalCalories:                0xFFFF,
		TotalFatCalories:             0xFFFF,
		AvgSpeed:                     0xFFFF,
		MaxSpeed:                     0xFFFF,
		AvgHeartRate:                 0xFF,
		MaxHeartRate:                 0xFF,
		AvgCadence:                   0xFF,
		MaxCadence:                   0xFF,
		AvgPower:                     0xFFFF,
		MaxPower:                     0xFFFF,
		TotalAscent:                  0xFFFF,
		TotalDescent:                 0xFFFF,
		TotalTrainingEffect:          0xFF,
		FirstLapIndex:                0xFFFF,
		NumLaps:                      0xFFFF,
		EventGroup:                   0xFF,
		Trigger:                      0xFF,
		NecLat:                       NewLatitudeInvalid(),
		NecLong:                      NewLongitudeInvalid(),
		SwcLat:                       NewLatitudeInvalid(),
		SwcLong:                      NewLongitudeInvalid(),
		NormalizedPower:              0xFFFF,
		TrainingStressScore:          0xFFFF,
		IntensityFactor:              0xFFFF,
		LeftRightBalance:             0xFFFF,
		AvgStrokeCount:               0xFFFFFFFF,
		AvgStrokeDistance:            0xFFFF,
		SwimStroke:                   0xFF,
		PoolLength:                   0xFFFF,
		ThresholdPower:               0xFFFF,
		PoolLengthUnit:               0xFF,
		NumActiveLengths:             0xFFFF,
		TotalWork:                    0xFFFFFFFF,
		AvgAltitude:                  0xFFFF,
		MaxAltitude:                  0xFFFF,
		GpsAccuracy:                  0xFF,
		AvgGrade:                     0x7FFF,
		AvgPosGrade:                  0x7FFF,
		AvgNegGrade:                  0x7FFF,
		MaxPosGrade:                  0x7FFF,
		MaxNegGrade:                  0x7FFF,
		AvgTemperature:               0x7F,
		MaxTemperature:               0x7F,
		TotalMovingTime:              0xFFFFFFFF,
		AvgPosVerticalSpeed:          0x7FFF,
		AvgNegVerticalSpeed:          0x7FFF,
		MaxPosVerticalSpeed:          0x7FFF,
		MaxNegVerticalSpeed:          0x7FFF,
		MinHeartRate:                 0xFF,
		TimeInHrZone:                 nil,
		TimeInSpeedZone:              nil,
		TimeInCadenceZone:            nil,
		TimeInPowerZone:              nil,
		AvgLapTime:                   0xFFFFFFFF,
		BestLapIndex:                 0xFFFF,
		MinAltitude:                  0xFFFF,
		PlayerScore:                  0xFFFF,
		OpponentScore:                0xFFFF,
		OpponentName:                 "",
		StrokeCount:                  nil,
		ZoneCount:                    nil,
		MaxBallSpeed:                 0xFFFF,
		AvgBallSpeed:                 0xFFFF,
		AvgVerticalOscillation:       0xFFFF,
		AvgStanceTimePercent:         0xFFFF,
		AvgStanceTime:                0xFFFF,
		AvgFractionalCadence:         0xFF,
		MaxFractionalCadence:         0xFF,
		TotalFractionalCycles:        0xFF,
		SportIndex:                   0xFF,
		EnhancedAvgSpeed:             0xFFFFFFFF,
		EnhancedMaxSpeed:             0xFFFFFFFF,
		EnhancedAvgAltitude:          0xFFFFFFFF,
		EnhancedMinAltitude:          0xFFFFFFFF,
		EnhancedMaxAltitude:          0xFFFFFFFF,
		TotalAnaerobicTrainingEffect: 0xFF,
		AvgVam: 0xFFFF,
	}
}

// GetTotalElapsedTimeScaled returns TotalElapsedTime
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: s
func (x *SessionMsg) GetTotalElapsedTimeScaled() float64 {
	if x.TotalElapsedTime == 0xFFFFFFFF {
		return math.NaN()
	}
	return float64(x.TotalElapsedTime) / 1000
}

// GetTotalTimerTimeScaled returns TotalTimerTime
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: s
func (x *SessionMsg) GetTotalTimerTimeScaled() float64 {
	if x.TotalTimerTime == 0xFFFFFFFF {
		return math.NaN()
	}
	return float64(x.TotalTimerTime) / 1000
}

// GetTotalDistanceScaled returns TotalDistance
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m
func (x *SessionMsg) GetTotalDistanceScaled() float64 {
	if x.TotalDistance == 0xFFFFFFFF {
		return math.NaN()
	}
	return float64(x.TotalDistance) / 100
}

// GetAvgSpeedScaled returns AvgSpeed
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m/s
func (x *SessionMsg) GetAvgSpeedScaled() float64 {
	if x.AvgSpeed == 0xFFFF {
		return math.NaN()
	}
	return float64(x.AvgSpeed) / 1000
}

// GetMaxSpeedScaled returns MaxSpeed
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m/s
func (x *SessionMsg) GetMaxSpeedScaled() float64 {
	if x.MaxSpeed == 0xFFFF {
		return math.NaN()
	}
	return float64(x.MaxSpeed) / 1000
}

// GetTotalTrainingEffectScaled returns TotalTrainingEffect
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
func (x *SessionMsg) GetTotalTrainingEffectScaled() float64 {
	if x.TotalTrainingEffect == 0xFF {
		return math.NaN()
	}
	return float64(x.TotalTrainingEffect) / 10
}

// GetTrainingStressScoreScaled returns TrainingStressScore
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: tss
func (x *SessionMsg) GetTrainingStressScoreScaled() float64 {
	if x.TrainingStressScore == 0xFFFF {
		return math.NaN()
	}
	return float64(x.TrainingStressScore) / 10
}

// GetIntensityFactorScaled returns IntensityFactor
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: if
func (x *SessionMsg) GetIntensityFactorScaled() float64 {
	if x.IntensityFactor == 0xFFFF {
		return math.NaN()
	}
	return float64(x.IntensityFactor) / 1000
}

// GetAvgStrokeCountScaled returns AvgStrokeCount
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: strokes/lap
func (x *SessionMsg) GetAvgStrokeCountScaled() float64 {
	if x.AvgStrokeCount == 0xFFFFFFFF {
		return math.NaN()
	}
	return float64(x.AvgStrokeCount) / 10
}

// GetAvgStrokeDistanceScaled returns AvgStrokeDistance
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m
func (x *SessionMsg) GetAvgStrokeDistanceScaled() float64 {
	if x.AvgStrokeDistance == 0xFFFF {
		return math.NaN()
	}
	return float64(x.AvgStrokeDistance) / 100
}

// GetPoolLengthScaled returns PoolLength
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m
func (x *SessionMsg) GetPoolLengthScaled() float64 {
	if x.PoolLength == 0xFFFF {
		return math.NaN()
	}
	return float64(x.PoolLength) / 100
}

// GetAvgAltitudeScaled returns AvgAltitude
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m
func (x *SessionMsg) GetAvgAltitudeScaled() float64 {
	if x.AvgAltitude == 0xFFFF {
		return math.NaN()
	}
	return float64(x.AvgAltitude)/5 - 500
}

// GetMaxAltitudeScaled returns MaxAltitude
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m
func (x *SessionMsg) GetMaxAltitudeScaled() float64 {
	if x.MaxAltitude == 0xFFFF {
		return math.NaN()
	}
	return float64(x.MaxAltitude)/5 - 500
}

// GetAvgGradeScaled returns AvgGrade
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: %
func (x *SessionMsg) GetAvgGradeScaled() float64 {
	if x.AvgGrade == 0x7FFF {
		return math.NaN()
	}
	return float64(x.AvgGrade) / 100
}

// GetAvgPosGradeScaled returns AvgPosGrade
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: %
func (x *SessionMsg) GetAvgPosGradeScaled() float64 {
	if x.AvgPosGrade == 0x7FFF {
		return math.NaN()
	}
	return float64(x.AvgPosGrade) / 100
}

// GetAvgNegGradeScaled returns AvgNegGrade
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: %
func (x *SessionMsg) GetAvgNegGradeScaled() float64 {
	if x.AvgNegGrade == 0x7FFF {
		return math.NaN()
	}
	return float64(x.AvgNegGrade) / 100
}

// GetMaxPosGradeScaled returns MaxPosGrade
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: %
func (x *SessionMsg) GetMaxPosGradeScaled() float64 {
	if x.MaxPosGrade == 0x7FFF {
		return math.NaN()
	}
	return float64(x.MaxPosGrade) / 100
}

// GetMaxNegGradeScaled returns MaxNegGrade
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: %
func (x *SessionMsg) GetMaxNegGradeScaled() float64 {
	if x.MaxNegGrade == 0x7FFF {
		return math.NaN()
	}
	return float64(x.MaxNegGrade) / 100
}

// GetTotalMovingTimeScaled returns TotalMovingTime
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: s
func (x *SessionMsg) GetTotalMovingTimeScaled() float64 {
	if x.TotalMovingTime == 0xFFFFFFFF {
		return math.NaN()
	}
	return float64(x.TotalMovingTime) / 1000
}

// GetAvgPosVerticalSpeedScaled returns AvgPosVerticalSpeed
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m/s
func (x *SessionMsg) GetAvgPosVerticalSpeedScaled() float64 {
	if x.AvgPosVerticalSpeed == 0x7FFF {
		return math.NaN()
	}
	return float64(x.AvgPosVerticalSpeed) / 1000
}

// GetAvgNegVerticalSpeedScaled returns AvgNegVerticalSpeed
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m/s
func (x *SessionMsg) GetAvgNegVerticalSpeedScaled() float64 {
	if x.AvgNegVerticalSpeed == 0x7FFF {
		return math.NaN()
	}
	return float64(x.AvgNegVerticalSpeed) / 1000
}

// GetMaxPosVerticalSpeedScaled returns MaxPosVerticalSpeed
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m/s
func (x *SessionMsg) GetMaxPosVerticalSpeedScaled() float64 {
	if x.MaxPosVerticalSpeed == 0x7FFF {
		return math.NaN()
	}
	return float64(x.MaxPosVerticalSpeed) / 1000
}

// GetMaxNegVerticalSpeedScaled returns MaxNegVerticalSpeed
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m/s
func (x *SessionMsg) GetMaxNegVerticalSpeedScaled() float64 {
	if x.MaxNegVerticalSpeed == 0x7FFF {
		return math.NaN()
	}
	return float64(x.MaxNegVerticalSpeed) / 1000
}

// GetTimeInHrZoneScaled returns TimeInHrZone
// as a slice with scale and any offset applied to every element.
// Units: s
func (x *SessionMsg) GetTimeInHrZoneScaled() []float64 {
	if len(x.TimeInHrZone) == 0 {
		return nil
	}
	s := make([]float64, len(x.TimeInHrZone))
	for i, v := range x.TimeInHrZone {
		s[i] = float64(v) / 1000
	}
	return s
}

// GetTimeInSpeedZoneScaled returns TimeInSpeedZone
// as a slice with scale and any offset applied to every element.
// Units: s
func (x *SessionMsg) GetTimeInSpeedZoneScaled() []float64 {
	if len(x.TimeInSpeedZone) == 0 {
		return nil
	}
	s := make([]float64, len(x.TimeInSpeedZone))
	for i, v := range x.TimeInSpeedZone {
		s[i] = float64(v) / 1000
	}
	return s
}

// GetTimeInCadenceZoneScaled returns TimeInCadenceZone
// as a slice with scale and any offset applied to every element.
// Units: s
func (x *SessionMsg) GetTimeInCadenceZoneScaled() []float64 {
	if len(x.TimeInCadenceZone) == 0 {
		return nil
	}
	s := make([]float64, len(x.TimeInCadenceZone))
	for i, v := range x.TimeInCadenceZone {
		s[i] = float64(v) / 1000
	}
	return s
}

// GetTimeInPowerZoneScaled returns TimeInPowerZone
// as a slice with scale and any offset applied to every element.
// Units: s
func (x *SessionMsg) GetTimeInPowerZoneScaled() []float64 {
	if len(x.TimeInPowerZone) == 0 {
		return nil
	}
	s := make([]float64, len(x.TimeInPowerZone))
	for i, v := range x.TimeInPowerZone {
		s[i] = float64(v) / 1000
	}
	return s
}

// GetAvgLapTimeScaled returns AvgLapTime
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: s
func (x *SessionMsg) GetAvgLapTimeScaled() float64 {
	if x.AvgLapTime == 0xFFFFFFFF {
		return math.NaN()
	}
	return float64(x.AvgLapTime) / 1000
}

// GetMinAltitudeScaled returns MinAltitude
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m
func (x *SessionMsg) GetMinAltitudeScaled() float64 {
	if x.MinAltitude == 0xFFFF {
		return math.NaN()
	}
	return float64(x.MinAltitude)/5 - 500
}

// GetMaxBallSpeedScaled returns MaxBallSpeed
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m/s
func (x *SessionMsg) GetMaxBallSpeedScaled() float64 {
	if x.MaxBallSpeed == 0xFFFF {
		return math.NaN()
	}
	return float64(x.MaxBallSpeed) / 100
}

// GetAvgBallSpeedScaled returns AvgBallSpeed
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m/s
func (x *SessionMsg) GetAvgBallSpeedScaled() float64 {
	if x.AvgBallSpeed == 0xFFFF {
		return math.NaN()
	}
	return float64(x.AvgBallSpeed) / 100
}

// GetAvgVerticalOscillationScaled returns AvgVerticalOscillation
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: mm
func (x *SessionMsg) GetAvgVerticalOscillationScaled() float64 {
	if x.AvgVerticalOscillation == 0xFFFF {
		return math.NaN()
	}
	return float64(x.AvgVerticalOscillation) / 10
}

// GetAvgStanceTimePercentScaled returns AvgStanceTimePercent
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: percent
func (x *SessionMsg) GetAvgStanceTimePercentScaled() float64 {
	if x.AvgStanceTimePercent == 0xFFFF {
		return math.NaN()
	}
	return float64(x.AvgStanceTimePercent) / 100
}

// GetAvgStanceTimeScaled returns AvgStanceTime
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: ms
func (x *SessionMsg) GetAvgStanceTimeScaled() float64 {
	if x.AvgStanceTime == 0xFFFF {
		return math.NaN()
	}
	return float64(x.AvgStanceTime) / 10
}

// GetAvgFractionalCadenceScaled returns AvgFractionalCadence
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: rpm
func (x *SessionMsg) GetAvgFractionalCadenceScaled() float64 {
	if x.AvgFractionalCadence == 0xFF {
		return math.NaN()
	}
	return float64(x.AvgFractionalCadence) / 128
}

// GetMaxFractionalCadenceScaled returns MaxFractionalCadence
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: rpm
func (x *SessionMsg) GetMaxFractionalCadenceScaled() float64 {
	if x.MaxFractionalCadence == 0xFF {
		return math.NaN()
	}
	return float64(x.MaxFractionalCadence) / 128
}

// GetTotalFractionalCyclesScaled returns TotalFractionalCycles
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: cycles
func (x *SessionMsg) GetTotalFractionalCyclesScaled() float64 {
	if x.TotalFractionalCycles == 0xFF {
		return math.NaN()
	}
	return float64(x.TotalFractionalCycles) / 128
}

// GetEnhancedAvgSpeedScaled returns EnhancedAvgSpeed
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m/s
func (x *SessionMsg) GetEnhancedAvgSpeedScaled() float64 {
	if x.EnhancedAvgSpeed == 0xFFFFFFFF {
		return math.NaN()
	}
	return float64(x.EnhancedAvgSpeed) / 1000
}

// GetEnhancedMaxSpeedScaled returns EnhancedMaxSpeed
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m/s
func (x *SessionMsg) GetEnhancedMaxSpeedScaled() float64 {
	if x.EnhancedMaxSpeed == 0xFFFFFFFF {
		return math.NaN()
	}
	return float64(x.EnhancedMaxSpeed) / 1000
}

// GetEnhancedAvgAltitudeScaled returns EnhancedAvgAltitude
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m
func (x *SessionMsg) GetEnhancedAvgAltitudeScaled() float64 {
	if x.EnhancedAvgAltitude == 0xFFFFFFFF {
		return math.NaN()
	}
	return float64(x.EnhancedAvgAltitude)/5 - 500
}

// GetEnhancedMinAltitudeScaled returns EnhancedMinAltitude
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m
func (x *SessionMsg) GetEnhancedMinAltitudeScaled() float64 {
	if x.EnhancedMinAltitude == 0xFFFFFFFF {
		return math.NaN()
	}
	return float64(x.EnhancedMinAltitude)/5 - 500
}

// GetEnhancedMaxAltitudeScaled returns EnhancedMaxAltitude
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m
func (x *SessionMsg) GetEnhancedMaxAltitudeScaled() float64 {
	if x.EnhancedMaxAltitude == 0xFFFFFFFF {
		return math.NaN()
	}
	return float64(x.EnhancedMaxAltitude)/5 - 500
}

// GetTotalAnaerobicTrainingEffectScaled returns TotalAnaerobicTrainingEffect
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
func (x *SessionMsg) GetTotalAnaerobicTrainingEffectScaled() float64 {
	if x.TotalAnaerobicTrainingEffect == 0xFF {
		return math.NaN()
	}
	return float64(x.TotalAnaerobicTrainingEffect) / 10
}

// GetAvgVamScaled returns AvgVam
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m/s
func (x *SessionMsg) GetAvgVamScaled() float64 {
	if x.AvgVam == 0xFFFF {
		return math.NaN()
	}
	return float64(x.AvgVam) / 1000
}

// GetTotalCycles returns the appropriate TotalCycles
// subfield if a matching reference field/value combination is found.
// If none of the reference field/value combinations are true
// then the main field is returned.
func (x *SessionMsg) GetTotalCycles() interface{} {
	switch x.Sport {
	case SportRunning, SportWalking:
		return uint32(x.TotalCycles)
	default:
		return x.TotalCycles
	}
}

// GetAvgCadence returns the appropriate AvgCadence
// subfield if a matching reference field/value combination is found.
// If none of the reference field/value combinations are true
// then the main field is returned.
func (x *SessionMsg) GetAvgCadence() interface{} {
	switch x.Sport {
	case SportRunning:
		return uint8(x.AvgCadence)
	default:
		return x.AvgCadence
	}
}

// GetMaxCadence returns the appropriate MaxCadence
// subfield if a matching reference field/value combination is found.
// If none of the reference field/value combinations are true
// then the main field is returned.
func (x *SessionMsg) GetMaxCadence() interface{} {
	switch x.Sport {
	case SportRunning:
		return uint8(x.MaxCadence)
	default:
		return x.MaxCadence
	}
}

func (x *SessionMsg) expandComponents() {
	if x.AvgSpeed != 0xFFFF {
		x.EnhancedAvgSpeed = uint32(
			(x.AvgSpeed >> 0) & ((1 << 16) - 1),
		)
	}
	if x.MaxSpeed != 0xFFFF {
		x.EnhancedMaxSpeed = uint32(
			(x.MaxSpeed >> 0) & ((1 << 16) - 1),
		)
	}
	if x.AvgAltitude != 0xFFFF {
		x.EnhancedAvgAltitude = uint32(
			(x.AvgAltitude >> 0) & ((1 << 16) - 1),
		)
	}
	if x.MaxAltitude != 0xFFFF {
		x.EnhancedMaxAltitude = uint32(
			(x.MaxAltitude >> 0) & ((1 << 16) - 1),
		)
	}
	if x.MinAltitude != 0xFFFF {
		x.EnhancedMinAltitude = uint32(
			(x.MinAltitude >> 0) & ((1 << 16) - 1),
		)
	}
}

// LapMsg represents the lap FIT message type.
type LapMsg struct {
	MessageIndex                  MessageIndex
	Timestamp                     time.Time // Lap end time.
	Event                         Event
	EventType                     EventType
	StartTime                     time.Time
	StartPositionLat              Latitude
	StartPositionLong             Longitude
	EndPositionLat                Latitude
	EndPositionLong               Longitude
	TotalElapsedTime              uint32 // Time (includes pauses)
	TotalTimerTime                uint32 // Timer Time (excludes pauses)
	TotalDistance                 uint32
	TotalCycles                   uint32
	TotalCalories                 uint16
	TotalFatCalories              uint16 // If New Leaf
	AvgSpeed                      uint16
	MaxSpeed                      uint16
	AvgHeartRate                  uint8
	MaxHeartRate                  uint8
	AvgCadence                    uint8 // total_cycles / total_timer_time if non_zero_avg_cadence otherwise total_cycles / total_elapsed_time
	MaxCadence                    uint8
	AvgPower                      uint16 // total_power / total_timer_time if non_zero_avg_power otherwise total_power / total_elapsed_time
	MaxPower                      uint16
	TotalAscent                   uint16
	TotalDescent                  uint16
	Intensity                     Intensity
	LapTrigger                    LapTrigger
	Sport                         Sport
	EventGroup                    uint8
	NumLengths                    uint16 // # of lengths of swim pool
	NormalizedPower               uint16
	LeftRightBalance              LeftRightBalance100
	FirstLengthIndex              uint16
	AvgStrokeDistance             uint16
	SwimStroke                    SwimStroke
	SubSport                      SubSport
	NumActiveLengths              uint16 // # of active lengths of swim pool
	TotalWork                     uint32
	AvgAltitude                   uint16
	MaxAltitude                   uint16
	GpsAccuracy                   uint8
	AvgGrade                      int16
	AvgPosGrade                   int16
	AvgNegGrade                   int16
	MaxPosGrade                   int16
	MaxNegGrade                   int16
	AvgTemperature                int8
	MaxTemperature                int8
	TotalMovingTime               uint32
	AvgPosVerticalSpeed           int16
	AvgNegVerticalSpeed           int16
	MaxPosVerticalSpeed           int16
	MaxNegVerticalSpeed           int16
	TimeInHrZone                  []uint32
	TimeInSpeedZone               []uint32
	TimeInCadenceZone             []uint32
	TimeInPowerZone               []uint32
	RepetitionNum                 uint16
	MinAltitude                   uint16
	MinHeartRate                  uint8
	WktStepIndex                  MessageIndex
	OpponentScore                 uint16
	StrokeCount                   []uint16 // stroke_type enum used as the index
	ZoneCount                     []uint16 // zone number used as the index
	AvgVerticalOscillation        uint16
	AvgStanceTimePercent          uint16
	AvgStanceTime                 uint16
	AvgFractionalCadence          uint8 // fractional part of the avg_cadence
	MaxFractionalCadence          uint8 // fractional part of the max_cadence
	TotalFractionalCycles         uint8 // fractional part of the total_cycles
	PlayerScore                   uint16
	AvgTotalHemoglobinConc        []uint16 // Avg saturated and unsaturated hemoglobin
	MinTotalHemoglobinConc        []uint16 // Min saturated and unsaturated hemoglobin
	MaxTotalHemoglobinConc        []uint16 // Max saturated and unsaturated hemoglobin
	AvgSaturatedHemoglobinPercent []uint16 // Avg percentage of hemoglobin saturated with oxygen
	MinSaturatedHemoglobinPercent []uint16 // Min percentage of hemoglobin saturated with oxygen
	MaxSaturatedHemoglobinPercent []uint16 // Max percentage of hemoglobin saturated with oxygen
	EnhancedAvgSpeed              uint32
	EnhancedMaxSpeed              uint32
	EnhancedAvgAltitude           uint32
	EnhancedMinAltitude           uint32
	EnhancedMaxAltitude           uint32
	AvgVam                        uint16
}

// NewLapMsg returns a lap FIT message
// initialized to all-invalid values.
func NewLapMsg() *LapMsg {
	return &LapMsg{
		MessageIndex:                  0xFFFF,
		Timestamp:                     timeBase,
		Event:                         0xFF,
		EventType:                     0xFF,
		StartTime:                     timeBase,
		StartPositionLat:              NewLatitudeInvalid(),
		StartPositionLong:             NewLongitudeInvalid(),
		EndPositionLat:                NewLatitudeInvalid(),
		EndPositionLong:               NewLongitudeInvalid(),
		TotalElapsedTime:              0xFFFFFFFF,
		TotalTimerTime:                0xFFFFFFFF,
		TotalDistance:                 0xFFFFFFFF,
		TotalCycles:                   0xFFFFFFFF,
		TotalCalories:                 0xFFFF,
		TotalFatCalories:              0xFFFF,
		AvgSpeed:                      0xFFFF,
		MaxSpeed:                      0xFFFF,
		AvgHeartRate:                  0xFF,
		MaxHeartRate:                  0xFF,
		AvgCadence:                    0xFF,
		MaxCadence:                    0xFF,
		AvgPower:                      0xFFFF,
		MaxPower:                      0xFFFF,
		TotalAscent:                   0xFFFF,
		TotalDescent:                  0xFFFF,
		Intensity:                     0xFF,
		LapTrigger:                    0xFF,
		Sport:                         0xFF,
		EventGroup:                    0xFF,
		NumLengths:                    0xFFFF,
		NormalizedPower:               0xFFFF,
		LeftRightBalance:              0xFFFF,
		FirstLengthIndex:              0xFFFF,
		AvgStrokeDistance:             0xFFFF,
		SwimStroke:                    0xFF,
		SubSport:                      0xFF,
		NumActiveLengths:              0xFFFF,
		TotalWork:                     0xFFFFFFFF,
		AvgAltitude:                   0xFFFF,
		MaxAltitude:                   0xFFFF,
		GpsAccuracy:                   0xFF,
		AvgGrade:                      0x7FFF,
		AvgPosGrade:                   0x7FFF,
		AvgNegGrade:                   0x7FFF,
		MaxPosGrade:                   0x7FFF,
		MaxNegGrade:                   0x7FFF,
		AvgTemperature:                0x7F,
		MaxTemperature:                0x7F,
		TotalMovingTime:               0xFFFFFFFF,
		AvgPosVerticalSpeed:           0x7FFF,
		AvgNegVerticalSpeed:           0x7FFF,
		MaxPosVerticalSpeed:           0x7FFF,
		MaxNegVerticalSpeed:           0x7FFF,
		TimeInHrZone:                  nil,
		TimeInSpeedZone:               nil,
		TimeInCadenceZone:             nil,
		TimeInPowerZone:               nil,
		RepetitionNum:                 0xFFFF,
		MinAltitude:                   0xFFFF,
		MinHeartRate:                  0xFF,
		WktStepIndex:                  0xFFFF,
		OpponentScore:                 0xFFFF,
		StrokeCount:                   nil,
		ZoneCount:                     nil,
		AvgVerticalOscillation:        0xFFFF,
		AvgStanceTimePercent:          0xFFFF,
		AvgStanceTime:                 0xFFFF,
		AvgFractionalCadence:          0xFF,
		MaxFractionalCadence:          0xFF,
		TotalFractionalCycles:         0xFF,
		PlayerScore:                   0xFFFF,
		AvgTotalHemoglobinConc:        nil,
		MinTotalHemoglobinConc:        nil,
		MaxTotalHemoglobinConc:        nil,
		AvgSaturatedHemoglobinPercent: nil,
		MinSaturatedHemoglobinPercent: nil,
		MaxSaturatedHemoglobinPercent: nil,
		EnhancedAvgSpeed:              0xFFFFFFFF,
		EnhancedMaxSpeed:              0xFFFFFFFF,
		EnhancedAvgAltitude:           0xFFFFFFFF,
		EnhancedMinAltitude:           0xFFFFFFFF,
		EnhancedMaxAltitude:           0xFFFFFFFF,
		AvgVam:                        0xFFFF,
	}
}

// GetTotalElapsedTimeScaled returns TotalElapsedTime
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: s
func (x *LapMsg) GetTotalElapsedTimeScaled() float64 {
	if x.TotalElapsedTime == 0xFFFFFFFF {
		return math.NaN()
	}
	return float64(x.TotalElapsedTime) / 1000
}

// GetTotalTimerTimeScaled returns TotalTimerTime
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: s
func (x *LapMsg) GetTotalTimerTimeScaled() float64 {
	if x.TotalTimerTime == 0xFFFFFFFF {
		return math.NaN()
	}
	return float64(x.TotalTimerTime) / 1000
}

// GetTotalDistanceScaled returns TotalDistance
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m
func (x *LapMsg) GetTotalDistanceScaled() float64 {
	if x.TotalDistance == 0xFFFFFFFF {
		return math.NaN()
	}
	return float64(x.TotalDistance) / 100
}

// GetAvgSpeedScaled returns AvgSpeed
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m/s
func (x *LapMsg) GetAvgSpeedScaled() float64 {
	if x.AvgSpeed == 0xFFFF {
		return math.NaN()
	}
	return float64(x.AvgSpeed) / 1000
}

// GetMaxSpeedScaled returns MaxSpeed
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m/s
func (x *LapMsg) GetMaxSpeedScaled() float64 {
	if x.MaxSpeed == 0xFFFF {
		return math.NaN()
	}
	return float64(x.MaxSpeed) / 1000
}

// GetAvgStrokeDistanceScaled returns AvgStrokeDistance
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m
func (x *LapMsg) GetAvgStrokeDistanceScaled() float64 {
	if x.AvgStrokeDistance == 0xFFFF {
		return math.NaN()
	}
	return float64(x.AvgStrokeDistance) / 100
}

// GetAvgAltitudeScaled returns AvgAltitude
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m
func (x *LapMsg) GetAvgAltitudeScaled() float64 {
	if x.AvgAltitude == 0xFFFF {
		return math.NaN()
	}
	return float64(x.AvgAltitude)/5 - 500
}

// GetMaxAltitudeScaled returns MaxAltitude
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m
func (x *LapMsg) GetMaxAltitudeScaled() float64 {
	if x.MaxAltitude == 0xFFFF {
		return math.NaN()
	}
	return float64(x.MaxAltitude)/5 - 500
}

// GetAvgGradeScaled returns AvgGrade
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: %
func (x *LapMsg) GetAvgGradeScaled() float64 {
	if x.AvgGrade == 0x7FFF {
		return math.NaN()
	}
	return float64(x.AvgGrade) / 100
}

// GetAvgPosGradeScaled returns AvgPosGrade
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: %
func (x *LapMsg) GetAvgPosGradeScaled() float64 {
	if x.AvgPosGrade == 0x7FFF {
		return math.NaN()
	}
	return float64(x.AvgPosGrade) / 100
}

// GetAvgNegGradeScaled returns AvgNegGrade
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: %
func (x *LapMsg) GetAvgNegGradeScaled() float64 {
	if x.AvgNegGrade == 0x7FFF {
		return math.NaN()
	}
	return float64(x.AvgNegGrade) / 100
}

// GetMaxPosGradeScaled returns MaxPosGrade
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: %
func (x *LapMsg) GetMaxPosGradeScaled() float64 {
	if x.MaxPosGrade == 0x7FFF {
		return math.NaN()
	}
	return float64(x.MaxPosGrade) / 100
}

// GetMaxNegGradeScaled returns MaxNegGrade
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: %
func (x *LapMsg) GetMaxNegGradeScaled() float64 {
	if x.MaxNegGrade == 0x7FFF {
		return math.NaN()
	}
	return float64(x.MaxNegGrade) / 100
}

// GetTotalMovingTimeScaled returns TotalMovingTime
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: s
func (x *LapMsg) GetTotalMovingTimeScaled() float64 {
	if x.TotalMovingTime == 0xFFFFFFFF {
		return math.NaN()
	}
	return float64(x.TotalMovingTime) / 1000
}

// GetAvgPosVerticalSpeedScaled returns AvgPosVerticalSpeed
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m/s
func (x *LapMsg) GetAvgPosVerticalSpeedScaled() float64 {
	if x.AvgPosVerticalSpeed == 0x7FFF {
		return math.NaN()
	}
	return float64(x.AvgPosVerticalSpeed) / 1000
}

// GetAvgNegVerticalSpeedScaled returns AvgNegVerticalSpeed
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m/s
func (x *LapMsg) GetAvgNegVerticalSpeedScaled() float64 {
	if x.AvgNegVerticalSpeed == 0x7FFF {
		return math.NaN()
	}
	return float64(x.AvgNegVerticalSpeed) / 1000
}

// GetMaxPosVerticalSpeedScaled returns MaxPosVerticalSpeed
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m/s
func (x *LapMsg) GetMaxPosVerticalSpeedScaled() float64 {
	if x.MaxPosVerticalSpeed == 0x7FFF {
		return math.NaN()
	}
	return float64(x.MaxPosVerticalSpeed) / 1000
}

// GetMaxNegVerticalSpeedScaled returns MaxNegVerticalSpeed
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m/s
func (x *LapMsg) GetMaxNegVerticalSpeedScaled() float64 {
	if x.MaxNegVerticalSpeed == 0x7FFF {
		return math.NaN()
	}
	return float64(x.MaxNegVerticalSpeed) / 1000
}

// GetTimeInHrZoneScaled returns TimeInHrZone
// as a slice with scale and any offset applied to every element.
// Units: s
func (x *LapMsg) GetTimeInHrZoneScaled() []float64 {
	if len(x.TimeInHrZone) == 0 {
		return nil
	}
	s := make([]float64, len(x.TimeInHrZone))
	for i, v := range x.TimeInHrZone {
		s[i] = float64(v) / 1000
	}
	return s
}

// GetTimeInSpeedZoneScaled returns TimeInSpeedZone
// as a slice with scale and any offset applied to every element.
// Units: s
func (x *LapMsg) GetTimeInSpeedZoneScaled() []float64 {
	if len(x.TimeInSpeedZone) == 0 {
		return nil
	}
	s := make([]float64, len(x.TimeInSpeedZone))
	for i, v := range x.TimeInSpeedZone {
		s[i] = float64(v) / 1000
	}
	return s
}

// GetTimeInCadenceZoneScaled returns TimeInCadenceZone
// as a slice with scale and any offset applied to every element.
// Units: s
func (x *LapMsg) GetTimeInCadenceZoneScaled() []float64 {
	if len(x.TimeInCadenceZone) == 0 {
		return nil
	}
	s := make([]float64, len(x.TimeInCadenceZone))
	for i, v := range x.TimeInCadenceZone {
		s[i] = float64(v) / 1000
	}
	return s
}

// GetTimeInPowerZoneScaled returns TimeInPowerZone
// as a slice with scale and any offset applied to every element.
// Units: s
func (x *LapMsg) GetTimeInPowerZoneScaled() []float64 {
	if len(x.TimeInPowerZone) == 0 {
		return nil
	}
	s := make([]float64, len(x.TimeInPowerZone))
	for i, v := range x.TimeInPowerZone {
		s[i] = float64(v) / 1000
	}
	return s
}

// GetMinAltitudeScaled returns MinAltitude
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m
func (x *LapMsg) GetMinAltitudeScaled() float64 {
	if x.MinAltitude == 0xFFFF {
		return math.NaN()
	}
	return float64(x.MinAltitude)/5 - 500
}

// GetAvgVerticalOscillationScaled returns AvgVerticalOscillation
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: mm
func (x *LapMsg) GetAvgVerticalOscillationScaled() float64 {
	if x.AvgVerticalOscillation == 0xFFFF {
		return math.NaN()
	}
	return float64(x.AvgVerticalOscillation) / 10
}

// GetAvgStanceTimePercentScaled returns AvgStanceTimePercent
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: percent
func (x *LapMsg) GetAvgStanceTimePercentScaled() float64 {
	if x.AvgStanceTimePercent == 0xFFFF {
		return math.NaN()
	}
	return float64(x.AvgStanceTimePercent) / 100
}

// GetAvgStanceTimeScaled returns AvgStanceTime
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: ms
func (x *LapMsg) GetAvgStanceTimeScaled() float64 {
	if x.AvgStanceTime == 0xFFFF {
		return math.NaN()
	}
	return float64(x.AvgStanceTime) / 10
}

// GetAvgFractionalCadenceScaled returns AvgFractionalCadence
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: rpm
func (x *LapMsg) GetAvgFractionalCadenceScaled() float64 {
	if x.AvgFractionalCadence == 0xFF {
		return math.NaN()
	}
	return float64(x.AvgFractionalCadence) / 128
}

// GetMaxFractionalCadenceScaled returns MaxFractionalCadence
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: rpm
func (x *LapMsg) GetMaxFractionalCadenceScaled() float64 {
	if x.MaxFractionalCadence == 0xFF {
		return math.NaN()
	}
	return float64(x.MaxFractionalCadence) / 128
}

// GetTotalFractionalCyclesScaled returns TotalFractionalCycles
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: cycles
func (x *LapMsg) GetTotalFractionalCyclesScaled() float64 {
	if x.TotalFractionalCycles == 0xFF {
		return math.NaN()
	}
	return float64(x.TotalFractionalCycles) / 128
}

// GetAvgTotalHemoglobinConcScaled returns AvgTotalHemoglobinConc
// as a slice with scale and any offset applied to every element.
// Units: g/dL
func (x *LapMsg) GetAvgTotalHemoglobinConcScaled() []float64 {
	if len(x.AvgTotalHemoglobinConc) == 0 {
		return nil
	}
	s := make([]float64, len(x.AvgTotalHemoglobinConc))
	for i, v := range x.AvgTotalHemoglobinConc {
		s[i] = float64(v) / 100
	}
	return s
}

// GetMinTotalHemoglobinConcScaled returns MinTotalHemoglobinConc
// as a slice with scale and any offset applied to every element.
// Units: g/dL
func (x *LapMsg) GetMinTotalHemoglobinConcScaled() []float64 {
	if len(x.MinTotalHemoglobinConc) == 0 {
		return nil
	}
	s := make([]float64, len(x.MinTotalHemoglobinConc))
	for i, v := range x.MinTotalHemoglobinConc {
		s[i] = float64(v) / 100
	}
	return s
}

// GetMaxTotalHemoglobinConcScaled returns MaxTotalHemoglobinConc
// as a slice with scale and any offset applied to every element.
// Units: g/dL
func (x *LapMsg) GetMaxTotalHemoglobinConcScaled() []float64 {
	if len(x.MaxTotalHemoglobinConc) == 0 {
		return nil
	}
	s := make([]float64, len(x.MaxTotalHemoglobinConc))
	for i, v := range x.MaxTotalHemoglobinConc {
		s[i] = float64(v) / 100
	}
	return s
}

// GetAvgSaturatedHemoglobinPercentScaled returns AvgSaturatedHemoglobinPercent
// as a slice with scale and any offset applied to every element.
// Units: %
func (x *LapMsg) GetAvgSaturatedHemoglobinPercentScaled() []float64 {
	if len(x.AvgSaturatedHemoglobinPercent) == 0 {
		return nil
	}
	s := make([]float64, len(x.AvgSaturatedHemoglobinPercent))
	for i, v := range x.AvgSaturatedHemoglobinPercent {
		s[i] = float64(v) / 10
	}
	return s
}

// GetMinSaturatedHemoglobinPercentScaled returns MinSaturatedHemoglobinPercent
// as a slice with scale and any offset applied to every element.
// Units: %
func (x *LapMsg) GetMinSaturatedHemoglobinPercentScaled() []float64 {
	if len(x.MinSaturatedHemoglobinPercent) == 0 {
		return nil
	}
	s := make([]float64, len(x.MinSaturatedHemoglobinPercent))
	for i, v := range x.MinSaturatedHemoglobinPercent {
		s[i] = float64(v) / 10
	}
	return s
}

// GetMaxSaturatedHemoglobinPercentScaled returns MaxSaturatedHemoglobinPercent
// as a slice with scale and any offset applied to every element.
// Units: %
func (x *LapMsg) GetMaxSaturatedHemoglobinPercentScaled() []float64 {
	if len(x.MaxSaturatedHemoglobinPercent) == 0 {
		return nil
	}
	s := make([]float64, len(x.MaxSaturatedHemoglobinPercent))
	for i, v := range x.MaxSaturatedHemoglobinPercent {
		s[i] = float64(v) / 10
	}
	return s
}

// GetEnhancedAvgSpeedScaled returns EnhancedAvgSpeed
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m/s
func (x *LapMsg) GetEnhancedAvgSpeedScaled() float64 {
	if x.EnhancedAvgSpeed == 0xFFFFFFFF {
		return math.NaN()
	}
	return float64(x.EnhancedAvgSpeed) / 1000
}

// GetEnhancedMaxSpeedScaled returns EnhancedMaxSpeed
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m/s
func (x *LapMsg) GetEnhancedMaxSpeedScaled() float64 {
	if x.EnhancedMaxSpeed == 0xFFFFFFFF {
		return math.NaN()
	}
	return float64(x.EnhancedMaxSpeed) / 1000
}

// GetEnhancedAvgAltitudeScaled returns EnhancedAvgAltitude
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m
func (x *LapMsg) GetEnhancedAvgAltitudeScaled() float64 {
	if x.EnhancedAvgAltitude == 0xFFFFFFFF {
		return math.NaN()
	}
	return float64(x.EnhancedAvgAltitude)/5 - 500
}

// GetEnhancedMinAltitudeScaled returns EnhancedMinAltitude
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m
func (x *LapMsg) GetEnhancedMinAltitudeScaled() float64 {
	if x.EnhancedMinAltitude == 0xFFFFFFFF {
		return math.NaN()
	}
	return float64(x.EnhancedMinAltitude)/5 - 500
}

// GetEnhancedMaxAltitudeScaled returns EnhancedMaxAltitude
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m
func (x *LapMsg) GetEnhancedMaxAltitudeScaled() float64 {
	if x.EnhancedMaxAltitude == 0xFFFFFFFF {
		return math.NaN()
	}
	return float64(x.EnhancedMaxAltitude)/5 - 500
}

// GetAvgVamScaled returns AvgVam
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m/s
func (x *LapMsg) GetAvgVamScaled() float64 {
	if x.AvgVam == 0xFFFF {
		return math.NaN()
	}
	return float64(x.AvgVam) / 1000
}

// GetTotalCycles returns the appropriate TotalCycles
// subfield if a matching reference field/value combination is found.
// If none of the reference field/value combinations are true
// then the main field is returned.
func (x *LapMsg) GetTotalCycles() interface{} {
	switch x.Sport {
	case SportRunning, SportWalking:
		return uint32(x.TotalCycles)
	default:
		return x.TotalCycles
	}
}

// GetAvgCadence returns the appropriate AvgCadence
// subfield if a matching reference field/value combination is found.
// If none of the reference field/value combinations are true
// then the main field is returned.
func (x *LapMsg) GetAvgCadence() interface{} {
	switch x.Sport {
	case SportRunning:
		return uint8(x.AvgCadence)
	default:
		return x.AvgCadence
	}
}

// GetMaxCadence returns the appropriate MaxCadence
// subfield if a matching reference field/value combination is found.
// If none of the reference field/value combinations are true
// then the main field is returned.
func (x *LapMsg) GetMaxCadence() interface{} {
	switch x.Sport {
	case SportRunning:
		return uint8(x.MaxCadence)
	default:
		return x.MaxCadence
	}
}

func (x *LapMsg) expandComponents() {
	if x.AvgSpeed != 0xFFFF {
		x.EnhancedAvgSpeed = uint32(
			(x.AvgSpeed >> 0) & ((1 << 16) - 1),
		)
	}
	if x.MaxSpeed != 0xFFFF {
		x.EnhancedMaxSpeed = uint32(
			(x.MaxSpeed >> 0) & ((1 << 16) - 1),
		)
	}
	if x.AvgAltitude != 0xFFFF {
		x.EnhancedAvgAltitude = uint32(
			(x.AvgAltitude >> 0) & ((1 << 16) - 1),
		)
	}
	if x.MaxAltitude != 0xFFFF {
		x.EnhancedMaxAltitude = uint32(
			(x.MaxAltitude >> 0) & ((1 << 16) - 1),
		)
	}
	if x.MinAltitude != 0xFFFF {
		x.EnhancedMinAltitude = uint32(
			(x.MinAltitude >> 0) & ((1 << 16) - 1),
		)
	}
}

// LengthMsg represents the length FIT message type.
type LengthMsg struct {
	MessageIndex       MessageIndex
	Timestamp          time.Time
	Event              Event
	EventType          EventType
	StartTime          time.Time
	TotalElapsedTime   uint32
	TotalTimerTime     uint32
	TotalStrokes       uint16
	AvgSpeed           uint16
	SwimStroke         SwimStroke
	AvgSwimmingCadence uint8
	EventGroup         uint8
	TotalCalories      uint16
	LengthType         LengthType
	PlayerScore        uint16
	OpponentScore      uint16
	StrokeCount        []uint16 // stroke_type enum used as the index
	ZoneCount          []uint16 // zone number used as the index
}

// NewLengthMsg returns a length FIT message
// initialized to all-invalid values.
func NewLengthMsg() *LengthMsg {
	return &LengthMsg{
		MessageIndex:       0xFFFF,
		Timestamp:          timeBase,
		Event:              0xFF,
		EventType:          0xFF,
		StartTime:          timeBase,
		TotalElapsedTime:   0xFFFFFFFF,
		TotalTimerTime:     0xFFFFFFFF,
		TotalStrokes:       0xFFFF,
		AvgSpeed:           0xFFFF,
		SwimStroke:         0xFF,
		AvgSwimmingCadence: 0xFF,
		EventGroup:         0xFF,
		TotalCalories:      0xFFFF,
		LengthType:         0xFF,
		PlayerScore:        0xFFFF,
		OpponentScore:      0xFFFF,
		StrokeCount:        nil,
		ZoneCount:          nil,
	}
}

// GetTotalElapsedTimeScaled returns TotalElapsedTime
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: s
func (x *LengthMsg) GetTotalElapsedTimeScaled() float64 {
	if x.TotalElapsedTime == 0xFFFFFFFF {
		return math.NaN()
	}
	return float64(x.TotalElapsedTime) / 1000
}

// GetTotalTimerTimeScaled returns TotalTimerTime
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: s
func (x *LengthMsg) GetTotalTimerTimeScaled() float64 {
	if x.TotalTimerTime == 0xFFFFFFFF {
		return math.NaN()
	}
	return float64(x.TotalTimerTime) / 1000
}

// GetAvgSpeedScaled returns AvgSpeed
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m/s
func (x *LengthMsg) GetAvgSpeedScaled() float64 {
	if x.AvgSpeed == 0xFFFF {
		return math.NaN()
	}
	return float64(x.AvgSpeed) / 1000
}

// RecordMsg represents the record FIT message type.
type RecordMsg struct {
	Timestamp                     time.Time
	PositionLat                   Latitude
	PositionLong                  Longitude
	Altitude                      uint16
	HeartRate                     uint8
	Cadence                       uint8
	Distance                      uint32
	Speed                         uint16
	Power                         uint16
	CompressedSpeedDistance       []byte
	Grade                         int16
	Resistance                    uint8 // Relative. 0 is none  254 is Max.
	TimeFromCourse                int32
	CycleLength                   uint8
	Temperature                   int8
	Speed1s                       []uint8 // Speed at 1s intervals.  Timestamp field indicates time of last array element.
	Cycles                        uint8
	TotalCycles                   uint32
	CompressedAccumulatedPower    uint16
	AccumulatedPower              uint32
	LeftRightBalance              LeftRightBalance
	GpsAccuracy                   uint8
	VerticalSpeed                 int16
	Calories                      uint16
	VerticalOscillation           uint16
	StanceTimePercent             uint16
	StanceTime                    uint16
	ActivityType                  ActivityType
	LeftTorqueEffectiveness       uint8
	RightTorqueEffectiveness      uint8
	LeftPedalSmoothness           uint8
	RightPedalSmoothness          uint8
	CombinedPedalSmoothness       uint8
	Time128                       uint8
	StrokeType                    StrokeType
	Zone                          uint8
	BallSpeed                     uint16
	Cadence256                    uint16 // Log cadence and fractional cadence for backwards compatability
	FractionalCadence             uint8
	TotalHemoglobinConc           uint16 // Total saturated and unsaturated hemoglobin
	TotalHemoglobinConcMin        uint16 // Min saturated and unsaturated hemoglobin
	TotalHemoglobinConcMax        uint16 // Max saturated and unsaturated hemoglobin
	SaturatedHemoglobinPercent    uint16 // Percentage of hemoglobin saturated with oxygen
	SaturatedHemoglobinPercentMin uint16 // Min percentage of hemoglobin saturated with oxygen
	SaturatedHemoglobinPercentMax uint16 // Max percentage of hemoglobin saturated with oxygen
	DeviceIndex                   DeviceIndex
	EnhancedSpeed                 uint32
	EnhancedAltitude              uint32
}

// NewRecordMsg returns a record FIT message
// initialized to all-invalid values.
func NewRecordMsg() *RecordMsg {
	return &RecordMsg{
		Timestamp:    timeBase,
		PositionLat:  NewLatitudeInvalid(),
		PositionLong: NewLongitudeInvalid(),
		Altitude:     0xFFFF,
		HeartRate:    0xFF,
		Cadence:      0xFF,
		Distance:     0xFFFFFFFF,
		Speed:        0xFFFF,
		Power:        0xFFFF,
		CompressedSpeedDistance: nil,
		Grade:                         0x7FFF,
		Resistance:                    0xFF,
		TimeFromCourse:                0x7FFFFFFF,
		CycleLength:                   0xFF,
		Temperature:                   0x7F,
		Speed1s:                       nil,
		Cycles:                        0xFF,
		TotalCycles:                   0xFFFFFFFF,
		CompressedAccumulatedPower:    0xFFFF,
		AccumulatedPower:              0xFFFFFFFF,
		LeftRightBalance:              0xFF,
		GpsAccuracy:                   0xFF,
		VerticalSpeed:                 0x7FFF,
		Calories:                      0xFFFF,
		VerticalOscillation:           0xFFFF,
		StanceTimePercent:             0xFFFF,
		StanceTime:                    0xFFFF,
		ActivityType:                  0xFF,
		LeftTorqueEffectiveness:       0xFF,
		RightTorqueEffectiveness:      0xFF,
		LeftPedalSmoothness:           0xFF,
		RightPedalSmoothness:          0xFF,
		CombinedPedalSmoothness:       0xFF,
		Time128:                       0xFF,
		StrokeType:                    0xFF,
		Zone:                          0xFF,
		BallSpeed:                     0xFFFF,
		Cadence256:                    0xFFFF,
		FractionalCadence:             0xFF,
		TotalHemoglobinConc:           0xFFFF,
		TotalHemoglobinConcMin:        0xFFFF,
		TotalHemoglobinConcMax:        0xFFFF,
		SaturatedHemoglobinPercent:    0xFFFF,
		SaturatedHemoglobinPercentMin: 0xFFFF,
		SaturatedHemoglobinPercentMax: 0xFFFF,
		DeviceIndex:                   0xFF,
		EnhancedSpeed:                 0xFFFFFFFF,
		EnhancedAltitude:              0xFFFFFFFF,
	}
}

// GetAltitudeScaled returns Altitude
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m
func (x *RecordMsg) GetAltitudeScaled() float64 {
	if x.Altitude == 0xFFFF {
		return math.NaN()
	}
	return float64(x.Altitude)/5 - 500
}

// GetDistanceScaled returns Distance
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m
func (x *RecordMsg) GetDistanceScaled() float64 {
	if x.Distance == 0xFFFFFFFF {
		return math.NaN()
	}
	return float64(x.Distance) / 100
}

// GetSpeedScaled returns Speed
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m/s
func (x *RecordMsg) GetSpeedScaled() float64 {
	if x.Speed == 0xFFFF {
		return math.NaN()
	}
	return float64(x.Speed) / 1000
}

// GetGradeScaled returns Grade
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: %
func (x *RecordMsg) GetGradeScaled() float64 {
	if x.Grade == 0x7FFF {
		return math.NaN()
	}
	return float64(x.Grade) / 100
}

// GetTimeFromCourseScaled returns TimeFromCourse
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: s
func (x *RecordMsg) GetTimeFromCourseScaled() float64 {
	if x.TimeFromCourse == 0x7FFFFFFF {
		return math.NaN()
	}
	return float64(x.TimeFromCourse) / 1000
}

// GetCycleLengthScaled returns CycleLength
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m
func (x *RecordMsg) GetCycleLengthScaled() float64 {
	if x.CycleLength == 0xFF {
		return math.NaN()
	}
	return float64(x.CycleLength) / 100
}

// GetSpeed1sScaled returns Speed1s
// as a slice with scale and any offset applied to every element.
// Units: m/s
func (x *RecordMsg) GetSpeed1sScaled() []float64 {
	if len(x.Speed1s) == 0 {
		return nil
	}
	s := make([]float64, len(x.Speed1s))
	for i, v := range x.Speed1s {
		s[i] = float64(v) / 16
	}
	return s
}

// GetVerticalSpeedScaled returns VerticalSpeed
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m/s
func (x *RecordMsg) GetVerticalSpeedScaled() float64 {
	if x.VerticalSpeed == 0x7FFF {
		return math.NaN()
	}
	return float64(x.VerticalSpeed) / 1000
}

// GetVerticalOscillationScaled returns VerticalOscillation
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: mm
func (x *RecordMsg) GetVerticalOscillationScaled() float64 {
	if x.VerticalOscillation == 0xFFFF {
		return math.NaN()
	}
	return float64(x.VerticalOscillation) / 10
}

// GetStanceTimePercentScaled returns StanceTimePercent
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: percent
func (x *RecordMsg) GetStanceTimePercentScaled() float64 {
	if x.StanceTimePercent == 0xFFFF {
		return math.NaN()
	}
	return float64(x.StanceTimePercent) / 100
}

// GetStanceTimeScaled returns StanceTime
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: ms
func (x *RecordMsg) GetStanceTimeScaled() float64 {
	if x.StanceTime == 0xFFFF {
		return math.NaN()
	}
	return float64(x.StanceTime) / 10
}

// GetLeftTorqueEffectivenessScaled returns LeftTorqueEffectiveness
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: percent
func (x *RecordMsg) GetLeftTorqueEffectivenessScaled() float64 {
	if x.LeftTorqueEffectiveness == 0xFF {
		return math.NaN()
	}
	return float64(x.LeftTorqueEffectiveness) / 2
}

// GetRightTorqueEffectivenessScaled returns RightTorqueEffectiveness
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: percent
func (x *RecordMsg) GetRightTorqueEffectivenessScaled() float64 {
	if x.RightTorqueEffectiveness == 0xFF {
		return math.NaN()
	}
	return float64(x.RightTorqueEffectiveness) / 2
}

// GetLeftPedalSmoothnessScaled returns LeftPedalSmoothness
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: percent
func (x *RecordMsg) GetLeftPedalSmoothnessScaled() float64 {
	if x.LeftPedalSmoothness == 0xFF {
		return math.NaN()
	}
	return float64(x.LeftPedalSmoothness) / 2
}

// GetRightPedalSmoothnessScaled returns RightPedalSmoothness
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: percent
func (x *RecordMsg) GetRightPedalSmoothnessScaled() float64 {
	if x.RightPedalSmoothness == 0xFF {
		return math.NaN()
	}
	return float64(x.RightPedalSmoothness) / 2
}

// GetCombinedPedalSmoothnessScaled returns CombinedPedalSmoothness
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: percent
func (x *RecordMsg) GetCombinedPedalSmoothnessScaled() float64 {
	if x.CombinedPedalSmoothness == 0xFF {
		return math.NaN()
	}
	return float64(x.CombinedPedalSmoothness) / 2
}

// GetTime128Scaled returns Time128
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: s
func (x *RecordMsg) GetTime128Scaled() float64 {
	if x.Time128 == 0xFF {
		return math.NaN()
	}
	return float64(x.Time128) / 128
}

// GetBallSpeedScaled returns BallSpeed
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m/s
func (x *RecordMsg) GetBallSpeedScaled() float64 {
	if x.BallSpeed == 0xFFFF {
		return math.NaN()
	}
	return float64(x.BallSpeed) / 100
}

// GetCadence256Scaled returns Cadence256
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: rpm
func (x *RecordMsg) GetCadence256Scaled() float64 {
	if x.Cadence256 == 0xFFFF {
		return math.NaN()
	}
	return float64(x.Cadence256) / 256
}

// GetFractionalCadenceScaled returns FractionalCadence
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: rpm
func (x *RecordMsg) GetFractionalCadenceScaled() float64 {
	if x.FractionalCadence == 0xFF {
		return math.NaN()
	}
	return float64(x.FractionalCadence) / 128
}

// GetTotalHemoglobinConcScaled returns TotalHemoglobinConc
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: g/dL
func (x *RecordMsg) GetTotalHemoglobinConcScaled() float64 {
	if x.TotalHemoglobinConc == 0xFFFF {
		return math.NaN()
	}
	return float64(x.TotalHemoglobinConc) / 100
}

// GetTotalHemoglobinConcMinScaled returns TotalHemoglobinConcMin
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: g/dL
func (x *RecordMsg) GetTotalHemoglobinConcMinScaled() float64 {
	if x.TotalHemoglobinConcMin == 0xFFFF {
		return math.NaN()
	}
	return float64(x.TotalHemoglobinConcMin) / 100
}

// GetTotalHemoglobinConcMaxScaled returns TotalHemoglobinConcMax
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: g/dL
func (x *RecordMsg) GetTotalHemoglobinConcMaxScaled() float64 {
	if x.TotalHemoglobinConcMax == 0xFFFF {
		return math.NaN()
	}
	return float64(x.TotalHemoglobinConcMax) / 100
}

// GetSaturatedHemoglobinPercentScaled returns SaturatedHemoglobinPercent
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: %
func (x *RecordMsg) GetSaturatedHemoglobinPercentScaled() float64 {
	if x.SaturatedHemoglobinPercent == 0xFFFF {
		return math.NaN()
	}
	return float64(x.SaturatedHemoglobinPercent) / 10
}

// GetSaturatedHemoglobinPercentMinScaled returns SaturatedHemoglobinPercentMin
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: %
func (x *RecordMsg) GetSaturatedHemoglobinPercentMinScaled() float64 {
	if x.SaturatedHemoglobinPercentMin == 0xFFFF {
		return math.NaN()
	}
	return float64(x.SaturatedHemoglobinPercentMin) / 10
}

// GetSaturatedHemoglobinPercentMaxScaled returns SaturatedHemoglobinPercentMax
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: %
func (x *RecordMsg) GetSaturatedHemoglobinPercentMaxScaled() float64 {
	if x.SaturatedHemoglobinPercentMax == 0xFFFF {
		return math.NaN()
	}
	return float64(x.SaturatedHemoglobinPercentMax) / 10
}

// GetEnhancedSpeedScaled returns EnhancedSpeed
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m/s
func (x *RecordMsg) GetEnhancedSpeedScaled() float64 {
	if x.EnhancedSpeed == 0xFFFFFFFF {
		return math.NaN()
	}
	return float64(x.EnhancedSpeed) / 1000
}

// GetEnhancedAltitudeScaled returns EnhancedAltitude
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m
func (x *RecordMsg) GetEnhancedAltitudeScaled() float64 {
	if x.EnhancedAltitude == 0xFFFFFFFF {
		return math.NaN()
	}
	return float64(x.EnhancedAltitude)/5 - 500
}

// GetSpeedFromCompressedSpeedDistance returns
// Speed with the scale and offset defined by the "Speed"
// component in the CompressedSpeedDistance field. NaN is
// if the field has an invalid value (i.e. has not been set).
func (x *RecordMsg) GetSpeedFromCompressedSpeedDistance() float64 {
	if x.Speed == 0xFFFF {
		return math.NaN()
	}
	return float64(x.Speed) / 100
}

// GetDistanceFromCompressedSpeedDistance returns
// Distance with the scale and offset defined by the "Distance"
// component in the CompressedSpeedDistance field. NaN is
// if the field has an invalid value (i.e. has not been set).
func (x *RecordMsg) GetDistanceFromCompressedSpeedDistance() float64 {
	if x.Distance == 0xFFFFFFFF {
		return math.NaN()
	}
	return float64(x.Distance) / 16
}

func (x *RecordMsg) expandComponents() {
	if x.Altitude != 0xFFFF {
		x.EnhancedAltitude = uint32(
			(x.Altitude >> 0) & ((1 << 16) - 1),
		)
	}
	if x.Speed != 0xFFFF {
		x.EnhancedSpeed = uint32(
			(x.Speed >> 0) & ((1 << 16) - 1),
		)
	}
	expand := false
	if len(x.CompressedSpeedDistance) == 3 {
		for _, v := range x.CompressedSpeedDistance {
			if v != 0xFF {
				expand = true
				break
			}
		}
	}
	if expand {
		x.Speed = uint16(x.CompressedSpeedDistance[0]) | uint16(x.CompressedSpeedDistance[1]&0x0F)<<8
		if accumuDistance == nil {
			accumuDistance = uint32NewAccumulator(12)
		}
		x.Distance = accumuDistance.accumulate(
			uint32(x.CompressedSpeedDistance[1]>>4) | uint32(x.CompressedSpeedDistance[2]<<4),
		)
	}
	if x.Cycles != 0xFF {
		if accumuTotalCycles == nil {
			accumuTotalCycles = new(uint32Accumulator)
		}
		x.TotalCycles = accumuTotalCycles.accumulate(
			uint32(
				(x.Cycles >> 0) & ((1 << 8) - 1),
			),
		)
	}
	if x.CompressedAccumulatedPower != 0xFFFF {
		if accumuAccumulatedPower == nil {
			accumuAccumulatedPower = new(uint32Accumulator)
		}
		x.AccumulatedPower = accumuAccumulatedPower.accumulate(
			uint32(
				(x.CompressedAccumulatedPower >> 0) & ((1 << 16) - 1),
			),
		)
	}
}

// EventMsg represents the event FIT message type.
type EventMsg struct {
	Timestamp     time.Time
	Event         Event
	EventType     EventType
	Data16        uint16
	Data          uint32
	EventGroup    uint8
	Score         uint16 // Do not populate directly.  Autogenerated by decoder for sport_point subfield components
	OpponentScore uint16 // Do not populate directly.  Autogenerated by decoder for sport_point subfield components
	FrontGearNum  uint8  // Do not populate directly.  Autogenerated by decoder for gear_change subfield components.  Front gear number. 1 is innermost.
	FrontGear     uint8  // Do not populate directly.  Autogenerated by decoder for gear_change subfield components.  Number of front teeth.
	RearGearNum   uint8  // Do not populate directly.  Autogenerated by decoder for gear_change subfield components.  Rear gear number. 1 is innermost.
	RearGear      uint8  // Do not populate directly.  Autogenerated by decoder for gear_change subfield components.  Number of rear teeth.
}

// NewEventMsg returns a event FIT message
// initialized to all-invalid values.
func NewEventMsg() *EventMsg {
	return &EventMsg{
		Timestamp:     timeBase,
		Event:         0xFF,
		EventType:     0xFF,
		Data16:        0xFFFF,
		Data:          0xFFFFFFFF,
		EventGroup:    0xFF,
		Score:         0xFFFF,
		OpponentScore: 0xFFFF,
		FrontGearNum:  0x00,
		FrontGear:     0x00,
		RearGearNum:   0x00,
		RearGear:      0x00,
	}
}

// GetData returns the appropriate Data
// subfield if a matching reference field/value combination is found.
// If none of the reference field/value combinations are true
// then the main field is returned.
func (x *EventMsg) GetData() interface{} {
	switch x.Event {
	case EventTimer:
		return TimerTrigger(x.Data)
	case EventCoursePoint:
		return MessageIndex(x.Data)
	case EventBattery:
		return float64(x.Data) / 1000
	case EventVirtualPartnerPace:
		return float64(x.Data) / 1000
	case EventHrHighAlert:
		return uint8(x.Data)
	case EventHrLowAlert:
		return uint8(x.Data)
	case EventSpeedHighAlert:
		return float64(x.Data) / 1000
	case EventSpeedLowAlert:
		return float64(x.Data) / 1000
	case EventCadHighAlert:
		return uint16(x.Data)
	case EventCadLowAlert:
		return uint16(x.Data)
	case EventPowerHighAlert:
		return uint16(x.Data)
	case EventPowerLowAlert:
		return uint16(x.Data)
	case EventTimeDurationAlert:
		return float64(x.Data) / 1000
	case EventDistanceDurationAlert:
		return float64(x.Data) / 100
	case EventCalorieDurationAlert:
		return uint32(x.Data)
	case EventFitnessEquipment:
		return FitnessEquipmentState(x.Data)
	case EventSportPoint:
		return uint32(x.Data)
	case EventFrontGearChange, EventRearGearChange:
		return uint32(x.Data)
	default:
		return x.Data
	}
}

func (x *EventMsg) expandComponents() {
	if x.Data16 != 0xFFFF {
		x.Data = uint32(
			(x.Data16 >> 0) & ((1 << 16) - 1),
		)
	}
	if x.Data != 0xFFFFFFFF {
		switch x.Event {
		case EventSportPoint:
			x.Score = uint16(
				(x.Data >> 0) & ((1 << 16) - 1),
			)
			x.OpponentScore = uint16(
				(x.Data >> 16) & ((1 << 16) - 1),
			)
		case EventFrontGearChange, EventRearGearChange:
			x.RearGearNum = uint8(
				(x.Data >> 0) & ((1 << 8) - 1),
			)
			x.RearGear = uint8(
				(x.Data >> 8) & ((1 << 8) - 1),
			)
			x.FrontGearNum = uint8(
				(x.Data >> 16) & ((1 << 8) - 1),
			)
			x.FrontGear = uint8(
				(x.Data >> 24) & ((1 << 8) - 1),
			)
		}
	}
}

// DeviceInfoMsg represents the device_info FIT message type.
type DeviceInfoMsg struct {
	Timestamp           time.Time
	DeviceIndex         DeviceIndex
	DeviceType          uint8
	Manufacturer        Manufacturer
	SerialNumber        uint32
	Product             uint16
	SoftwareVersion     uint16
	HardwareVersion     uint8
	CumOperatingTime    uint32 // Reset by new battery or charge.
	BatteryVoltage      uint16
	BatteryStatus       BatteryStatus
	SensorPosition      BodyLocation // Indicates the location of the sensor
	Descriptor          string       // Used to describe the sensor or location
	AntTransmissionType uint8
	AntDeviceNumber     uint16
	AntNetwork          AntNetwork
	SourceType          SourceType
	ProductName         string // Optional free form string to indicate the devices name or model
}

// NewDeviceInfoMsg returns a device_info FIT message
// initialized to all-invalid values.
func NewDeviceInfoMsg() *DeviceInfoMsg {
	return &DeviceInfoMsg{
		Timestamp:           timeBase,
		DeviceIndex:         0xFF,
		DeviceType:          0xFF,
		Manufacturer:        0xFFFF,
		SerialNumber:        0x00000000,
		Product:             0xFFFF,
		SoftwareVersion:     0xFFFF,
		HardwareVersion:     0xFF,
		CumOperatingTime:    0xFFFFFFFF,
		BatteryVoltage:      0xFFFF,
		BatteryStatus:       0xFF,
		SensorPosition:      0xFF,
		Descriptor:          "",
		AntTransmissionType: 0x00,
		AntDeviceNumber:     0x0000,
		AntNetwork:          0xFF,
		SourceType:          0xFF,
		ProductName:         "",
	}
}

// GetSoftwareVersionScaled returns SoftwareVersion
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
func (x *DeviceInfoMsg) GetSoftwareVersionScaled() float64 {
	if x.SoftwareVersion == 0xFFFF {
		return math.NaN()
	}
	return float64(x.SoftwareVersion) / 100
}

// GetBatteryVoltageScaled returns BatteryVoltage
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: V
func (x *DeviceInfoMsg) GetBatteryVoltageScaled() float64 {
	if x.BatteryVoltage == 0xFFFF {
		return math.NaN()
	}
	return float64(x.BatteryVoltage) / 256
}

// GetDeviceType returns the appropriate DeviceType
// subfield if a matching reference field/value combination is found.
// If none of the reference field/value combinations are true
// then the main field is returned.
func (x *DeviceInfoMsg) GetDeviceType() interface{} {
	switch x.SourceType {
	case SourceTypeAntplus:
		return AntplusDeviceType(x.DeviceType)
	case SourceTypeAnt:
		return uint8(x.DeviceType)
	default:
		return x.DeviceType
	}
}

// GetProduct returns the appropriate Product
// subfield if a matching reference field/value combination is found.
// If none of the reference field/value combinations are true
// then the main field is returned.
func (x *DeviceInfoMsg) GetProduct() interface{} {
	switch x.Manufacturer {
	case ManufacturerGarmin, ManufacturerDynastream, ManufacturerDynastreamOem:
		return GarminProduct(x.Product)
	default:
		return x.Product
	}
}

// TrainingFileMsg represents the training_file FIT message type.
type TrainingFileMsg struct {
	Timestamp    time.Time
	Type         FileType
	Manufacturer Manufacturer
	Product      uint16
	SerialNumber uint32
	TimeCreated  time.Time
}

// NewTrainingFileMsg returns a training_file FIT message
// initialized to all-invalid values.
func NewTrainingFileMsg() *TrainingFileMsg {
	return &TrainingFileMsg{
		Timestamp:    timeBase,
		Type:         0xFF,
		Manufacturer: 0xFFFF,
		Product:      0xFFFF,
		SerialNumber: 0x00000000,
		TimeCreated:  timeBase,
	}
}

// GetProduct returns the appropriate Product
// subfield if a matching reference field/value combination is found.
// If none of the reference field/value combinations are true
// then the main field is returned.
func (x *TrainingFileMsg) GetProduct() interface{} {
	switch x.Manufacturer {
	case ManufacturerGarmin, ManufacturerDynastream, ManufacturerDynastreamOem:
		return GarminProduct(x.Product)
	default:
		return x.Product
	}
}

// HrvMsg represents the hrv FIT message type.
type HrvMsg struct {
	Time []uint16 // Time between beats
}

// NewHrvMsg returns a hrv FIT message
// initialized to all-invalid values.
func NewHrvMsg() *HrvMsg {
	return &HrvMsg{
		Time: nil,
	}
}

// GetTimeScaled returns Time
// as a slice with scale and any offset applied to every element.
// Units: s
func (x *HrvMsg) GetTimeScaled() []float64 {
	if len(x.Time) == 0 {
		return nil
	}
	s := make([]float64, len(x.Time))
	for i, v := range x.Time {
		s[i] = float64(v) / 1000
	}
	return s
}

// WeatherConditionsMsg represents the weather_conditions FIT message type.
type WeatherConditionsMsg struct {
	Timestamp                time.Time     // time of update for current conditions, else forecast time
	WeatherReport            WeatherReport // Current or forecast
	Temperature              int8
	Condition                WeatherStatus // Corresponds to GSC Response weatherIcon field
	WindDirection            uint16
	WindSpeed                uint16
	PrecipitationProbability uint8 // range 0-100
	TemperatureFeelsLike     int8  // Heat Index if  GCS heatIdx above or equal to 90F or wind chill if GCS windChill below or equal to 32F
	RelativeHumidity         uint8
	Location                 string // string corresponding to GCS response location string
	ObservedAtTime           time.Time
	ObservedLocationLat      Latitude
	ObservedLocationLong     Longitude
	DayOfWeek                DayOfWeek
	HighTemperature          int8
	LowTemperature           int8
}

// NewWeatherConditionsMsg returns a weather_conditions FIT message
// initialized to all-invalid values.
func NewWeatherConditionsMsg() *WeatherConditionsMsg {
	return &WeatherConditionsMsg{
		Timestamp:                timeBase,
		WeatherReport:            0xFF,
		Temperature:              0x7F,
		Condition:                0xFF,
		WindDirection:            0xFFFF,
		WindSpeed:                0xFFFF,
		PrecipitationProbability: 0xFF,
		TemperatureFeelsLike:     0x7F,
		RelativeHumidity:         0xFF,
		Location:                 "",
		ObservedAtTime:           timeBase,
		ObservedLocationLat:      NewLatitudeInvalid(),
		ObservedLocationLong:     NewLongitudeInvalid(),
		DayOfWeek:                0xFF,
		HighTemperature:          0x7F,
		LowTemperature:           0x7F,
	}
}

// GetWindSpeedScaled returns WindSpeed
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m/s
func (x *WeatherConditionsMsg) GetWindSpeedScaled() float64 {
	if x.WindSpeed == 0xFFFF {
		return math.NaN()
	}
	return float64(x.WindSpeed) / 1000
}

// WeatherAlertMsg represents the weather_alert FIT message type.
type WeatherAlertMsg struct {
	Timestamp  time.Time
	ReportId   string            // Unique identifier from GCS report ID string, length is 12
	IssueTime  time.Time         // Time alert was issued
	ExpireTime time.Time         // Time alert expires
	Severity   WeatherSeverity   // Warning, Watch, Advisory, Statement
	Type       WeatherSevereType // Tornado, Severe Thunderstorm, etc.
}

// NewWeatherAlertMsg returns a weather_alert FIT message
// initialized to all-invalid values.
func NewWeatherAlertMsg() *WeatherAlertMsg {
	return &WeatherAlertMsg{
		Timestamp:  timeBase,
		ReportId:   "",
		IssueTime:  timeBase,
		ExpireTime: timeBase,
		Severity:   0xFF,
		Type:       0xFF,
	}
}

// GpsMetadataMsg represents the gps_metadata FIT message type.
type GpsMetadataMsg struct {
}

// NewGpsMetadataMsg returns a gps_metadata FIT message
// initialized to all-invalid values.
func NewGpsMetadataMsg() *GpsMetadataMsg {
	return &GpsMetadataMsg{}
}

// CameraEventMsg represents the camera_event FIT message type.
type CameraEventMsg struct {
}

// NewCameraEventMsg returns a camera_event FIT message
// initialized to all-invalid values.
func NewCameraEventMsg() *CameraEventMsg {
	return &CameraEventMsg{}
}

// GyroscopeDataMsg represents the gyroscope_data FIT message type.
type GyroscopeDataMsg struct {
}

// NewGyroscopeDataMsg returns a gyroscope_data FIT message
// initialized to all-invalid values.
func NewGyroscopeDataMsg() *GyroscopeDataMsg {
	return &GyroscopeDataMsg{}
}

// AccelerometerDataMsg represents the accelerometer_data FIT message type.
type AccelerometerDataMsg struct {
}

// NewAccelerometerDataMsg returns a accelerometer_data FIT message
// initialized to all-invalid values.
func NewAccelerometerDataMsg() *AccelerometerDataMsg {
	return &AccelerometerDataMsg{}
}

// MagnetometerDataMsg represents the magnetometer_data FIT message type.
type MagnetometerDataMsg struct {
}

// NewMagnetometerDataMsg returns a magnetometer_data FIT message
// initialized to all-invalid values.
func NewMagnetometerDataMsg() *MagnetometerDataMsg {
	return &MagnetometerDataMsg{}
}

// ThreeDSensorCalibrationMsg represents the three_d_sensor_calibration FIT message type.
type ThreeDSensorCalibrationMsg struct {
}

// NewThreeDSensorCalibrationMsg returns a three_d_sensor_calibration FIT message
// initialized to all-invalid values.
func NewThreeDSensorCalibrationMsg() *ThreeDSensorCalibrationMsg {
	return &ThreeDSensorCalibrationMsg{}
}

// VideoFrameMsg represents the video_frame FIT message type.
type VideoFrameMsg struct {
}

// NewVideoFrameMsg returns a video_frame FIT message
// initialized to all-invalid values.
func NewVideoFrameMsg() *VideoFrameMsg {
	return &VideoFrameMsg{}
}

// ObdiiDataMsg represents the obdii_data FIT message type.
type ObdiiDataMsg struct {
}

// NewObdiiDataMsg returns a obdii_data FIT message
// initialized to all-invalid values.
func NewObdiiDataMsg() *ObdiiDataMsg {
	return &ObdiiDataMsg{}
}

// NmeaSentenceMsg represents the nmea_sentence FIT message type.
type NmeaSentenceMsg struct {
	Timestamp   time.Time // Timestamp message was output
	TimestampMs uint16    // Fractional part of timestamp, added to timestamp
	Sentence    string    // NMEA sentence
}

// NewNmeaSentenceMsg returns a nmea_sentence FIT message
// initialized to all-invalid values.
func NewNmeaSentenceMsg() *NmeaSentenceMsg {
	return &NmeaSentenceMsg{
		Timestamp:   timeBase,
		TimestampMs: 0xFFFF,
		Sentence:    "",
	}
}

// AviationAttitudeMsg represents the aviation_attitude FIT message type.
type AviationAttitudeMsg struct {
	Timestamp             time.Time // Timestamp message was output
	TimestampMs           uint16    // Fractional part of timestamp, added to timestamp
	SystemTime            []uint32  // System time associated with sample expressed in ms.
	Pitch                 []int16   // Range -PI/2 to +PI/2
	Roll                  []int16   // Range -PI to +PI
	AccelLateral          []int16   // Range -78.4 to +78.4 (-8 Gs to 8 Gs)
	AccelNormal           []int16   // Range -78.4 to +78.4 (-8 Gs to 8 Gs)
	TurnRate              []int16   // Range -8.727 to +8.727 (-500 degs/sec to +500 degs/sec)
	Stage                 []AttitudeStage
	AttitudeStageComplete []uint8  // The percent complete of the current attitude stage.  Set to 0 for attitude stages 0, 1 and 2 and to 100 for attitude stage 3 by AHRS modules that do not support it.  Range - 100
	Track                 []uint16 // Track Angle/Heading Range 0 - 2pi
	Validity              []AttitudeValidity
}

// NewAviationAttitudeMsg returns a aviation_attitude FIT message
// initialized to all-invalid values.
func NewAviationAttitudeMsg() *AviationAttitudeMsg {
	return &AviationAttitudeMsg{
		Timestamp:    timeBase,
		TimestampMs:  0xFFFF,
		SystemTime:   nil,
		Pitch:        nil,
		Roll:         nil,
		AccelLateral: nil,
		AccelNormal:  nil,
		TurnRate:     nil,
		Stage:        nil,
		AttitudeStageComplete: nil,
		Track:    nil,
		Validity: nil,
	}
}

// GetPitchScaled returns Pitch
// as a slice with scale and any offset applied to every element.
// Units: radians
func (x *AviationAttitudeMsg) GetPitchScaled() []float64 {
	if len(x.Pitch) == 0 {
		return nil
	}
	s := make([]float64, len(x.Pitch))
	for i, v := range x.Pitch {
		s[i] = float64(v) / 10430.38
	}
	return s
}

// GetRollScaled returns Roll
// as a slice with scale and any offset applied to every element.
// Units: radians
func (x *AviationAttitudeMsg) GetRollScaled() []float64 {
	if len(x.Roll) == 0 {
		return nil
	}
	s := make([]float64, len(x.Roll))
	for i, v := range x.Roll {
		s[i] = float64(v) / 10430.38
	}
	return s
}

// GetAccelLateralScaled returns AccelLateral
// as a slice with scale and any offset applied to every element.
// Units: m/s^2
func (x *AviationAttitudeMsg) GetAccelLateralScaled() []float64 {
	if len(x.AccelLateral) == 0 {
		return nil
	}
	s := make([]float64, len(x.AccelLateral))
	for i, v := range x.AccelLateral {
		s[i] = float64(v) / 100
	}
	return s
}

// GetAccelNormalScaled returns AccelNormal
// as a slice with scale and any offset applied to every element.
// Units: m/s^2
func (x *AviationAttitudeMsg) GetAccelNormalScaled() []float64 {
	if len(x.AccelNormal) == 0 {
		return nil
	}
	s := make([]float64, len(x.AccelNormal))
	for i, v := range x.AccelNormal {
		s[i] = float64(v) / 100
	}
	return s
}

// GetTurnRateScaled returns TurnRate
// as a slice with scale and any offset applied to every element.
// Units: radians/second
func (x *AviationAttitudeMsg) GetTurnRateScaled() []float64 {
	if len(x.TurnRate) == 0 {
		return nil
	}
	s := make([]float64, len(x.TurnRate))
	for i, v := range x.TurnRate {
		s[i] = float64(v) / 1024
	}
	return s
}

// GetTrackScaled returns Track
// as a slice with scale and any offset applied to every element.
// Units: radians
func (x *AviationAttitudeMsg) GetTrackScaled() []float64 {
	if len(x.Track) == 0 {
		return nil
	}
	s := make([]float64, len(x.Track))
	for i, v := range x.Track {
		s[i] = float64(v) / 10430.38
	}
	return s
}

// VideoMsg represents the video FIT message type.
type VideoMsg struct {
}

// NewVideoMsg returns a video FIT message
// initialized to all-invalid values.
func NewVideoMsg() *VideoMsg {
	return &VideoMsg{}
}

// VideoTitleMsg represents the video_title FIT message type.
type VideoTitleMsg struct {
	MessageIndex MessageIndex // Long titles will be split into multiple parts
	MessageCount uint16       // Total number of title parts
	Text         string
}

// NewVideoTitleMsg returns a video_title FIT message
// initialized to all-invalid values.
func NewVideoTitleMsg() *VideoTitleMsg {
	return &VideoTitleMsg{
		MessageIndex: 0xFFFF,
		MessageCount: 0xFFFF,
		Text:         "",
	}
}

// VideoDescriptionMsg represents the video_description FIT message type.
type VideoDescriptionMsg struct {
	MessageIndex MessageIndex // Long descriptions will be split into multiple parts
	MessageCount uint16       // Total number of description parts
	Text         string
}

// NewVideoDescriptionMsg returns a video_description FIT message
// initialized to all-invalid values.
func NewVideoDescriptionMsg() *VideoDescriptionMsg {
	return &VideoDescriptionMsg{
		MessageIndex: 0xFFFF,
		MessageCount: 0xFFFF,
		Text:         "",
	}
}

// VideoClipMsg represents the video_clip FIT message type.
type VideoClipMsg struct {
}

// NewVideoClipMsg returns a video_clip FIT message
// initialized to all-invalid values.
func NewVideoClipMsg() *VideoClipMsg {
	return &VideoClipMsg{}
}

// CourseMsg represents the course FIT message type.
type CourseMsg struct {
	Sport        Sport
	Name         string
	Capabilities CourseCapabilities
	SubSport     SubSport
}

// NewCourseMsg returns a course FIT message
// initialized to all-invalid values.
func NewCourseMsg() *CourseMsg {
	return &CourseMsg{
		Sport:        0xFF,
		Name:         "",
		Capabilities: 0x00000000,
		SubSport:     0xFF,
	}
}

// CoursePointMsg represents the course_point FIT message type.
type CoursePointMsg struct {
	MessageIndex MessageIndex
	Timestamp    time.Time
	PositionLat  Latitude
	PositionLong Longitude
	Distance     uint32
	Type         CoursePoint
	Name         string
	Favorite     Bool
}

// NewCoursePointMsg returns a course_point FIT message
// initialized to all-invalid values.
func NewCoursePointMsg() *CoursePointMsg {
	return &CoursePointMsg{
		MessageIndex: 0xFFFF,
		Timestamp:    timeBase,
		PositionLat:  NewLatitudeInvalid(),
		PositionLong: NewLongitudeInvalid(),
		Distance:     0xFFFFFFFF,
		Type:         0xFF,
		Name:         "",
		Favorite:     0xFF,
	}
}

// GetDistanceScaled returns Distance
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m
func (x *CoursePointMsg) GetDistanceScaled() float64 {
	if x.Distance == 0xFFFFFFFF {
		return math.NaN()
	}
	return float64(x.Distance) / 100
}

// SegmentIdMsg represents the segment_id FIT message type.
type SegmentIdMsg struct {
	Name                  string               // Friendly name assigned to segment
	Uuid                  string               // UUID of the segment
	Sport                 Sport                // Sport associated with the segment
	Enabled               Bool                 // Segment enabled for evaluation
	UserProfilePrimaryKey uint32               // Primary key of the user that created the segment
	DeviceId              uint32               // ID of the device that created the segment
	DefaultRaceLeader     uint8                // Index for the Leader Board entry selected as the default race participant
	DeleteStatus          SegmentDeleteStatus  // Indicates if any segments should be deleted
	SelectionType         SegmentSelectionType // Indicates how the segment was selected to be sent to the device
}

// NewSegmentIdMsg returns a segment_id FIT message
// initialized to all-invalid values.
func NewSegmentIdMsg() *SegmentIdMsg {
	return &SegmentIdMsg{
		Name:                  "",
		Uuid:                  "",
		Sport:                 0xFF,
		Enabled:               0xFF,
		UserProfilePrimaryKey: 0xFFFFFFFF,
		DeviceId:              0xFFFFFFFF,
		DefaultRaceLeader:     0xFF,
		DeleteStatus:          0xFF,
		SelectionType:         0xFF,
	}
}

// SegmentLeaderboardEntryMsg represents the segment_leaderboard_entry FIT message type.
type SegmentLeaderboardEntryMsg struct {
	MessageIndex    MessageIndex
	Name            string                 // Friendly name assigned to leader
	Type            SegmentLeaderboardType // Leader classification
	GroupPrimaryKey uint32                 // Primary user ID of this leader
	ActivityId      uint32                 // ID of the activity associated with this leader time
	SegmentTime     uint32                 // Segment Time (includes pauses)
}

// NewSegmentLeaderboardEntryMsg returns a segment_leaderboard_entry FIT message
// initialized to all-invalid values.
func NewSegmentLeaderboardEntryMsg() *SegmentLeaderboardEntryMsg {
	return &SegmentLeaderboardEntryMsg{
		MessageIndex:    0xFFFF,
		Name:            "",
		Type:            0xFF,
		GroupPrimaryKey: 0xFFFFFFFF,
		ActivityId:      0xFFFFFFFF,
		SegmentTime:     0xFFFFFFFF,
	}
}

// GetSegmentTimeScaled returns SegmentTime
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: s
func (x *SegmentLeaderboardEntryMsg) GetSegmentTimeScaled() float64 {
	if x.SegmentTime == 0xFFFFFFFF {
		return math.NaN()
	}
	return float64(x.SegmentTime) / 1000
}

// SegmentPointMsg represents the segment_point FIT message type.
type SegmentPointMsg struct {
	MessageIndex MessageIndex
	PositionLat  Latitude
	PositionLong Longitude
	Distance     uint32   // Accumulated distance along the segment at the described point
	Altitude     uint16   // Accumulated altitude along the segment at the described point
	LeaderTime   []uint32 // Accumualted time each leader board member required to reach the described point. This value is zero for all leader board members at the starting point of the segment.
}

// NewSegmentPointMsg returns a segment_point FIT message
// initialized to all-invalid values.
func NewSegmentPointMsg() *SegmentPointMsg {
	return &SegmentPointMsg{
		MessageIndex: 0xFFFF,
		PositionLat:  NewLatitudeInvalid(),
		PositionLong: NewLongitudeInvalid(),
		Distance:     0xFFFFFFFF,
		Altitude:     0xFFFF,
		LeaderTime:   nil,
	}
}

// GetDistanceScaled returns Distance
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m
func (x *SegmentPointMsg) GetDistanceScaled() float64 {
	if x.Distance == 0xFFFFFFFF {
		return math.NaN()
	}
	return float64(x.Distance) / 100
}

// GetAltitudeScaled returns Altitude
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m
func (x *SegmentPointMsg) GetAltitudeScaled() float64 {
	if x.Altitude == 0xFFFF {
		return math.NaN()
	}
	return float64(x.Altitude)/5 - 500
}

// GetLeaderTimeScaled returns LeaderTime
// as a slice with scale and any offset applied to every element.
// Units: s
func (x *SegmentPointMsg) GetLeaderTimeScaled() []float64 {
	if len(x.LeaderTime) == 0 {
		return nil
	}
	s := make([]float64, len(x.LeaderTime))
	for i, v := range x.LeaderTime {
		s[i] = float64(v) / 1000
	}
	return s
}

// SegmentLapMsg represents the segment_lap FIT message type.
type SegmentLapMsg struct {
	MessageIndex                MessageIndex
	Timestamp                   time.Time // Lap end time.
	Event                       Event
	EventType                   EventType
	StartTime                   time.Time
	StartPositionLat            Latitude
	StartPositionLong           Longitude
	EndPositionLat              Latitude
	EndPositionLong             Longitude
	TotalElapsedTime            uint32 // Time (includes pauses)
	TotalTimerTime              uint32 // Timer Time (excludes pauses)
	TotalDistance               uint32
	TotalCycles                 uint32
	TotalCalories               uint16
	TotalFatCalories            uint16 // If New Leaf
	AvgSpeed                    uint16
	MaxSpeed                    uint16
	AvgHeartRate                uint8
	MaxHeartRate                uint8
	AvgCadence                  uint8 // total_cycles / total_timer_time if non_zero_avg_cadence otherwise total_cycles / total_elapsed_time
	MaxCadence                  uint8
	AvgPower                    uint16 // total_power / total_timer_time if non_zero_avg_power otherwise total_power / total_elapsed_time
	MaxPower                    uint16
	TotalAscent                 uint16
	TotalDescent                uint16
	Sport                       Sport
	EventGroup                  uint8
	NecLat                      Latitude  // North east corner latitude.
	NecLong                     Longitude // North east corner longitude.
	SwcLat                      Latitude  // South west corner latitude.
	SwcLong                     Longitude // South west corner latitude.
	Name                        string
	NormalizedPower             uint16
	LeftRightBalance            LeftRightBalance100
	SubSport                    SubSport
	TotalWork                   uint32
	AvgAltitude                 uint16
	MaxAltitude                 uint16
	GpsAccuracy                 uint8
	AvgGrade                    int16
	AvgPosGrade                 int16
	AvgNegGrade                 int16
	MaxPosGrade                 int16
	MaxNegGrade                 int16
	AvgTemperature              int8
	MaxTemperature              int8
	TotalMovingTime             uint32
	AvgPosVerticalSpeed         int16
	AvgNegVerticalSpeed         int16
	MaxPosVerticalSpeed         int16
	MaxNegVerticalSpeed         int16
	TimeInHrZone                []uint32
	TimeInSpeedZone             []uint32
	TimeInCadenceZone           []uint32
	TimeInPowerZone             []uint32
	RepetitionNum               uint16
	MinAltitude                 uint16
	MinHeartRate                uint8
	ActiveTime                  uint32
	WktStepIndex                MessageIndex
	SportEvent                  SportEvent
	AvgLeftTorqueEffectiveness  uint8
	AvgRightTorqueEffectiveness uint8
	AvgLeftPedalSmoothness      uint8
	AvgRightPedalSmoothness     uint8
	AvgCombinedPedalSmoothness  uint8
	Status                      SegmentLapStatus
	Uuid                        string
	AvgFractionalCadence        uint8 // fractional part of the avg_cadence
	MaxFractionalCadence        uint8 // fractional part of the max_cadence
	TotalFractionalCycles       uint8 // fractional part of the total_cycles
	FrontGearShiftCount         uint16
	RearGearShiftCount          uint16
}

// NewSegmentLapMsg returns a segment_lap FIT message
// initialized to all-invalid values.
func NewSegmentLapMsg() *SegmentLapMsg {
	return &SegmentLapMsg{
		MessageIndex:                0xFFFF,
		Timestamp:                   timeBase,
		Event:                       0xFF,
		EventType:                   0xFF,
		StartTime:                   timeBase,
		StartPositionLat:            NewLatitudeInvalid(),
		StartPositionLong:           NewLongitudeInvalid(),
		EndPositionLat:              NewLatitudeInvalid(),
		EndPositionLong:             NewLongitudeInvalid(),
		TotalElapsedTime:            0xFFFFFFFF,
		TotalTimerTime:              0xFFFFFFFF,
		TotalDistance:               0xFFFFFFFF,
		TotalCycles:                 0xFFFFFFFF,
		TotalCalories:               0xFFFF,
		TotalFatCalories:            0xFFFF,
		AvgSpeed:                    0xFFFF,
		MaxSpeed:                    0xFFFF,
		AvgHeartRate:                0xFF,
		MaxHeartRate:                0xFF,
		AvgCadence:                  0xFF,
		MaxCadence:                  0xFF,
		AvgPower:                    0xFFFF,
		MaxPower:                    0xFFFF,
		TotalAscent:                 0xFFFF,
		TotalDescent:                0xFFFF,
		Sport:                       0xFF,
		EventGroup:                  0xFF,
		NecLat:                      NewLatitudeInvalid(),
		NecLong:                     NewLongitudeInvalid(),
		SwcLat:                      NewLatitudeInvalid(),
		SwcLong:                     NewLongitudeInvalid(),
		Name:                        "",
		NormalizedPower:             0xFFFF,
		LeftRightBalance:            0xFFFF,
		SubSport:                    0xFF,
		TotalWork:                   0xFFFFFFFF,
		AvgAltitude:                 0xFFFF,
		MaxAltitude:                 0xFFFF,
		GpsAccuracy:                 0xFF,
		AvgGrade:                    0x7FFF,
		AvgPosGrade:                 0x7FFF,
		AvgNegGrade:                 0x7FFF,
		MaxPosGrade:                 0x7FFF,
		MaxNegGrade:                 0x7FFF,
		AvgTemperature:              0x7F,
		MaxTemperature:              0x7F,
		TotalMovingTime:             0xFFFFFFFF,
		AvgPosVerticalSpeed:         0x7FFF,
		AvgNegVerticalSpeed:         0x7FFF,
		MaxPosVerticalSpeed:         0x7FFF,
		MaxNegVerticalSpeed:         0x7FFF,
		TimeInHrZone:                nil,
		TimeInSpeedZone:             nil,
		TimeInCadenceZone:           nil,
		TimeInPowerZone:             nil,
		RepetitionNum:               0xFFFF,
		MinAltitude:                 0xFFFF,
		MinHeartRate:                0xFF,
		ActiveTime:                  0xFFFFFFFF,
		WktStepIndex:                0xFFFF,
		SportEvent:                  0xFF,
		AvgLeftTorqueEffectiveness:  0xFF,
		AvgRightTorqueEffectiveness: 0xFF,
		AvgLeftPedalSmoothness:      0xFF,
		AvgRightPedalSmoothness:     0xFF,
		AvgCombinedPedalSmoothness:  0xFF,
		Status:                0xFF,
		Uuid:                  "",
		AvgFractionalCadence:  0xFF,
		MaxFractionalCadence:  0xFF,
		TotalFractionalCycles: 0xFF,
		FrontGearShiftCount:   0xFFFF,
		RearGearShiftCount:    0xFFFF,
	}
}

// GetTotalElapsedTimeScaled returns TotalElapsedTime
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: s
func (x *SegmentLapMsg) GetTotalElapsedTimeScaled() float64 {
	if x.TotalElapsedTime == 0xFFFFFFFF {
		return math.NaN()
	}
	return float64(x.TotalElapsedTime) / 1000
}

// GetTotalTimerTimeScaled returns TotalTimerTime
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: s
func (x *SegmentLapMsg) GetTotalTimerTimeScaled() float64 {
	if x.TotalTimerTime == 0xFFFFFFFF {
		return math.NaN()
	}
	return float64(x.TotalTimerTime) / 1000
}

// GetTotalDistanceScaled returns TotalDistance
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m
func (x *SegmentLapMsg) GetTotalDistanceScaled() float64 {
	if x.TotalDistance == 0xFFFFFFFF {
		return math.NaN()
	}
	return float64(x.TotalDistance) / 100
}

// GetAvgSpeedScaled returns AvgSpeed
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m/s
func (x *SegmentLapMsg) GetAvgSpeedScaled() float64 {
	if x.AvgSpeed == 0xFFFF {
		return math.NaN()
	}
	return float64(x.AvgSpeed) / 1000
}

// GetMaxSpeedScaled returns MaxSpeed
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m/s
func (x *SegmentLapMsg) GetMaxSpeedScaled() float64 {
	if x.MaxSpeed == 0xFFFF {
		return math.NaN()
	}
	return float64(x.MaxSpeed) / 1000
}

// GetAvgAltitudeScaled returns AvgAltitude
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m
func (x *SegmentLapMsg) GetAvgAltitudeScaled() float64 {
	if x.AvgAltitude == 0xFFFF {
		return math.NaN()
	}
	return float64(x.AvgAltitude)/5 - 500
}

// GetMaxAltitudeScaled returns MaxAltitude
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m
func (x *SegmentLapMsg) GetMaxAltitudeScaled() float64 {
	if x.MaxAltitude == 0xFFFF {
		return math.NaN()
	}
	return float64(x.MaxAltitude)/5 - 500
}

// GetAvgGradeScaled returns AvgGrade
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: %
func (x *SegmentLapMsg) GetAvgGradeScaled() float64 {
	if x.AvgGrade == 0x7FFF {
		return math.NaN()
	}
	return float64(x.AvgGrade) / 100
}

// GetAvgPosGradeScaled returns AvgPosGrade
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: %
func (x *SegmentLapMsg) GetAvgPosGradeScaled() float64 {
	if x.AvgPosGrade == 0x7FFF {
		return math.NaN()
	}
	return float64(x.AvgPosGrade) / 100
}

// GetAvgNegGradeScaled returns AvgNegGrade
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: %
func (x *SegmentLapMsg) GetAvgNegGradeScaled() float64 {
	if x.AvgNegGrade == 0x7FFF {
		return math.NaN()
	}
	return float64(x.AvgNegGrade) / 100
}

// GetMaxPosGradeScaled returns MaxPosGrade
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: %
func (x *SegmentLapMsg) GetMaxPosGradeScaled() float64 {
	if x.MaxPosGrade == 0x7FFF {
		return math.NaN()
	}
	return float64(x.MaxPosGrade) / 100
}

// GetMaxNegGradeScaled returns MaxNegGrade
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: %
func (x *SegmentLapMsg) GetMaxNegGradeScaled() float64 {
	if x.MaxNegGrade == 0x7FFF {
		return math.NaN()
	}
	return float64(x.MaxNegGrade) / 100
}

// GetTotalMovingTimeScaled returns TotalMovingTime
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: s
func (x *SegmentLapMsg) GetTotalMovingTimeScaled() float64 {
	if x.TotalMovingTime == 0xFFFFFFFF {
		return math.NaN()
	}
	return float64(x.TotalMovingTime) / 1000
}

// GetAvgPosVerticalSpeedScaled returns AvgPosVerticalSpeed
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m/s
func (x *SegmentLapMsg) GetAvgPosVerticalSpeedScaled() float64 {
	if x.AvgPosVerticalSpeed == 0x7FFF {
		return math.NaN()
	}
	return float64(x.AvgPosVerticalSpeed) / 1000
}

// GetAvgNegVerticalSpeedScaled returns AvgNegVerticalSpeed
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m/s
func (x *SegmentLapMsg) GetAvgNegVerticalSpeedScaled() float64 {
	if x.AvgNegVerticalSpeed == 0x7FFF {
		return math.NaN()
	}
	return float64(x.AvgNegVerticalSpeed) / 1000
}

// GetMaxPosVerticalSpeedScaled returns MaxPosVerticalSpeed
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m/s
func (x *SegmentLapMsg) GetMaxPosVerticalSpeedScaled() float64 {
	if x.MaxPosVerticalSpeed == 0x7FFF {
		return math.NaN()
	}
	return float64(x.MaxPosVerticalSpeed) / 1000
}

// GetMaxNegVerticalSpeedScaled returns MaxNegVerticalSpeed
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m/s
func (x *SegmentLapMsg) GetMaxNegVerticalSpeedScaled() float64 {
	if x.MaxNegVerticalSpeed == 0x7FFF {
		return math.NaN()
	}
	return float64(x.MaxNegVerticalSpeed) / 1000
}

// GetTimeInHrZoneScaled returns TimeInHrZone
// as a slice with scale and any offset applied to every element.
// Units: s
func (x *SegmentLapMsg) GetTimeInHrZoneScaled() []float64 {
	if len(x.TimeInHrZone) == 0 {
		return nil
	}
	s := make([]float64, len(x.TimeInHrZone))
	for i, v := range x.TimeInHrZone {
		s[i] = float64(v) / 1000
	}
	return s
}

// GetTimeInSpeedZoneScaled returns TimeInSpeedZone
// as a slice with scale and any offset applied to every element.
// Units: s
func (x *SegmentLapMsg) GetTimeInSpeedZoneScaled() []float64 {
	if len(x.TimeInSpeedZone) == 0 {
		return nil
	}
	s := make([]float64, len(x.TimeInSpeedZone))
	for i, v := range x.TimeInSpeedZone {
		s[i] = float64(v) / 1000
	}
	return s
}

// GetTimeInCadenceZoneScaled returns TimeInCadenceZone
// as a slice with scale and any offset applied to every element.
// Units: s
func (x *SegmentLapMsg) GetTimeInCadenceZoneScaled() []float64 {
	if len(x.TimeInCadenceZone) == 0 {
		return nil
	}
	s := make([]float64, len(x.TimeInCadenceZone))
	for i, v := range x.TimeInCadenceZone {
		s[i] = float64(v) / 1000
	}
	return s
}

// GetTimeInPowerZoneScaled returns TimeInPowerZone
// as a slice with scale and any offset applied to every element.
// Units: s
func (x *SegmentLapMsg) GetTimeInPowerZoneScaled() []float64 {
	if len(x.TimeInPowerZone) == 0 {
		return nil
	}
	s := make([]float64, len(x.TimeInPowerZone))
	for i, v := range x.TimeInPowerZone {
		s[i] = float64(v) / 1000
	}
	return s
}

// GetMinAltitudeScaled returns MinAltitude
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m
func (x *SegmentLapMsg) GetMinAltitudeScaled() float64 {
	if x.MinAltitude == 0xFFFF {
		return math.NaN()
	}
	return float64(x.MinAltitude)/5 - 500
}

// GetActiveTimeScaled returns ActiveTime
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: s
func (x *SegmentLapMsg) GetActiveTimeScaled() float64 {
	if x.ActiveTime == 0xFFFFFFFF {
		return math.NaN()
	}
	return float64(x.ActiveTime) / 1000
}

// GetAvgLeftTorqueEffectivenessScaled returns AvgLeftTorqueEffectiveness
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: percent
func (x *SegmentLapMsg) GetAvgLeftTorqueEffectivenessScaled() float64 {
	if x.AvgLeftTorqueEffectiveness == 0xFF {
		return math.NaN()
	}
	return float64(x.AvgLeftTorqueEffectiveness) / 2
}

// GetAvgRightTorqueEffectivenessScaled returns AvgRightTorqueEffectiveness
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: percent
func (x *SegmentLapMsg) GetAvgRightTorqueEffectivenessScaled() float64 {
	if x.AvgRightTorqueEffectiveness == 0xFF {
		return math.NaN()
	}
	return float64(x.AvgRightTorqueEffectiveness) / 2
}

// GetAvgLeftPedalSmoothnessScaled returns AvgLeftPedalSmoothness
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: percent
func (x *SegmentLapMsg) GetAvgLeftPedalSmoothnessScaled() float64 {
	if x.AvgLeftPedalSmoothness == 0xFF {
		return math.NaN()
	}
	return float64(x.AvgLeftPedalSmoothness) / 2
}

// GetAvgRightPedalSmoothnessScaled returns AvgRightPedalSmoothness
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: percent
func (x *SegmentLapMsg) GetAvgRightPedalSmoothnessScaled() float64 {
	if x.AvgRightPedalSmoothness == 0xFF {
		return math.NaN()
	}
	return float64(x.AvgRightPedalSmoothness) / 2
}

// GetAvgCombinedPedalSmoothnessScaled returns AvgCombinedPedalSmoothness
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: percent
func (x *SegmentLapMsg) GetAvgCombinedPedalSmoothnessScaled() float64 {
	if x.AvgCombinedPedalSmoothness == 0xFF {
		return math.NaN()
	}
	return float64(x.AvgCombinedPedalSmoothness) / 2
}

// GetAvgFractionalCadenceScaled returns AvgFractionalCadence
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: rpm
func (x *SegmentLapMsg) GetAvgFractionalCadenceScaled() float64 {
	if x.AvgFractionalCadence == 0xFF {
		return math.NaN()
	}
	return float64(x.AvgFractionalCadence) / 128
}

// GetMaxFractionalCadenceScaled returns MaxFractionalCadence
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: rpm
func (x *SegmentLapMsg) GetMaxFractionalCadenceScaled() float64 {
	if x.MaxFractionalCadence == 0xFF {
		return math.NaN()
	}
	return float64(x.MaxFractionalCadence) / 128
}

// GetTotalFractionalCyclesScaled returns TotalFractionalCycles
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: cycles
func (x *SegmentLapMsg) GetTotalFractionalCyclesScaled() float64 {
	if x.TotalFractionalCycles == 0xFF {
		return math.NaN()
	}
	return float64(x.TotalFractionalCycles) / 128
}

// GetTotalCycles returns the appropriate TotalCycles
// subfield if a matching reference field/value combination is found.
// If none of the reference field/value combinations are true
// then the main field is returned.
func (x *SegmentLapMsg) GetTotalCycles() interface{} {
	switch x.Sport {
	case SportCycling:
		return uint32(x.TotalCycles)
	default:
		return x.TotalCycles
	}
}

// SegmentFileMsg represents the segment_file FIT message type.
type SegmentFileMsg struct {
	MessageIndex          MessageIndex
	FileUuid              string                   // UUID of the segment file
	Enabled               Bool                     // Enabled state of the segment file
	UserProfilePrimaryKey uint32                   // Primary key of the user that created the segment file
	LeaderType            []SegmentLeaderboardType // Leader type of each leader in the segment file
	LeaderGroupPrimaryKey []uint32                 // Group primary key of each leader in the segment file
	LeaderActivityId      []uint32                 // Activity ID of each leader in the segment file
}

// NewSegmentFileMsg returns a segment_file FIT message
// initialized to all-invalid values.
func NewSegmentFileMsg() *SegmentFileMsg {
	return &SegmentFileMsg{
		MessageIndex:          0xFFFF,
		FileUuid:              "",
		Enabled:               0xFF,
		UserProfilePrimaryKey: 0xFFFFFFFF,
		LeaderType:            nil,
		LeaderGroupPrimaryKey: nil,
		LeaderActivityId:      nil,
	}
}

// WorkoutMsg represents the workout FIT message type.
type WorkoutMsg struct {
	Sport          Sport
	Capabilities   WorkoutCapabilities
	NumValidSteps  uint16 // number of valid steps
	WktName        string
	SubSport       SubSport
	PoolLength     uint16
	PoolLengthUnit DisplayMeasure
}

// NewWorkoutMsg returns a workout FIT message
// initialized to all-invalid values.
func NewWorkoutMsg() *WorkoutMsg {
	return &WorkoutMsg{
		Sport:          0xFF,
		Capabilities:   0x00000000,
		NumValidSteps:  0xFFFF,
		WktName:        "",
		SubSport:       0xFF,
		PoolLength:     0xFFFF,
		PoolLengthUnit: 0xFF,
	}
}

// GetPoolLengthScaled returns PoolLength
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m
func (x *WorkoutMsg) GetPoolLengthScaled() float64 {
	if x.PoolLength == 0xFFFF {
		return math.NaN()
	}
	return float64(x.PoolLength) / 100
}

// WorkoutSessionMsg represents the workout_session FIT message type.
type WorkoutSessionMsg struct {
	MessageIndex   MessageIndex
	Sport          Sport
	SubSport       SubSport
	NumValidSteps  uint16
	FirstStepIndex uint16
	PoolLength     uint16
	PoolLengthUnit DisplayMeasure
}

// NewWorkoutSessionMsg returns a workout_session FIT message
// initialized to all-invalid values.
func NewWorkoutSessionMsg() *WorkoutSessionMsg {
	return &WorkoutSessionMsg{
		MessageIndex:   0xFFFF,
		Sport:          0xFF,
		SubSport:       0xFF,
		NumValidSteps:  0xFFFF,
		FirstStepIndex: 0xFFFF,
		PoolLength:     0xFFFF,
		PoolLengthUnit: 0xFF,
	}
}

// GetPoolLengthScaled returns PoolLength
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m
func (x *WorkoutSessionMsg) GetPoolLengthScaled() float64 {
	if x.PoolLength == 0xFFFF {
		return math.NaN()
	}
	return float64(x.PoolLength) / 100
}

// WorkoutStepMsg represents the workout_step FIT message type.
type WorkoutStepMsg struct {
	MessageIndex          MessageIndex
	WktStepName           string
	DurationType          WktStepDuration
	DurationValue         uint32
	TargetType            WktStepTarget
	TargetValue           uint32
	CustomTargetValueLow  uint32
	CustomTargetValueHigh uint32
	Intensity             Intensity
	Notes                 string
	Equipment             WorkoutEquipment
}

// NewWorkoutStepMsg returns a workout_step FIT message
// initialized to all-invalid values.
func NewWorkoutStepMsg() *WorkoutStepMsg {
	return &WorkoutStepMsg{
		MessageIndex:          0xFFFF,
		WktStepName:           "",
		DurationType:          0xFF,
		DurationValue:         0xFFFFFFFF,
		TargetType:            0xFF,
		TargetValue:           0xFFFFFFFF,
		CustomTargetValueLow:  0xFFFFFFFF,
		CustomTargetValueHigh: 0xFFFFFFFF,
		Intensity:             0xFF,
		Notes:                 "",
		Equipment:             0xFF,
	}
}

// GetDurationValue returns the appropriate DurationValue
// subfield if a matching reference field/value combination is found.
// If none of the reference field/value combinations are true
// then the main field is returned.
func (x *WorkoutStepMsg) GetDurationValue() interface{} {
	switch x.DurationType {
	case WktStepDurationTime, WktStepDurationRepetitionTime:
		return float64(x.DurationValue) / 1000
	case WktStepDurationDistance:
		return float64(x.DurationValue) / 100
	case WktStepDurationHrLessThan, WktStepDurationHrGreaterThan:
		return WorkoutHr(x.DurationValue)
	case WktStepDurationCalories:
		return uint32(x.DurationValue)
	case WktStepDurationRepeatUntilStepsCmplt, WktStepDurationRepeatUntilTime, WktStepDurationRepeatUntilDistance, WktStepDurationRepeatUntilCalories, WktStepDurationRepeatUntilHrLessThan, WktStepDurationRepeatUntilHrGreaterThan, WktStepDurationRepeatUntilPowerLessThan, WktStepDurationRepeatUntilPowerGreaterThan:
		return uint32(x.DurationValue)
	case WktStepDurationPowerLessThan, WktStepDurationPowerGreaterThan:
		return WorkoutPower(x.DurationValue)
	default:
		return x.DurationValue
	}
}

// GetTargetValue returns the appropriate TargetValue
// subfield if a matching reference field/value combination is found.
// If none of the reference field/value combinations are true
// then the main field is returned.
func (x *WorkoutStepMsg) GetTargetValue() interface{} {
	switch {
	case x.TargetType == WktStepTargetSpeed:
		return uint32(x.TargetValue)
	case x.TargetType == WktStepTargetHeartRate:
		return uint32(x.TargetValue)
	case x.TargetType == WktStepTargetCadence:
		return uint32(x.TargetValue)
	case x.TargetType == WktStepTargetPower:
		return uint32(x.TargetValue)
	case x.DurationType == WktStepDurationRepeatUntilStepsCmplt:
		return uint32(x.TargetValue)
	case x.DurationType == WktStepDurationRepeatUntilTime:
		return float64(x.TargetValue) / 1000
	case x.DurationType == WktStepDurationRepeatUntilDistance:
		return float64(x.TargetValue) / 100
	case x.DurationType == WktStepDurationRepeatUntilCalories:
		return uint32(x.TargetValue)
	case x.DurationType == WktStepDurationRepeatUntilHrLessThan:
		return WorkoutHr(x.TargetValue)
	case x.DurationType == WktStepDurationRepeatUntilHrGreaterThan:
		return WorkoutHr(x.TargetValue)
	case x.DurationType == WktStepDurationRepeatUntilPowerLessThan:
		return WorkoutPower(x.TargetValue)
	case x.DurationType == WktStepDurationRepeatUntilPowerGreaterThan:
		return WorkoutPower(x.TargetValue)
	case x.TargetType == WktStepTargetSwimStroke:
		return SwimStroke(x.TargetValue)
	default:
		return x.TargetValue
	}
}

// GetCustomTargetValueLow returns the appropriate CustomTargetValueLow
// subfield if a matching reference field/value combination is found.
// If none of the reference field/value combinations are true
// then the main field is returned.
func (x *WorkoutStepMsg) GetCustomTargetValueLow() interface{} {
	switch x.TargetType {
	case WktStepTargetSpeed:
		return float64(x.CustomTargetValueLow) / 1000
	case WktStepTargetHeartRate:
		return WorkoutHr(x.CustomTargetValueLow)
	case WktStepTargetCadence:
		return uint32(x.CustomTargetValueLow)
	case WktStepTargetPower:
		return WorkoutPower(x.CustomTargetValueLow)
	default:
		return x.CustomTargetValueLow
	}
}

// GetCustomTargetValueHigh returns the appropriate CustomTargetValueHigh
// subfield if a matching reference field/value combination is found.
// If none of the reference field/value combinations are true
// then the main field is returned.
func (x *WorkoutStepMsg) GetCustomTargetValueHigh() interface{} {
	switch x.TargetType {
	case WktStepTargetSpeed:
		return float64(x.CustomTargetValueHigh) / 1000
	case WktStepTargetHeartRate:
		return WorkoutHr(x.CustomTargetValueHigh)
	case WktStepTargetCadence:
		return uint32(x.CustomTargetValueHigh)
	case WktStepTargetPower:
		return WorkoutPower(x.CustomTargetValueHigh)
	default:
		return x.CustomTargetValueHigh
	}
}

// ScheduleMsg represents the schedule FIT message type.
type ScheduleMsg struct {
	Manufacturer  Manufacturer // Corresponds to file_id of scheduled workout / course.
	Product       uint16       // Corresponds to file_id of scheduled workout / course.
	SerialNumber  uint32       // Corresponds to file_id of scheduled workout / course.
	TimeCreated   time.Time    // Corresponds to file_id of scheduled workout / course.
	Completed     Bool         // TRUE if this activity has been started
	Type          Schedule
	ScheduledTime time.Time
}

// NewScheduleMsg returns a schedule FIT message
// initialized to all-invalid values.
func NewScheduleMsg() *ScheduleMsg {
	return &ScheduleMsg{
		Manufacturer:  0xFFFF,
		Product:       0xFFFF,
		SerialNumber:  0x00000000,
		TimeCreated:   timeBase,
		Completed:     0xFF,
		Type:          0xFF,
		ScheduledTime: timeBase,
	}
}

// GetProduct returns the appropriate Product
// subfield if a matching reference field/value combination is found.
// If none of the reference field/value combinations are true
// then the main field is returned.
func (x *ScheduleMsg) GetProduct() interface{} {
	switch x.Manufacturer {
	case ManufacturerGarmin, ManufacturerDynastream, ManufacturerDynastreamOem:
		return GarminProduct(x.Product)
	default:
		return x.Product
	}
}

// TotalsMsg represents the totals FIT message type.
type TotalsMsg struct {
	MessageIndex MessageIndex
	Timestamp    time.Time
	TimerTime    uint32 // Excludes pauses
	Distance     uint32
	Calories     uint32
	Sport        Sport
	ElapsedTime  uint32 // Includes pauses
	Sessions     uint16
	ActiveTime   uint32
}

// NewTotalsMsg returns a totals FIT message
// initialized to all-invalid values.
func NewTotalsMsg() *TotalsMsg {
	return &TotalsMsg{
		MessageIndex: 0xFFFF,
		Timestamp:    timeBase,
		TimerTime:    0xFFFFFFFF,
		Distance:     0xFFFFFFFF,
		Calories:     0xFFFFFFFF,
		Sport:        0xFF,
		ElapsedTime:  0xFFFFFFFF,
		Sessions:     0xFFFF,
		ActiveTime:   0xFFFFFFFF,
	}
}

// WeightScaleMsg represents the weight_scale FIT message type.
type WeightScaleMsg struct {
	Timestamp         time.Time
	Weight            Weight
	PercentFat        uint16
	PercentHydration  uint16
	VisceralFatMass   uint16
	BoneMass          uint16
	MuscleMass        uint16
	BasalMet          uint16
	PhysiqueRating    uint8
	ActiveMet         uint16 // ~4kJ per kcal, 0.25 allows max 16384 kcal
	MetabolicAge      uint8
	VisceralFatRating uint8
	UserProfileIndex  MessageIndex // Associates this weight scale message to a user.  This corresponds to the index of the user profile message in the weight scale file.
}

// NewWeightScaleMsg returns a weight_scale FIT message
// initialized to all-invalid values.
func NewWeightScaleMsg() *WeightScaleMsg {
	return &WeightScaleMsg{
		Timestamp:         timeBase,
		Weight:            0xFFFF,
		PercentFat:        0xFFFF,
		PercentHydration:  0xFFFF,
		VisceralFatMass:   0xFFFF,
		BoneMass:          0xFFFF,
		MuscleMass:        0xFFFF,
		BasalMet:          0xFFFF,
		PhysiqueRating:    0xFF,
		ActiveMet:         0xFFFF,
		MetabolicAge:      0xFF,
		VisceralFatRating: 0xFF,
		UserProfileIndex:  0xFFFF,
	}
}

// GetWeightScaled returns Weight
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: kg
func (x *WeightScaleMsg) GetWeightScaled() float64 {
	if x.Weight == 0xFFFF {
		return math.NaN()
	}
	return float64(x.Weight) / 100
}

// GetPercentFatScaled returns PercentFat
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: %
func (x *WeightScaleMsg) GetPercentFatScaled() float64 {
	if x.PercentFat == 0xFFFF {
		return math.NaN()
	}
	return float64(x.PercentFat) / 100
}

// GetPercentHydrationScaled returns PercentHydration
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: %
func (x *WeightScaleMsg) GetPercentHydrationScaled() float64 {
	if x.PercentHydration == 0xFFFF {
		return math.NaN()
	}
	return float64(x.PercentHydration) / 100
}

// GetVisceralFatMassScaled returns VisceralFatMass
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: kg
func (x *WeightScaleMsg) GetVisceralFatMassScaled() float64 {
	if x.VisceralFatMass == 0xFFFF {
		return math.NaN()
	}
	return float64(x.VisceralFatMass) / 100
}

// GetBoneMassScaled returns BoneMass
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: kg
func (x *WeightScaleMsg) GetBoneMassScaled() float64 {
	if x.BoneMass == 0xFFFF {
		return math.NaN()
	}
	return float64(x.BoneMass) / 100
}

// GetMuscleMassScaled returns MuscleMass
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: kg
func (x *WeightScaleMsg) GetMuscleMassScaled() float64 {
	if x.MuscleMass == 0xFFFF {
		return math.NaN()
	}
	return float64(x.MuscleMass) / 100
}

// GetBasalMetScaled returns BasalMet
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: kcal/day
func (x *WeightScaleMsg) GetBasalMetScaled() float64 {
	if x.BasalMet == 0xFFFF {
		return math.NaN()
	}
	return float64(x.BasalMet) / 4
}

// GetActiveMetScaled returns ActiveMet
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: kcal/day
func (x *WeightScaleMsg) GetActiveMetScaled() float64 {
	if x.ActiveMet == 0xFFFF {
		return math.NaN()
	}
	return float64(x.ActiveMet) / 4
}

// BloodPressureMsg represents the blood_pressure FIT message type.
type BloodPressureMsg struct {
	Timestamp            time.Time
	SystolicPressure     uint16
	DiastolicPressure    uint16
	MeanArterialPressure uint16
	Map3SampleMean       uint16
	MapMorningValues     uint16
	MapEveningValues     uint16
	HeartRate            uint8
	HeartRateType        HrType
	Status               BpStatus
	UserProfileIndex     MessageIndex // Associates this blood pressure message to a user.  This corresponds to the index of the user profile message in the blood pressure file.
}

// NewBloodPressureMsg returns a blood_pressure FIT message
// initialized to all-invalid values.
func NewBloodPressureMsg() *BloodPressureMsg {
	return &BloodPressureMsg{
		Timestamp:            timeBase,
		SystolicPressure:     0xFFFF,
		DiastolicPressure:    0xFFFF,
		MeanArterialPressure: 0xFFFF,
		Map3SampleMean:       0xFFFF,
		MapMorningValues:     0xFFFF,
		MapEveningValues:     0xFFFF,
		HeartRate:            0xFF,
		HeartRateType:        0xFF,
		Status:               0xFF,
		UserProfileIndex:     0xFFFF,
	}
}

// MonitoringInfoMsg represents the monitoring_info FIT message type.
type MonitoringInfoMsg struct {
	Timestamp      time.Time
	LocalTimestamp time.Time // Use to convert activity timestamps to local time if device does not support time zone and daylight savings time correction.
}

// NewMonitoringInfoMsg returns a monitoring_info FIT message
// initialized to all-invalid values.
func NewMonitoringInfoMsg() *MonitoringInfoMsg {
	return &MonitoringInfoMsg{
		Timestamp:      timeBase,
		LocalTimestamp: timeBase,
	}
}

// MonitoringMsg represents the monitoring FIT message type.
type MonitoringMsg struct {
	Timestamp       time.Time   // Must align to logging interval, for example, time must be 00:00:00 for daily log.
	DeviceIndex     DeviceIndex // Associates this data to device_info message.  Not required for file with single device (sensor).
	Calories        uint16      // Accumulated total calories.  Maintained by MonitoringReader for each activity_type.  See SDK documentation
	Distance        uint32      // Accumulated distance.  Maintained by MonitoringReader for each activity_type.  See SDK documentation.
	Cycles          uint32      // Accumulated cycles.  Maintained by MonitoringReader for each activity_type.  See SDK documentation.
	ActiveTime      uint32
	ActivityType    ActivityType
	ActivitySubtype ActivitySubtype
	Distance16      uint16
	Cycles16        uint16
	ActiveTime16    uint16
	LocalTimestamp  time.Time // Must align to logging interval, for example, time must be 00:00:00 for daily log.
}

// NewMonitoringMsg returns a monitoring FIT message
// initialized to all-invalid values.
func NewMonitoringMsg() *MonitoringMsg {
	return &MonitoringMsg{
		Timestamp:       timeBase,
		DeviceIndex:     0xFF,
		Calories:        0xFFFF,
		Distance:        0xFFFFFFFF,
		Cycles:          0xFFFFFFFF,
		ActiveTime:      0xFFFFFFFF,
		ActivityType:    0xFF,
		ActivitySubtype: 0xFF,
		Distance16:      0xFFFF,
		Cycles16:        0xFFFF,
		ActiveTime16:    0xFFFF,
		LocalTimestamp:  timeBase,
	}
}

// GetDistanceScaled returns Distance
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m
func (x *MonitoringMsg) GetDistanceScaled() float64 {
	if x.Distance == 0xFFFFFFFF {
		return math.NaN()
	}
	return float64(x.Distance) / 100
}

// GetCyclesScaled returns Cycles
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: cycles
func (x *MonitoringMsg) GetCyclesScaled() float64 {
	if x.Cycles == 0xFFFFFFFF {
		return math.NaN()
	}
	return float64(x.Cycles) / 2
}

// GetActiveTimeScaled returns ActiveTime
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: s
func (x *MonitoringMsg) GetActiveTimeScaled() float64 {
	if x.ActiveTime == 0xFFFFFFFF {
		return math.NaN()
	}
	return float64(x.ActiveTime) / 1000
}

// GetCycles returns the appropriate Cycles
// subfield if a matching reference field/value combination is found.
// If none of the reference field/value combinations are true
// then the main field is returned.
func (x *MonitoringMsg) GetCycles() interface{} {
	switch x.ActivityType {
	case ActivityTypeCycling, ActivityTypeSwimming:
		return float64(x.Cycles) / 2
	default:
		return x.Cycles
	}
}

// HrMsg represents the hr FIT message type.
type HrMsg struct {
	Timestamp           time.Time
	FractionalTimestamp uint16
	Time256             uint8
	FilteredBpm         []uint8
	EventTimestamp      []uint32
	EventTimestamp12    []byte
}

// NewHrMsg returns a hr FIT message
// initialized to all-invalid values.
func NewHrMsg() *HrMsg {
	return &HrMsg{
		Timestamp:           timeBase,
		FractionalTimestamp: 0xFFFF,
		Time256:             0xFF,
		FilteredBpm:         nil,
		EventTimestamp:      nil,
		EventTimestamp12:    nil,
	}
}

// GetFractionalTimestampScaled returns FractionalTimestamp
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: s
func (x *HrMsg) GetFractionalTimestampScaled() float64 {
	if x.FractionalTimestamp == 0xFFFF {
		return math.NaN()
	}
	return float64(x.FractionalTimestamp) / 32768
}

// GetTime256Scaled returns Time256
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: s
func (x *HrMsg) GetTime256Scaled() float64 {
	if x.Time256 == 0xFF {
		return math.NaN()
	}
	return float64(x.Time256) / 256
}

// GetEventTimestampScaled returns EventTimestamp
// as a slice with scale and any offset applied to every element.
// Units: s
func (x *HrMsg) GetEventTimestampScaled() []float64 {
	if len(x.EventTimestamp) == 0 {
		return nil
	}
	s := make([]float64, len(x.EventTimestamp))
	for i, v := range x.EventTimestamp {
		s[i] = float64(v) / 1024
	}
	return s
}

func (x *HrMsg) expandComponents() {
	if x.Time256 != 0xFF {
	}
	// TODO
}

// MemoGlobMsg represents the memo_glob FIT message type.
type MemoGlobMsg struct {
}

// NewMemoGlobMsg returns a memo_glob FIT message
// initialized to all-invalid values.
func NewMemoGlobMsg() *MemoGlobMsg {
	return &MemoGlobMsg{}
}

// AntChannelIdMsg represents the ant_channel_id FIT message type.
type AntChannelIdMsg struct {
}

// NewAntChannelIdMsg returns a ant_channel_id FIT message
// initialized to all-invalid values.
func NewAntChannelIdMsg() *AntChannelIdMsg {
	return &AntChannelIdMsg{}
}

// AntRxMsg represents the ant_rx FIT message type.
type AntRxMsg struct {
	Timestamp           time.Time
	FractionalTimestamp uint16
	MesgId              byte
	MesgData            []byte
	ChannelNumber       uint8
	Data                []byte
}

// NewAntRxMsg returns a ant_rx FIT message
// initialized to all-invalid values.
func NewAntRxMsg() *AntRxMsg {
	return &AntRxMsg{
		Timestamp:           timeBase,
		FractionalTimestamp: 0xFFFF,
		MesgId:              0xFF,
		MesgData:            nil,
		ChannelNumber:       0xFF,
		Data:                nil,
	}
}

// GetFractionalTimestampScaled returns FractionalTimestamp
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: s
func (x *AntRxMsg) GetFractionalTimestampScaled() float64 {
	if x.FractionalTimestamp == 0xFFFF {
		return math.NaN()
	}
	return float64(x.FractionalTimestamp) / 32768
}

func (x *AntRxMsg) expandComponents() {
	if len(x.MesgData) != 0 {
		x.Data = make([]byte, len(x.MesgData)-1)
		for i, v := range x.MesgData {
			if v == 0xFF {
				break
			}
			if i == 0 {
				x.ChannelNumber = v
			} else {
				x.Data[i-1] = v
			}
		}
	}
}

// AntTxMsg represents the ant_tx FIT message type.
type AntTxMsg struct {
	Timestamp           time.Time
	FractionalTimestamp uint16
	MesgId              byte
	MesgData            []byte
	ChannelNumber       uint8
	Data                []byte
}

// NewAntTxMsg returns a ant_tx FIT message
// initialized to all-invalid values.
func NewAntTxMsg() *AntTxMsg {
	return &AntTxMsg{
		Timestamp:           timeBase,
		FractionalTimestamp: 0xFFFF,
		MesgId:              0xFF,
		MesgData:            nil,
		ChannelNumber:       0xFF,
		Data:                nil,
	}
}

// GetFractionalTimestampScaled returns FractionalTimestamp
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: s
func (x *AntTxMsg) GetFractionalTimestampScaled() float64 {
	if x.FractionalTimestamp == 0xFFFF {
		return math.NaN()
	}
	return float64(x.FractionalTimestamp) / 32768
}

func (x *AntTxMsg) expandComponents() {
	if len(x.MesgData) != 0 {
		x.Data = make([]byte, len(x.MesgData)-1)
		for i, v := range x.MesgData {
			if v == 0xFF {
				break
			}
			if i == 0 {
				x.ChannelNumber = v
			} else {
				x.Data[i-1] = v
			}
		}
	}
}

// ExdScreenConfigurationMsg represents the exd_screen_configuration FIT message type.
type ExdScreenConfigurationMsg struct {
	ScreenIndex   uint8
	FieldCount    uint8 // number of fields in screen
	Layout        ExdLayout
	ScreenEnabled Bool
}

// NewExdScreenConfigurationMsg returns a exd_screen_configuration FIT message
// initialized to all-invalid values.
func NewExdScreenConfigurationMsg() *ExdScreenConfigurationMsg {
	return &ExdScreenConfigurationMsg{
		ScreenIndex:   0xFF,
		FieldCount:    0xFF,
		Layout:        0xFF,
		ScreenEnabled: 0xFF,
	}
}

// ExdDataFieldConfigurationMsg represents the exd_data_field_configuration FIT message type.
type ExdDataFieldConfigurationMsg struct {
	ScreenIndex  uint8
	ConceptField byte
	FieldId      uint8
	ConceptCount uint8
	DisplayType  ExdDisplayType
	Title        []string
}

// NewExdDataFieldConfigurationMsg returns a exd_data_field_configuration FIT message
// initialized to all-invalid values.
func NewExdDataFieldConfigurationMsg() *ExdDataFieldConfigurationMsg {
	return &ExdDataFieldConfigurationMsg{
		ScreenIndex:  0xFF,
		ConceptField: 0xFF,
		FieldId:      0xFF,
		ConceptCount: 0xFF,
		DisplayType:  0xFF,
		Title:        nil,
	}
}

func (x *ExdDataFieldConfigurationMsg) expandComponents() {
	if x.ConceptField != 0xFF {
		x.FieldId = uint8(
			(x.ConceptField >> 0) & ((1 << 4) - 1),
		)
		x.ConceptCount = uint8(
			(x.ConceptField >> 4) & ((1 << 4) - 1),
		)
	}
}

// ExdDataConceptConfigurationMsg represents the exd_data_concept_configuration FIT message type.
type ExdDataConceptConfigurationMsg struct {
	ScreenIndex  uint8
	ConceptField byte
	FieldId      uint8
	ConceptIndex uint8
	DataPage     uint8
	ConceptKey   uint8
	Scaling      uint8
	DataUnits    ExdDataUnits
	Qualifier    ExdQualifiers
	Descriptor   ExdDescriptors
	IsSigned     Bool
}

// NewExdDataConceptConfigurationMsg returns a exd_data_concept_configuration FIT message
// initialized to all-invalid values.
func NewExdDataConceptConfigurationMsg() *ExdDataConceptConfigurationMsg {
	return &ExdDataConceptConfigurationMsg{
		ScreenIndex:  0xFF,
		ConceptField: 0xFF,
		FieldId:      0xFF,
		ConceptIndex: 0xFF,
		DataPage:     0xFF,
		ConceptKey:   0xFF,
		Scaling:      0xFF,
		DataUnits:    0xFF,
		Qualifier:    0xFF,
		Descriptor:   0xFF,
		IsSigned:     0xFF,
	}
}

func (x *ExdDataConceptConfigurationMsg) expandComponents() {
	if x.ConceptField != 0xFF {
		x.FieldId = uint8(
			(x.ConceptField >> 0) & ((1 << 4) - 1),
		)
		x.ConceptIndex = uint8(
			(x.ConceptField >> 4) & ((1 << 4) - 1),
		)
	}
}

// FieldDescriptionMsg represents the field_description FIT message type.
type FieldDescriptionMsg struct {
	DeveloperDataIndex    uint8
	FieldDefinitionNumber uint8
	FitBaseTypeId         FitBaseType
	FieldName             []string
	Array                 uint8
	Components            string
	Scale                 uint8
	Offset                int8
	Units                 []string
	Bits                  string
	Accumulate            string
	FitBaseUnitId         FitBaseUnit
	NativeMesgNum         MesgNum
	NativeFieldNum        uint8
}

// NewFieldDescriptionMsg returns a field_description FIT message
// initialized to all-invalid values.
func NewFieldDescriptionMsg() *FieldDescriptionMsg {
	return &FieldDescriptionMsg{
		DeveloperDataIndex:    0xFF,
		FieldDefinitionNumber: 0xFF,
		FitBaseTypeId:         0xFF,
		FieldName:             nil,
		Array:                 0xFF,
		Components:            "",
		Scale:                 0xFF,
		Offset:                0x7F,
		Units:                 nil,
		Bits:                  "",
		Accumulate:            "",
		FitBaseUnitId:         0xFFFF,
		NativeMesgNum:         0xFFFF,
		NativeFieldNum:        0xFF,
	}
}

// DeveloperDataIdMsg represents the developer_data_id FIT message type.
type DeveloperDataIdMsg struct {
	DeveloperId        []byte
	ApplicationId      []byte
	ManufacturerId     Manufacturer
	DeveloperDataIndex uint8
	ApplicationVersion uint32
}

// NewDeveloperDataIdMsg returns a developer_data_id FIT message
// initialized to all-invalid values.
func NewDeveloperDataIdMsg() *DeveloperDataIdMsg {
	return &DeveloperDataIdMsg{
		DeveloperId:        nil,
		ApplicationId:      nil,
		ManufacturerId:     0xFFFF,
		DeveloperDataIndex: 0xFF,
		ApplicationVersion: 0xFFFFFFFF,
	}
}
// PROFILE
// Code generated using the program found in 'cmd/fitgen/main.go'. DO NOT EDIT.

// SDK Version: 20.43

package fit

import (
	"reflect"

	"github.com/tormoder/fit/internal/types"
)

const (
	// ProfileMajorVersion is the current supported profile major version of the FIT SDK.
	ProfileMajorVersion = 20

	// ProfileMinorVersion is the current supported profile minor version of the FIT SDK.
	ProfileMinorVersion = 43
)

var knownMsgNums = map[MesgNum]bool{
	MesgNumFileId:                      true,
	MesgNumCapabilities:                true,
	MesgNumDeviceSettings:              true,
	MesgNumUserProfile:                 true,
	MesgNumHrmProfile:                  true,
	MesgNumSdmProfile:                  true,
	MesgNumBikeProfile:                 true,
	MesgNumZonesTarget:                 true,
	MesgNumHrZone:                      true,
	MesgNumPowerZone:                   true,
	MesgNumMetZone:                     true,
	MesgNumSport:                       true,
	MesgNumGoal:                        true,
	MesgNumSession:                     true,
	MesgNumLap:                         true,
	MesgNumRecord:                      true,
	MesgNumEvent:                       true,
	MesgNumDeviceInfo:                  true,
	MesgNumWorkout:                     true,
	MesgNumWorkoutStep:                 true,
	MesgNumSchedule:                    true,
	MesgNumWeightScale:                 true,
	MesgNumCourse:                      true,
	MesgNumCoursePoint:                 true,
	MesgNumTotals:                      true,
	MesgNumActivity:                    true,
	MesgNumSoftware:                    true,
	MesgNumFileCapabilities:            true,
	MesgNumMesgCapabilities:            true,
	MesgNumFieldCapabilities:           true,
	MesgNumFileCreator:                 true,
	MesgNumBloodPressure:               true,
	MesgNumSpeedZone:                   true,
	MesgNumMonitoring:                  true,
	MesgNumTrainingFile:                true,
	MesgNumHrv:                         true,
	MesgNumAntRx:                       true,
	MesgNumAntTx:                       true,
	MesgNumAntChannelId:                true,
	MesgNumLength:                      true,
	MesgNumMonitoringInfo:              true,
	MesgNumSlaveDevice:                 true,
	MesgNumConnectivity:                true,
	MesgNumWeatherConditions:           true,
	MesgNumWeatherAlert:                true,
	MesgNumCadenceZone:                 true,
	MesgNumHr:                          true,
	MesgNumSegmentLap:                  true,
	MesgNumMemoGlob:                    true,
	MesgNumSegmentId:                   true,
	MesgNumSegmentLeaderboardEntry:     true,
	MesgNumSegmentPoint:                true,
	MesgNumSegmentFile:                 true,
	MesgNumWorkoutSession:              true,
	MesgNumWatchfaceSettings:           true,
	MesgNumCameraEvent:                 true,
	MesgNumTimestampCorrelation:        true,
	MesgNumGyroscopeData:               true,
	MesgNumAccelerometerData:           true,
	MesgNumThreeDSensorCalibration:     true,
	MesgNumVideoFrame:                  true,
	MesgNumObdiiData:                   true,
	MesgNumNmeaSentence:                true,
	MesgNumAviationAttitude:            true,
	MesgNumVideo:                       true,
	MesgNumVideoTitle:                  true,
	MesgNumVideoDescription:            true,
	MesgNumVideoClip:                   true,
	MesgNumOhrSettings:                 true,
	MesgNumExdScreenConfiguration:      true,
	MesgNumExdDataFieldConfiguration:   true,
	MesgNumExdDataConceptConfiguration: true,
	MesgNumFieldDescription:            true,
	MesgNumDeveloperDataId:             true,
	MesgNumMagnetometerData:            true,
}

var (
	accumuDistance         *uint32Accumulator
	accumuTotalCycles      *uint32Accumulator
	accumuAccumulatedPower *uint32Accumulator
)

// Set length to 256, so that lookup for any
// field 255 (localMesgNumInvalid) will return nil.
var _fields = [...][256]*field{
	MesgNumFileId: {
		0: {0, 0, types.Fit(0)},
		1: {1, 1, types.Fit(4)},
		2: {2, 2, types.Fit(4)},
		3: {3, 3, types.Fit(12)},
		4: {4, 4, types.Fit(70)},
		5: {5, 5, types.Fit(4)},
		8: {6, 8, types.Fit(7)},
	},

	MesgNumFileCreator: {
		0: {0, 0, types.Fit(4)},
		1: {1, 1, types.Fit(2)},
	},

	MesgNumTimestampCorrelation: {},

	MesgNumSoftware: {
		254: {0, 254, types.Fit(4)},
		3:   {1, 3, types.Fit(4)},
		5:   {2, 5, types.Fit(7)},
	},

	MesgNumSlaveDevice: {
		0: {0, 0, types.Fit(4)},
		1: {1, 1, types.Fit(4)},
	},

	MesgNumCapabilities: {
		0:  {0, 0, types.Fit(42)},
		1:  {1, 1, types.Fit(42)},
		21: {2, 21, types.Fit(12)},
		23: {3, 23, types.Fit(12)},
	},

	MesgNumFileCapabilities: {
		254: {0, 254, types.Fit(4)},
		0:   {1, 0, types.Fit(0)},
		1:   {2, 1, types.Fit(10)},
		2:   {3, 2, types.Fit(7)},
		3:   {4, 3, types.Fit(4)},
		4:   {5, 4, types.Fit(6)},
	},

	MesgNumMesgCapabilities: {
		254: {0, 254, types.Fit(4)},
		0:   {1, 0, types.Fit(0)},
		1:   {2, 1, types.Fit(4)},
		2:   {3, 2, types.Fit(0)},
		3:   {4, 3, types.Fit(4)},
	},

	MesgNumFieldCapabilities: {
		254: {0, 254, types.Fit(4)},
		0:   {1, 0, types.Fit(0)},
		1:   {2, 1, types.Fit(4)},
		2:   {3, 2, types.Fit(2)},
		3:   {4, 3, types.Fit(4)},
	},

	MesgNumDeviceSettings: {
		0:  {0, 0, types.Fit(2)},
		1:  {1, 1, types.Fit(6)},
		2:  {2, 2, types.Fit(38)},
		4:  {3, 4, types.Fit(32)},
		5:  {4, 5, types.Fit(33)},
		12: {5, 12, types.Fit(0)},
		36: {6, 36, types.Fit(0)},
		39: {7, 39, types.Fit(70)},
		40: {8, 40, types.Fit(36)},
		46: {9, 46, types.Fit(0)},
		47: {10, 47, types.Fit(0)},
		55: {11, 55, types.Fit(0)},
		56: {12, 56, types.Fit(0)},
		57: {13, 57, types.Fit(36)},
		58: {14, 58, types.Fit(4)},
		59: {15, 59, types.Fit(4)},
	},

	MesgNumUserProfile: {
		254: {0, 254, types.Fit(4)},
		0:   {1, 0, types.Fit(7)},
		1:   {2, 1, types.Fit(0)},
		2:   {3, 2, types.Fit(2)},
		3:   {4, 3, types.Fit(2)},
		4:   {5, 4, types.Fit(4)},
		5:   {6, 5, types.Fit(0)},
		6:   {7, 6, types.Fit(0)},
		7:   {8, 7, types.Fit(0)},
		8:   {9, 8, types.Fit(2)},
		9:   {10, 9, types.Fit(2)},
		10:  {11, 10, types.Fit(2)},
		11:  {12, 11, types.Fit(2)},
		12:  {13, 12, types.Fit(0)},
		13:  {14, 13, types.Fit(0)},
		14:  {15, 14, types.Fit(0)},
		16:  {16, 16, types.Fit(0)},
		17:  {17, 17, types.Fit(0)},
		18:  {18, 18, types.Fit(0)},
		21:  {19, 21, types.Fit(0)},
		22:  {20, 22, types.Fit(4)},
		23:  {21, 23, types.Fit(45)},
		30:  {22, 30, types.Fit(0)},
		31:  {23, 31, types.Fit(4)},
		32:  {24, 32, types.Fit(4)},
	},

	MesgNumHrmProfile: {
		254: {0, 254, types.Fit(4)},
		0:   {1, 0, types.Fit(0)},
		1:   {2, 1, types.Fit(11)},
		2:   {3, 2, types.Fit(0)},
		3:   {4, 3, types.Fit(10)},
	},

	MesgNumSdmProfile: {
		254: {0, 254, types.Fit(4)},
		0:   {1, 0, types.Fit(0)},
		1:   {2, 1, types.Fit(11)},
		2:   {3, 2, types.Fit(4)},
		3:   {4, 3, types.Fit(6)},
		4:   {5, 4, types.Fit(0)},
		5:   {6, 5, types.Fit(10)},
		7:   {7, 7, types.Fit(2)},
	},

	MesgNumBikeProfile: {
		254: {0, 254, types.Fit(4)},
		0:   {1, 0, types.Fit(7)},
		1:   {2, 1, types.Fit(0)},
		2:   {3, 2, types.Fit(0)},
		3:   {4, 3, types.Fit(6)},
		4:   {5, 4, types.Fit(11)},
		5:   {6, 5, types.Fit(11)},
		6:   {7, 6, types.Fit(11)},
		7:   {8, 7, types.Fit(11)},
		8:   {9, 8, types.Fit(4)},
		9:   {10, 9, types.Fit(4)},
		10:  {11, 10, types.Fit(4)},
		11:  {12, 11, types.Fit(4)},
		12:  {13, 12, types.Fit(0)},
		13:  {14, 13, types.Fit(0)},
		14:  {15, 14, types.Fit(2)},
		15:  {16, 15, types.Fit(0)},
		16:  {17, 16, types.Fit(0)},
		17:  {18, 17, types.Fit(0)},
		18:  {19, 18, types.Fit(0)},
		19:  {20, 19, types.Fit(2)},
		20:  {21, 20, types.Fit(0)},
		21:  {22, 21, types.Fit(10)},
		22:  {23, 22, types.Fit(10)},
		23:  {24, 23, types.Fit(10)},
		24:  {25, 24, types.Fit(10)},
		37:  {26, 37, types.Fit(2)},
		38:  {27, 38, types.Fit(10)},
		39:  {28, 39, types.Fit(42)},
		40:  {29, 40, types.Fit(10)},
		41:  {30, 41, types.Fit(42)},
		44:  {31, 44, types.Fit(0)},
	},

	MesgNumConnectivity: {
		0:  {0, 0, types.Fit(0)},
		1:  {1, 1, types.Fit(0)},
		2:  {2, 2, types.Fit(0)},
		3:  {3, 3, types.Fit(7)},
		4:  {4, 4, types.Fit(0)},
		5:  {5, 5, types.Fit(0)},
		6:  {6, 6, types.Fit(0)},
		7:  {7, 7, types.Fit(0)},
		8:  {8, 8, types.Fit(0)},
		9:  {9, 9, types.Fit(0)},
		10: {10, 10, types.Fit(0)},
		11: {11, 11, types.Fit(0)},
		12: {12, 12, types.Fit(0)},
	},

	MesgNumWatchfaceSettings: {},

	MesgNumOhrSettings: {},

	MesgNumZonesTarget: {
		1: {0, 1, types.Fit(2)},
		2: {1, 2, types.Fit(2)},
		3: {2, 3, types.Fit(4)},
		5: {3, 5, types.Fit(0)},
		7: {4, 7, types.Fit(0)},
	},

	MesgNumSport: {
		0: {0, 0, types.Fit(0)},
		1: {1, 1, types.Fit(0)},
		3: {2, 3, types.Fit(7)},
	},

	MesgNumHrZone: {
		254: {0, 254, types.Fit(4)},
		1:   {1, 1, types.Fit(2)},
		2:   {2, 2, types.Fit(7)},
	},

	MesgNumSpeedZone: {
		254: {0, 254, types.Fit(4)},
		0:   {1, 0, types.Fit(4)},
		1:   {2, 1, types.Fit(7)},
	},

	MesgNumCadenceZone: {
		254: {0, 254, types.Fit(4)},
		0:   {1, 0, types.Fit(2)},
		1:   {2, 1, types.Fit(7)},
	},

	MesgNumPowerZone: {
		254: {0, 254, types.Fit(4)},
		1:   {1, 1, types.Fit(4)},
		2:   {2, 2, types.Fit(7)},
	},

	MesgNumMetZone: {
		254: {0, 254, types.Fit(4)},
		1:   {1, 1, types.Fit(2)},
		2:   {2, 2, types.Fit(4)},
		3:   {3, 3, types.Fit(2)},
	},

	MesgNumGoal: {
		254: {0, 254, types.Fit(4)},
		0:   {1, 0, types.Fit(0)},
		1:   {2, 1, types.Fit(0)},
		2:   {3, 2, types.Fit(70)},
		3:   {4, 3, types.Fit(70)},
		4:   {5, 4, types.Fit(0)},
		5:   {6, 5, types.Fit(6)},
		6:   {7, 6, types.Fit(0)},
		7:   {8, 7, types.Fit(6)},
		8:   {9, 8, types.Fit(0)},
		9:   {10, 9, types.Fit(4)},
		10:  {11, 10, types.Fit(0)},
		11:  {12, 11, types.Fit(0)},
	},

	MesgNumActivity: {
		253: {0, 253, types.Fit(70)},
		0:   {1, 0, types.Fit(6)},
		1:   {2, 1, types.Fit(4)},
		2:   {3, 2, types.Fit(0)},
		3:   {4, 3, types.Fit(0)},
		4:   {5, 4, types.Fit(0)},
		5:   {6, 5, types.Fit(134)},
		6:   {7, 6, types.Fit(2)},
	},

	MesgNumSession: {
		254: {0, 254, types.Fit(4)},
		253: {1, 253, types.Fit(70)},
		0:   {2, 0, types.Fit(0)},
		1:   {3, 1, types.Fit(0)},
		2:   {4, 2, types.Fit(70)},
		3:   {5, 3, types.Fit(197)},
		4:   {6, 4, types.Fit(261)},
		5:   {7, 5, types.Fit(0)},
		6:   {8, 6, types.Fit(0)},
		7:   {9, 7, types.Fit(6)},
		8:   {10, 8, types.Fit(6)},
		9:   {11, 9, types.Fit(6)},
		10:  {12, 10, types.Fit(6)},
		11:  {13, 11, types.Fit(4)},
		13:  {14, 13, types.Fit(4)},
		14:  {15, 14, types.Fit(4)},
		15:  {16, 15, types.Fit(4)},
		16:  {17, 16, types.Fit(2)},
		17:  {18, 17, types.Fit(2)},
		18:  {19, 18, types.Fit(2)},
		19:  {20, 19, types.Fit(2)},
		20:  {21, 20, types.Fit(4)},
		21:  {22, 21, types.Fit(4)},
		22:  {23, 22, types.Fit(4)},
		23:  {24, 23, types.Fit(4)},
		24:  {25, 24, types.Fit(2)},
		25:  {26, 25, types.Fit(4)},
		26:  {27, 26, types.Fit(4)},
		27:  {28, 27, types.Fit(2)},
		28:  {29, 28, types.Fit(0)},
		29:  {30, 29, types.Fit(197)},
		30:  {31, 30, types.Fit(261)},
		31:  {32, 31, types.Fit(197)},
		32:  {33, 32, types.Fit(261)},
		34:  {34, 34, types.Fit(4)},
		35:  {35, 35, types.Fit(4)},
		36:  {36, 36, types.Fit(4)},
		37:  {37, 37, types.Fit(4)},
		41:  {38, 41, types.Fit(6)},
		42:  {39, 42, types.Fit(4)},
		43:  {40, 43, types.Fit(0)},
		44:  {41, 44, types.Fit(4)},
		45:  {42, 45, types.Fit(4)},
		46:  {43, 46, types.Fit(0)},
		47:  {44, 47, types.Fit(4)},
		48:  {45, 48, types.Fit(6)},
		49:  {46, 49, types.Fit(4)},
		50:  {47, 50, types.Fit(4)},
		51:  {48, 51, types.Fit(2)},
		52:  {49, 52, types.Fit(3)},
		53:  {50, 53, types.Fit(3)},
		54:  {51, 54, types.Fit(3)},
		55:  {52, 55, types.Fit(3)},
		56:  {53, 56, types.Fit(3)},
		57:  {54, 57, types.Fit(1)},
		58:  {55, 58, types.Fit(1)},
		59:  {56, 59, types.Fit(6)},
		60:  {57, 60, types.Fit(3)},
		61:  {58, 61, types.Fit(3)},
		62:  {59, 62, types.Fit(3)},
		63:  {60, 63, types.Fit(3)},
		64:  {61, 64, types.Fit(2)},
		65:  {62, 65, types.Fit(38)},
		66:  {63, 66, types.Fit(38)},
		67:  {64, 67, types.Fit(38)},
		68:  {65, 68, types.Fit(38)},
		69:  {66, 69, types.Fit(6)},
		70:  {67, 70, types.Fit(4)},
		71:  {68, 71, types.Fit(4)},
		82:  {69, 82, types.Fit(4)},
		83:  {70, 83, types.Fit(4)},
		84:  {71, 84, types.Fit(7)},
		85:  {72, 85, types.Fit(36)},
		86:  {73, 86, types.Fit(36)},
		87:  {74, 87, types.Fit(4)},
		88:  {75, 88, types.Fit(4)},
		89:  {76, 89, types.Fit(4)},
		90:  {77, 90, types.Fit(4)},
		91:  {78, 91, types.Fit(4)},
		92:  {79, 92, types.Fit(2)},
		93:  {80, 93, types.Fit(2)},
		94:  {81, 94, types.Fit(2)},
		111: {82, 111, types.Fit(2)},
		124: {83, 124, types.Fit(6)},
		125: {84, 125, types.Fit(6)},
		126: {85, 126, types.Fit(6)},
		127: {86, 127, types.Fit(6)},
		128: {87, 128, types.Fit(6)},
		137: {88, 137, types.Fit(2)},
		139: {89, 139, types.Fit(4)},
	},

	MesgNumLap: {
		254: {0, 254, types.Fit(4)},
		253: {1, 253, types.Fit(70)},
		0:   {2, 0, types.Fit(0)},
		1:   {3, 1, types.Fit(0)},
		2:   {4, 2, types.Fit(70)},
		3:   {5, 3, types.Fit(197)},
		4:   {6, 4, types.Fit(261)},
		5:   {7, 5, types.Fit(197)},
		6:   {8, 6, types.Fit(261)},
		7:   {9, 7, types.Fit(6)},
		8:   {10, 8, types.Fit(6)},
		9:   {11, 9, types.Fit(6)},
		10:  {12, 10, types.Fit(6)},
		11:  {13, 11, types.Fit(4)},
		12:  {14, 12, types.Fit(4)},
		13:  {15, 13, types.Fit(4)},
		14:  {16, 14, types.Fit(4)},
		15:  {17, 15, types.Fit(2)},
		16:  {18, 16, types.Fit(2)},
		17:  {19, 17, types.Fit(2)},
		18:  {20, 18, types.Fit(2)},
		19:  {21, 19, types.Fit(4)},
		20:  {22, 20, types.Fit(4)},
		21:  {23, 21, types.Fit(4)},
		22:  {24, 22, types.Fit(4)},
		23:  {25, 23, types.Fit(0)},
		24:  {26, 24, types.Fit(0)},
		25:  {27, 25, types.Fit(0)},
		26:  {28, 26, types.Fit(2)},
		32:  {29, 32, types.Fit(4)},
		33:  {30, 33, types.Fit(4)},
		34:  {31, 34, types.Fit(4)},
		35:  {32, 35, types.Fit(4)},
		37:  {33, 37, types.Fit(4)},
		38:  {34, 38, types.Fit(0)},
		39:  {35, 39, types.Fit(0)},
		40:  {36, 40, types.Fit(4)},
		41:  {37, 41, types.Fit(6)},
		42:  {38, 42, types.Fit(4)},
		43:  {39, 43, types.Fit(4)},
		44:  {40, 44, types.Fit(2)},
		45:  {41, 45, types.Fit(3)},
		46:  {42, 46, types.Fit(3)},
		47:  {43, 47, types.Fit(3)},
		48:  {44, 48, types.Fit(3)},
		49:  {45, 49, types.Fit(3)},
		50:  {46, 50, types.Fit(1)},
		51:  {47, 51, types.Fit(1)},
		52:  {48, 52, types.Fit(6)},
		53:  {49, 53, types.Fit(3)},
		54:  {50, 54, types.Fit(3)},
		55:  {51, 55, types.Fit(3)},
		56:  {52, 56, types.Fit(3)},
		57:  {53, 57, types.Fit(38)},
		58:  {54, 58, types.Fit(38)},
		59:  {55, 59, types.Fit(38)},
		60:  {56, 60, types.Fit(38)},
		61:  {57, 61, types.Fit(4)},
		62:  {58, 62, types.Fit(4)},
		63:  {59, 63, types.Fit(2)},
		71:  {60, 71, types.Fit(4)},
		74:  {61, 74, types.Fit(4)},
		75:  {62, 75, types.Fit(36)},
		76:  {63, 76, types.Fit(36)},
		77:  {64, 77, types.Fit(4)},
		78:  {65, 78, types.Fit(4)},
		79:  {66, 79, types.Fit(4)},
		80:  {67, 80, types.Fit(2)},
		81:  {68, 81, types.Fit(2)},
		82:  {69, 82, types.Fit(2)},
		83:  {70, 83, types.Fit(4)},
		84:  {71, 84, types.Fit(36)},
		85:  {72, 85, types.Fit(36)},
		86:  {73, 86, types.Fit(36)},
		87:  {74, 87, types.Fit(36)},
		88:  {75, 88, types.Fit(36)},
		89:  {76, 89, types.Fit(36)},
		110: {77, 110, types.Fit(6)},
		111: {78, 111, types.Fit(6)},
		112: {79, 112, types.Fit(6)},
		113: {80, 113, types.Fit(6)},
		114: {81, 114, types.Fit(6)},
		121: {82, 121, types.Fit(4)},
	},

	MesgNumLength: {
		254: {0, 254, types.Fit(4)},
		253: {1, 253, types.Fit(70)},
		0:   {2, 0, types.Fit(0)},
		1:   {3, 1, types.Fit(0)},
		2:   {4, 2, types.Fit(70)},
		3:   {5, 3, types.Fit(6)},
		4:   {6, 4, types.Fit(6)},
		5:   {7, 5, types.Fit(4)},
		6:   {8, 6, types.Fit(4)},
		7:   {9, 7, types.Fit(0)},
		9:   {10, 9, types.Fit(2)},
		10:  {11, 10, types.Fit(2)},
		11:  {12, 11, types.Fit(4)},
		12:  {13, 12, types.Fit(0)},
		18:  {14, 18, types.Fit(4)},
		19:  {15, 19, types.Fit(4)},
		20:  {16, 20, types.Fit(36)},
		21:  {17, 21, types.Fit(36)},
	},

	MesgNumRecord: {
		253: {0, 253, types.Fit(70)},
		0:   {1, 0, types.Fit(197)},
		1:   {2, 1, types.Fit(261)},
		2:   {3, 2, types.Fit(4)},
		3:   {4, 3, types.Fit(2)},
		4:   {5, 4, types.Fit(2)},
		5:   {6, 5, types.Fit(6)},
		6:   {7, 6, types.Fit(4)},
		7:   {8, 7, types.Fit(4)},
		8:   {9, 8, types.Fit(45)},
		9:   {10, 9, types.Fit(3)},
		10:  {11, 10, types.Fit(2)},
		11:  {12, 11, types.Fit(5)},
		12:  {13, 12, types.Fit(2)},
		13:  {14, 13, types.Fit(1)},
		17:  {15, 17, types.Fit(34)},
		18:  {16, 18, types.Fit(2)},
		19:  {17, 19, types.Fit(6)},
		28:  {18, 28, types.Fit(4)},
		29:  {19, 29, types.Fit(6)},
		30:  {20, 30, types.Fit(2)},
		31:  {21, 31, types.Fit(2)},
		32:  {22, 32, types.Fit(3)},
		33:  {23, 33, types.Fit(4)},
		39:  {24, 39, types.Fit(4)},
		40:  {25, 40, types.Fit(4)},
		41:  {26, 41, types.Fit(4)},
		42:  {27, 42, types.Fit(0)},
		43:  {28, 43, types.Fit(2)},
		44:  {29, 44, types.Fit(2)},
		45:  {30, 45, types.Fit(2)},
		46:  {31, 46, types.Fit(2)},
		47:  {32, 47, types.Fit(2)},
		48:  {33, 48, types.Fit(2)},
		49:  {34, 49, types.Fit(0)},
		50:  {35, 50, types.Fit(2)},
		51:  {36, 51, types.Fit(4)},
		52:  {37, 52, types.Fit(4)},
		53:  {38, 53, types.Fit(2)},
		54:  {39, 54, types.Fit(4)},
		55:  {40, 55, types.Fit(4)},
		56:  {41, 56, types.Fit(4)},
		57:  {42, 57, types.Fit(4)},
		58:  {43, 58, types.Fit(4)},
		59:  {44, 59, types.Fit(4)},
		62:  {45, 62, types.Fit(2)},
		73:  {46, 73, types.Fit(6)},
		78:  {47, 78, types.Fit(6)},
	},

	MesgNumEvent: {
		253: {0, 253, types.Fit(70)},
		0:   {1, 0, types.Fit(0)},
		1:   {2, 1, types.Fit(0)},
		2:   {3, 2, types.Fit(4)},
		3:   {4, 3, types.Fit(6)},
		4:   {5, 4, types.Fit(2)},
		7:   {6, 7, types.Fit(4)},
		8:   {7, 8, types.Fit(4)},
		9:   {8, 9, types.Fit(10)},
		10:  {9, 10, types.Fit(10)},
		11:  {10, 11, types.Fit(10)},
		12:  {11, 12, types.Fit(10)},
	},

	MesgNumDeviceInfo: {
		253: {0, 253, types.Fit(70)},
		0:   {1, 0, types.Fit(2)},
		1:   {2, 1, types.Fit(2)},
		2:   {3, 2, types.Fit(4)},
		3:   {4, 3, types.Fit(12)},
		4:   {5, 4, types.Fit(4)},
		5:   {6, 5, types.Fit(4)},
		6:   {7, 6, types.Fit(2)},
		7:   {8, 7, types.Fit(6)},
		10:  {9, 10, types.Fit(4)},
		11:  {10, 11, types.Fit(2)},
		18:  {11, 18, types.Fit(0)},
		19:  {12, 19, types.Fit(7)},
		20:  {13, 20, types.Fit(10)},
		21:  {14, 21, types.Fit(11)},
		22:  {15, 22, types.Fit(0)},
		25:  {16, 25, types.Fit(0)},
		27:  {17, 27, types.Fit(7)},
	},

	MesgNumTrainingFile: {
		253: {0, 253, types.Fit(70)},
		0:   {1, 0, types.Fit(0)},
		1:   {2, 1, types.Fit(4)},
		2:   {3, 2, types.Fit(4)},
		3:   {4, 3, types.Fit(12)},
		4:   {5, 4, types.Fit(70)},
	},

	MesgNumHrv: {
		0: {0, 0, types.Fit(36)},
	},

	MesgNumWeatherConditions: {
		253: {0, 253, types.Fit(70)},
		0:   {1, 0, types.Fit(0)},
		1:   {2, 1, types.Fit(1)},
		2:   {3, 2, types.Fit(0)},
		3:   {4, 3, types.Fit(4)},
		4:   {5, 4, types.Fit(4)},
		5:   {6, 5, types.Fit(2)},
		6:   {7, 6, types.Fit(1)},
		7:   {8, 7, types.Fit(2)},
		8:   {9, 8, types.Fit(7)},
		9:   {10, 9, types.Fit(70)},
		10:  {11, 10, types.Fit(197)},
		11:  {12, 11, types.Fit(261)},
		12:  {13, 12, types.Fit(0)},
		13:  {14, 13, types.Fit(1)},
		14:  {15, 14, types.Fit(1)},
	},

	MesgNumWeatherAlert: {
		253: {0, 253, types.Fit(70)},
		0:   {1, 0, types.Fit(7)},
		1:   {2, 1, types.Fit(70)},
		2:   {3, 2, types.Fit(70)},
		3:   {4, 3, types.Fit(0)},
		4:   {5, 4, types.Fit(0)},
	},

	MesgNumGpsMetadata: {},

	MesgNumCameraEvent: {},

	MesgNumGyroscopeData: {},

	MesgNumAccelerometerData: {},

	MesgNumMagnetometerData: {},

	MesgNumThreeDSensorCalibration: {},

	MesgNumVideoFrame: {},

	MesgNumObdiiData: {},

	MesgNumNmeaSentence: {
		253: {0, 253, types.Fit(70)},
		0:   {1, 0, types.Fit(4)},
		1:   {2, 1, types.Fit(7)},
	},

	MesgNumAviationAttitude: {
		253: {0, 253, types.Fit(70)},
		0:   {1, 0, types.Fit(4)},
		1:   {2, 1, types.Fit(38)},
		2:   {3, 2, types.Fit(35)},
		3:   {4, 3, types.Fit(35)},
		4:   {5, 4, types.Fit(35)},
		5:   {6, 5, types.Fit(35)},
		6:   {7, 6, types.Fit(35)},
		7:   {8, 7, types.Fit(32)},
		8:   {9, 8, types.Fit(34)},
		9:   {10, 9, types.Fit(36)},
		10:  {11, 10, types.Fit(36)},
	},

	MesgNumVideo: {},

	MesgNumVideoTitle: {
		254: {0, 254, types.Fit(4)},
		0:   {1, 0, types.Fit(4)},
		1:   {2, 1, types.Fit(7)},
	},

	MesgNumVideoDescription: {
		254: {0, 254, types.Fit(4)},
		0:   {1, 0, types.Fit(4)},
		1:   {2, 1, types.Fit(7)},
	},

	MesgNumVideoClip: {},

	MesgNumCourse: {
		4: {0, 4, types.Fit(0)},
		5: {1, 5, types.Fit(7)},
		6: {2, 6, types.Fit(12)},
		7: {3, 7, types.Fit(0)},
	},

	MesgNumCoursePoint: {
		254: {0, 254, types.Fit(4)},
		1:   {1, 1, types.Fit(70)},
		2:   {2, 2, types.Fit(197)},
		3:   {3, 3, types.Fit(261)},
		4:   {4, 4, types.Fit(6)},
		5:   {5, 5, types.Fit(0)},
		6:   {6, 6, types.Fit(7)},
		8:   {7, 8, types.Fit(0)},
	},

	MesgNumSegmentId: {
		0: {0, 0, types.Fit(7)},
		1: {1, 1, types.Fit(7)},
		2: {2, 2, types.Fit(0)},
		3: {3, 3, types.Fit(0)},
		4: {4, 4, types.Fit(6)},
		5: {5, 5, types.Fit(6)},
		6: {6, 6, types.Fit(2)},
		7: {7, 7, types.Fit(0)},
		8: {8, 8, types.Fit(0)},
	},

	MesgNumSegmentLeaderboardEntry: {
		254: {0, 254, types.Fit(4)},
		0:   {1, 0, types.Fit(7)},
		1:   {2, 1, types.Fit(0)},
		2:   {3, 2, types.Fit(6)},
		3:   {4, 3, types.Fit(6)},
		4:   {5, 4, types.Fit(6)},
	},

	MesgNumSegmentPoint: {
		254: {0, 254, types.Fit(4)},
		1:   {1, 1, types.Fit(197)},
		2:   {2, 2, types.Fit(261)},
		3:   {3, 3, types.Fit(6)},
		4:   {4, 4, types.Fit(4)},
		5:   {5, 5, types.Fit(38)},
	},

	MesgNumSegmentLap: {
		254: {0, 254, types.Fit(4)},
		253: {1, 253, types.Fit(70)},
		0:   {2, 0, types.Fit(0)},
		1:   {3, 1, types.Fit(0)},
		2:   {4, 2, types.Fit(70)},
		3:   {5, 3, types.Fit(197)},
		4:   {6, 4, types.Fit(261)},
		5:   {7, 5, types.Fit(197)},
		6:   {8, 6, types.Fit(261)},
		7:   {9, 7, types.Fit(6)},
		8:   {10, 8, types.Fit(6)},
		9:   {11, 9, types.Fit(6)},
		10:  {12, 10, types.Fit(6)},
		11:  {13, 11, types.Fit(4)},
		12:  {14, 12, types.Fit(4)},
		13:  {15, 13, types.Fit(4)},
		14:  {16, 14, types.Fit(4)},
		15:  {17, 15, types.Fit(2)},
		16:  {18, 16, types.Fit(2)},
		17:  {19, 17, types.Fit(2)},
		18:  {20, 18, types.Fit(2)},
		19:  {21, 19, types.Fit(4)},
		20:  {22, 20, types.Fit(4)},
		21:  {23, 21, types.Fit(4)},
		22:  {24, 22, types.Fit(4)},
		23:  {25, 23, types.Fit(0)},
		24:  {26, 24, types.Fit(2)},
		25:  {27, 25, types.Fit(197)},
		26:  {28, 26, types.Fit(261)},
		27:  {29, 27, types.Fit(197)},
		28:  {30, 28, types.Fit(261)},
		29:  {31, 29, types.Fit(7)},
		30:  {32, 30, types.Fit(4)},
		31:  {33, 31, types.Fit(4)},
		32:  {34, 32, types.Fit(0)},
		33:  {35, 33, types.Fit(6)},
		34:  {36, 34, types.Fit(4)},
		35:  {37, 35, types.Fit(4)},
		36:  {38, 36, types.Fit(2)},
		37:  {39, 37, types.Fit(3)},
		38:  {40, 38, types.Fit(3)},
		39:  {41, 39, types.Fit(3)},
		40:  {42, 40, types.Fit(3)},
		41:  {43, 41, types.Fit(3)},
		42:  {44, 42, types.Fit(1)},
		43:  {45, 43, types.Fit(1)},
		44:  {46, 44, types.Fit(6)},
		45:  {47, 45, types.Fit(3)},
		46:  {48, 46, types.Fit(3)},
		47:  {49, 47, types.Fit(3)},
		48:  {50, 48, types.Fit(3)},
		49:  {51, 49, types.Fit(38)},
		50:  {52, 50, types.Fit(38)},
		51:  {53, 51, types.Fit(38)},
		52:  {54, 52, types.Fit(38)},
		53:  {55, 53, types.Fit(4)},
		54:  {56, 54, types.Fit(4)},
		55:  {57, 55, types.Fit(2)},
		56:  {58, 56, types.Fit(6)},
		57:  {59, 57, types.Fit(4)},
		58:  {60, 58, types.Fit(0)},
		59:  {61, 59, types.Fit(2)},
		60:  {62, 60, types.Fit(2)},
		61:  {63, 61, types.Fit(2)},
		62:  {64, 62, types.Fit(2)},
		63:  {65, 63, types.Fit(2)},
		64:  {66, 64, types.Fit(0)},
		65:  {67, 65, types.Fit(7)},
		66:  {68, 66, types.Fit(2)},
		67:  {69, 67, types.Fit(2)},
		68:  {70, 68, types.Fit(2)},
		69:  {71, 69, types.Fit(4)},
		70:  {72, 70, types.Fit(4)},
	},

	MesgNumSegmentFile: {
		254: {0, 254, types.Fit(4)},
		1:   {1, 1, types.Fit(7)},
		3:   {2, 3, types.Fit(0)},
		4:   {3, 4, types.Fit(6)},
		7:   {4, 7, types.Fit(32)},
		8:   {5, 8, types.Fit(38)},
		9:   {6, 9, types.Fit(38)},
	},

	MesgNumWorkout: {
		4:  {0, 4, types.Fit(0)},
		5:  {1, 5, types.Fit(12)},
		6:  {2, 6, types.Fit(4)},
		8:  {3, 8, types.Fit(7)},
		11: {4, 11, types.Fit(0)},
		14: {5, 14, types.Fit(4)},
		15: {6, 15, types.Fit(0)},
	},

	MesgNumWorkoutSession: {
		254: {0, 254, types.Fit(4)},
		0:   {1, 0, types.Fit(0)},
		1:   {2, 1, types.Fit(0)},
		2:   {3, 2, types.Fit(4)},
		3:   {4, 3, types.Fit(4)},
		4:   {5, 4, types.Fit(4)},
		5:   {6, 5, types.Fit(0)},
	},

	MesgNumWorkoutStep: {
		254: {0, 254, types.Fit(4)},
		0:   {1, 0, types.Fit(7)},
		1:   {2, 1, types.Fit(0)},
		2:   {3, 2, types.Fit(6)},
		3:   {4, 3, types.Fit(0)},
		4:   {5, 4, types.Fit(6)},
		5:   {6, 5, types.Fit(6)},
		6:   {7, 6, types.Fit(6)},
		7:   {8, 7, types.Fit(0)},
		8:   {9, 8, types.Fit(7)},
		9:   {10, 9, types.Fit(0)},
	},

	MesgNumSchedule: {
		0: {0, 0, types.Fit(4)},
		1: {1, 1, types.Fit(4)},
		2: {2, 2, types.Fit(12)},
		3: {3, 3, types.Fit(70)},
		4: {4, 4, types.Fit(0)},
		5: {5, 5, types.Fit(0)},
		6: {6, 6, types.Fit(134)},
	},

	MesgNumTotals: {
		254: {0, 254, types.Fit(4)},
		253: {1, 253, types.Fit(70)},
		0:   {2, 0, types.Fit(6)},
		1:   {3, 1, types.Fit(6)},
		2:   {4, 2, types.Fit(6)},
		3:   {5, 3, types.Fit(0)},
		4:   {6, 4, types.Fit(6)},
		5:   {7, 5, types.Fit(4)},
		6:   {8, 6, types.Fit(6)},
	},

	MesgNumWeightScale: {
		253: {0, 253, types.Fit(70)},
		0:   {1, 0, types.Fit(4)},
		1:   {2, 1, types.Fit(4)},
		2:   {3, 2, types.Fit(4)},
		3:   {4, 3, types.Fit(4)},
		4:   {5, 4, types.Fit(4)},
		5:   {6, 5, types.Fit(4)},
		7:   {7, 7, types.Fit(4)},
		8:   {8, 8, types.Fit(2)},
		9:   {9, 9, types.Fit(4)},
		10:  {10, 10, types.Fit(2)},
		11:  {11, 11, types.Fit(2)},
		12:  {12, 12, types.Fit(4)},
	},

	MesgNumBloodPressure: {
		253: {0, 253, types.Fit(70)},
		0:   {1, 0, types.Fit(4)},
		1:   {2, 1, types.Fit(4)},
		2:   {3, 2, types.Fit(4)},
		3:   {4, 3, types.Fit(4)},
		4:   {5, 4, types.Fit(4)},
		5:   {6, 5, types.Fit(4)},
		6:   {7, 6, types.Fit(2)},
		7:   {8, 7, types.Fit(0)},
		8:   {9, 8, types.Fit(0)},
		9:   {10, 9, types.Fit(4)},
	},

	MesgNumMonitoringInfo: {
		253: {0, 253, types.Fit(70)},
		0:   {1, 0, types.Fit(134)},
	},

	MesgNumMonitoring: {
		253: {0, 253, types.Fit(70)},
		0:   {1, 0, types.Fit(2)},
		1:   {2, 1, types.Fit(4)},
		2:   {3, 2, types.Fit(6)},
		3:   {4, 3, types.Fit(6)},
		4:   {5, 4, types.Fit(6)},
		5:   {6, 5, types.Fit(0)},
		6:   {7, 6, types.Fit(0)},
		8:   {8, 8, types.Fit(4)},
		9:   {9, 9, types.Fit(4)},
		10:  {10, 10, types.Fit(4)},
		11:  {11, 11, types.Fit(134)},
	},

	MesgNumHr: {
		253: {0, 253, types.Fit(70)},
		0:   {1, 0, types.Fit(4)},
		1:   {2, 1, types.Fit(2)},
		6:   {3, 6, types.Fit(34)},
		9:   {4, 9, types.Fit(38)},
		10:  {5, 10, types.Fit(45)},
	},

	MesgNumMemoGlob: {},

	MesgNumAntChannelId: {},

	MesgNumAntRx: {
		253: {0, 253, types.Fit(70)},
		0:   {1, 0, types.Fit(4)},
		1:   {2, 1, types.Fit(13)},
		2:   {3, 2, types.Fit(45)},
		3:   {4, 3, types.Fit(2)},
		4:   {5, 4, types.Fit(45)},
	},

	MesgNumAntTx: {
		253: {0, 253, types.Fit(70)},
		0:   {1, 0, types.Fit(4)},
		1:   {2, 1, types.Fit(13)},
		2:   {3, 2, types.Fit(45)},
		3:   {4, 3, types.Fit(2)},
		4:   {5, 4, types.Fit(45)},
	},

	MesgNumExdScreenConfiguration: {
		0: {0, 0, types.Fit(2)},
		1: {1, 1, types.Fit(2)},
		2: {2, 2, types.Fit(0)},
		3: {3, 3, types.Fit(0)},
	},

	MesgNumExdDataFieldConfiguration: {
		0: {0, 0, types.Fit(2)},
		1: {1, 1, types.Fit(13)},
		2: {2, 2, types.Fit(2)},
		3: {3, 3, types.Fit(2)},
		4: {4, 4, types.Fit(0)},
		5: {5, 5, types.Fit(39)},
	},

	MesgNumExdDataConceptConfiguration: {
		0:  {0, 0, types.Fit(2)},
		1:  {1, 1, types.Fit(13)},
		2:  {2, 2, types.Fit(2)},
		3:  {3, 3, types.Fit(2)},
		4:  {4, 4, types.Fit(2)},
		5:  {5, 5, types.Fit(2)},
		6:  {6, 6, types.Fit(2)},
		8:  {7, 8, types.Fit(0)},
		9:  {8, 9, types.Fit(0)},
		10: {9, 10, types.Fit(0)},
		11: {10, 11, types.Fit(0)},
	},

	MesgNumFieldDescription: {
		0:  {0, 0, types.Fit(2)},
		1:  {1, 1, types.Fit(2)},
		2:  {2, 2, types.Fit(2)},
		3:  {3, 3, types.Fit(39)},
		4:  {4, 4, types.Fit(2)},
		5:  {5, 5, types.Fit(7)},
		6:  {6, 6, types.Fit(2)},
		7:  {7, 7, types.Fit(1)},
		8:  {8, 8, types.Fit(39)},
		9:  {9, 9, types.Fit(7)},
		10: {10, 10, types.Fit(7)},
		13: {11, 13, types.Fit(4)},
		14: {12, 14, types.Fit(4)},
		15: {13, 15, types.Fit(2)},
	},

	MesgNumDeveloperDataId: {
		0: {0, 0, types.Fit(45)},
		1: {1, 1, types.Fit(45)},
		2: {2, 2, types.Fit(4)},
		3: {3, 3, types.Fit(2)},
		4: {4, 4, types.Fit(6)},
	},
}

func getField(gmn MesgNum, fdn byte) (*field, bool) {
	if int(gmn) >= len(_fields) {
		return nil, false
	}
	f := _fields[gmn][fdn]
	if f == nil {
		return nil, false
	}
	return f, true
}

var msgsTypes = [...]reflect.Type{
	MesgNumFileId:                      reflect.TypeOf(FileIdMsg{}),
	MesgNumFileCreator:                 reflect.TypeOf(FileCreatorMsg{}),
	MesgNumTimestampCorrelation:        reflect.TypeOf(TimestampCorrelationMsg{}),
	MesgNumSoftware:                    reflect.TypeOf(SoftwareMsg{}),
	MesgNumSlaveDevice:                 reflect.TypeOf(SlaveDeviceMsg{}),
	MesgNumCapabilities:                reflect.TypeOf(CapabilitiesMsg{}),
	MesgNumFileCapabilities:            reflect.TypeOf(FileCapabilitiesMsg{}),
	MesgNumMesgCapabilities:            reflect.TypeOf(MesgCapabilitiesMsg{}),
	MesgNumFieldCapabilities:           reflect.TypeOf(FieldCapabilitiesMsg{}),
	MesgNumDeviceSettings:              reflect.TypeOf(DeviceSettingsMsg{}),
	MesgNumUserProfile:                 reflect.TypeOf(UserProfileMsg{}),
	MesgNumHrmProfile:                  reflect.TypeOf(HrmProfileMsg{}),
	MesgNumSdmProfile:                  reflect.TypeOf(SdmProfileMsg{}),
	MesgNumBikeProfile:                 reflect.TypeOf(BikeProfileMsg{}),
	MesgNumConnectivity:                reflect.TypeOf(ConnectivityMsg{}),
	MesgNumWatchfaceSettings:           reflect.TypeOf(WatchfaceSettingsMsg{}),
	MesgNumOhrSettings:                 reflect.TypeOf(OhrSettingsMsg{}),
	MesgNumZonesTarget:                 reflect.TypeOf(ZonesTargetMsg{}),
	MesgNumSport:                       reflect.TypeOf(SportMsg{}),
	MesgNumHrZone:                      reflect.TypeOf(HrZoneMsg{}),
	MesgNumSpeedZone:                   reflect.TypeOf(SpeedZoneMsg{}),
	MesgNumCadenceZone:                 reflect.TypeOf(CadenceZoneMsg{}),
	MesgNumPowerZone:                   reflect.TypeOf(PowerZoneMsg{}),
	MesgNumMetZone:                     reflect.TypeOf(MetZoneMsg{}),
	MesgNumGoal:                        reflect.TypeOf(GoalMsg{}),
	MesgNumActivity:                    reflect.TypeOf(ActivityMsg{}),
	MesgNumSession:                     reflect.TypeOf(SessionMsg{}),
	MesgNumLap:                         reflect.TypeOf(LapMsg{}),
	MesgNumLength:                      reflect.TypeOf(LengthMsg{}),
	MesgNumRecord:                      reflect.TypeOf(RecordMsg{}),
	MesgNumEvent:                       reflect.TypeOf(EventMsg{}),
	MesgNumDeviceInfo:                  reflect.TypeOf(DeviceInfoMsg{}),
	MesgNumTrainingFile:                reflect.TypeOf(TrainingFileMsg{}),
	MesgNumHrv:                         reflect.TypeOf(HrvMsg{}),
	MesgNumWeatherConditions:           reflect.TypeOf(WeatherConditionsMsg{}),
	MesgNumWeatherAlert:                reflect.TypeOf(WeatherAlertMsg{}),
	MesgNumGpsMetadata:                 reflect.TypeOf(GpsMetadataMsg{}),
	MesgNumCameraEvent:                 reflect.TypeOf(CameraEventMsg{}),
	MesgNumGyroscopeData:               reflect.TypeOf(GyroscopeDataMsg{}),
	MesgNumAccelerometerData:           reflect.TypeOf(AccelerometerDataMsg{}),
	MesgNumMagnetometerData:            reflect.TypeOf(MagnetometerDataMsg{}),
	MesgNumThreeDSensorCalibration:     reflect.TypeOf(ThreeDSensorCalibrationMsg{}),
	MesgNumVideoFrame:                  reflect.TypeOf(VideoFrameMsg{}),
	MesgNumObdiiData:                   reflect.TypeOf(ObdiiDataMsg{}),
	MesgNumNmeaSentence:                reflect.TypeOf(NmeaSentenceMsg{}),
	MesgNumAviationAttitude:            reflect.TypeOf(AviationAttitudeMsg{}),
	MesgNumVideo:                       reflect.TypeOf(VideoMsg{}),
	MesgNumVideoTitle:                  reflect.TypeOf(VideoTitleMsg{}),
	MesgNumVideoDescription:            reflect.TypeOf(VideoDescriptionMsg{}),
	MesgNumVideoClip:                   reflect.TypeOf(VideoClipMsg{}),
	MesgNumCourse:                      reflect.TypeOf(CourseMsg{}),
	MesgNumCoursePoint:                 reflect.TypeOf(CoursePointMsg{}),
	MesgNumSegmentId:                   reflect.TypeOf(SegmentIdMsg{}),
	MesgNumSegmentLeaderboardEntry:     reflect.TypeOf(SegmentLeaderboardEntryMsg{}),
	MesgNumSegmentPoint:                reflect.TypeOf(SegmentPointMsg{}),
	MesgNumSegmentLap:                  reflect.TypeOf(SegmentLapMsg{}),
	MesgNumSegmentFile:                 reflect.TypeOf(SegmentFileMsg{}),
	MesgNumWorkout:                     reflect.TypeOf(WorkoutMsg{}),
	MesgNumWorkoutSession:              reflect.TypeOf(WorkoutSessionMsg{}),
	MesgNumWorkoutStep:                 reflect.TypeOf(WorkoutStepMsg{}),
	MesgNumSchedule:                    reflect.TypeOf(ScheduleMsg{}),
	MesgNumTotals:                      reflect.TypeOf(TotalsMsg{}),
	MesgNumWeightScale:                 reflect.TypeOf(WeightScaleMsg{}),
	MesgNumBloodPressure:               reflect.TypeOf(BloodPressureMsg{}),
	MesgNumMonitoringInfo:              reflect.TypeOf(MonitoringInfoMsg{}),
	MesgNumMonitoring:                  reflect.TypeOf(MonitoringMsg{}),
	MesgNumHr:                          reflect.TypeOf(HrMsg{}),
	MesgNumMemoGlob:                    reflect.TypeOf(MemoGlobMsg{}),
	MesgNumAntChannelId:                reflect.TypeOf(AntChannelIdMsg{}),
	MesgNumAntRx:                       reflect.TypeOf(AntRxMsg{}),
	MesgNumAntTx:                       reflect.TypeOf(AntTxMsg{}),
	MesgNumExdScreenConfiguration:      reflect.TypeOf(ExdScreenConfigurationMsg{}),
	MesgNumExdDataFieldConfiguration:   reflect.TypeOf(ExdDataFieldConfigurationMsg{}),
	MesgNumExdDataConceptConfiguration: reflect.TypeOf(ExdDataConceptConfigurationMsg{}),
	MesgNumFieldDescription:            reflect.TypeOf(FieldDescriptionMsg{}),
	MesgNumDeveloperDataId:             reflect.TypeOf(DeveloperDataIdMsg{}),
}

var msgsAllInvalid = [...]reflect.Value{
	MesgNumFileId: reflect.ValueOf(FileIdMsg{
		0xFF,
		0xFFFF,
		0xFFFF,
		0x00000000,
		timeBase,
		0xFFFF,
		"",
	}),
	MesgNumFileCreator: reflect.ValueOf(FileCreatorMsg{
		0xFFFF,
		0xFF,
	}),
	MesgNumTimestampCorrelation: reflect.ValueOf(TimestampCorrelationMsg{}),
	MesgNumSoftware: reflect.ValueOf(SoftwareMsg{
		0xFFFF,
		0xFFFF,
		"",
	}),
	MesgNumSlaveDevice: reflect.ValueOf(SlaveDeviceMsg{
		0xFFFF,
		0xFFFF,
	}),
	MesgNumCapabilities: reflect.ValueOf(CapabilitiesMsg{
		nil,
		nil,
		0x00000000,
		0x00000000,
	}),
	MesgNumFileCapabilities: reflect.ValueOf(FileCapabilitiesMsg{
		0xFFFF,
		0xFF,
		0x00,
		"",
		0xFFFF,
		0xFFFFFFFF,
	}),
	MesgNumMesgCapabilities: reflect.ValueOf(MesgCapabilitiesMsg{
		0xFFFF,
		0xFF,
		0xFFFF,
		0xFF,
		0xFFFF,
	}),
	MesgNumFieldCapabilities: reflect.ValueOf(FieldCapabilitiesMsg{
		0xFFFF,
		0xFF,
		0xFFFF,
		0xFF,
		0xFFFF,
	}),
	MesgNumDeviceSettings: reflect.ValueOf(DeviceSettingsMsg{
		0xFF,
		0xFFFFFFFF,
		nil,
		nil,
		nil,
		0xFF,
		0xFF,
		timeBase,
		nil,
		0xFF,
		0xFF,
		0xFF,
		0xFF,
		nil,
		0xFFFF,
		0xFFFF,
	}),
	MesgNumUserProfile: reflect.ValueOf(UserProfileMsg{
		0xFFFF,
		"",
		0xFF,
		0xFF,
		0xFF,
		0xFFFF,
		0xFF,
		0xFF,
		0xFF,
		0xFF,
		0xFF,
		0xFF,
		0xFF,
		0xFF,
		0xFF,
		0xFF,
		0xFF,
		0xFF,
		0xFF,
		0xFF,
		0xFFFF,
		nil,
		0xFF,
		0xFFFF,
		0xFFFF,
	}),
	MesgNumHrmProfile: reflect.ValueOf(HrmProfileMsg{
		0xFFFF,
		0xFF,
		0x0000,
		0xFF,
		0x00,
	}),
	MesgNumSdmProfile: reflect.ValueOf(SdmProfileMsg{
		0xFFFF,
		0xFF,
		0x0000,
		0xFFFF,
		0xFFFFFFFF,
		0xFF,
		0x00,
		0xFF,
	}),
	MesgNumBikeProfile: reflect.ValueOf(BikeProfileMsg{
		0xFFFF,
		"",
		0xFF,
		0xFF,
		0xFFFFFFFF,
		0x0000,
		0x0000,
		0x0000,
		0x0000,
		0xFFFF,
		0xFFFF,
		0xFFFF,
		0xFFFF,
		0xFF,
		0xFF,
		0xFF,
		0xFF,
		0xFF,
		0xFF,
		0xFF,
		0xFF,
		0xFF,
		0x00,
		0x00,
		0x00,
		0x00,
		0xFF,
		0x00,
		nil,
		0x00,
		nil,
		0xFF,
	}),
	MesgNumConnectivity: reflect.ValueOf(ConnectivityMsg{
		0xFF,
		0xFF,
		0xFF,
		"",
		0xFF,
		0xFF,
		0xFF,
		0xFF,
		0xFF,
		0xFF,
		0xFF,
		0xFF,
		0xFF,
	}),
	MesgNumWatchfaceSettings: reflect.ValueOf(WatchfaceSettingsMsg{}),
	MesgNumOhrSettings:       reflect.ValueOf(OhrSettingsMsg{}),
	MesgNumZonesTarget: reflect.ValueOf(ZonesTargetMsg{
		0xFF,
		0xFF,
		0xFFFF,
		0xFF,
		0xFF,
	}),
	MesgNumSport: reflect.ValueOf(SportMsg{
		0xFF,
		0xFF,
		"",
	}),
	MesgNumHrZone: reflect.ValueOf(HrZoneMsg{
		0xFFFF,
		0xFF,
		"",
	}),
	MesgNumSpeedZone: reflect.ValueOf(SpeedZoneMsg{
		0xFFFF,
		0xFFFF,
		"",
	}),
	MesgNumCadenceZone: reflect.ValueOf(CadenceZoneMsg{
		0xFFFF,
		0xFF,
		"",
	}),
	MesgNumPowerZone: reflect.ValueOf(PowerZoneMsg{
		0xFFFF,
		0xFFFF,
		"",
	}),
	MesgNumMetZone: reflect.ValueOf(MetZoneMsg{
		0xFFFF,
		0xFF,
		0xFFFF,
		0xFF,
	}),
	MesgNumGoal: reflect.ValueOf(GoalMsg{
		0xFFFF,
		0xFF,
		0xFF,
		timeBase,
		timeBase,
		0xFF,
		0xFFFFFFFF,
		0xFF,
		0xFFFFFFFF,
		0xFF,
		0xFFFF,
		0xFF,
		0xFF,
	}),
	MesgNumActivity: reflect.ValueOf(ActivityMsg{
		timeBase,
		0xFFFFFFFF,
		0xFFFF,
		0xFF,
		0xFF,
		0xFF,
		timeBase,
		0xFF,
	}),
	MesgNumSession: reflect.ValueOf(SessionMsg{
		0xFFFF,
		timeBase,
		0xFF,
		0xFF,
		timeBase,
		NewLatitudeInvalid(),
		NewLongitudeInvalid(),
		0xFF,
		0xFF,
		0xFFFFFFFF,
		0xFFFFFFFF,
		0xFFFFFFFF,
		0xFFFFFFFF,
		0xFFFF,
		0xFFFF,
		0xFFFF,
		0xFFFF,
		0xFF,
		0xFF,
		0xFF,
		0xFF,
		0xFFFF,
		0xFFFF,
		0xFFFF,
		0xFFFF,
		0xFF,
		0xFFFF,
		0xFFFF,
		0xFF,
		0xFF,
		NewLatitudeInvalid(),
		NewLongitudeInvalid(),
		NewLatitudeInvalid(),
		NewLongitudeInvalid(),
		0xFFFF,
		0xFFFF,
		0xFFFF,
		0xFFFF,
		0xFFFFFFFF,
		0xFFFF,
		0xFF,
		0xFFFF,
		0xFFFF,
		0xFF,
		0xFFFF,
		0xFFFFFFFF,
		0xFFFF,
		0xFFFF,
		0xFF,
		0x7FFF,
		0x7FFF,
		0x7FFF,
		0x7FFF,
		0x7FFF,
		0x7F,
		0x7F,
		0xFFFFFFFF,
		0x7FFF,
		0x7FFF,
		0x7FFF,
		0x7FFF,
		0xFF,
		nil,
		nil,
		nil,
		nil,
		0xFFFFFFFF,
		0xFFFF,
		0xFFFF,
		0xFFFF,
		0xFFFF,
		"",
		nil,
		nil,
		0xFFFF,
		0xFFFF,
		0xFFFF,
		0xFFFF,
		0xFFFF,
		0xFF,
		0xFF,
		0xFF,
		0xFF,
		0xFFFFFFFF,
		0xFFFFFFFF,
		0xFFFFFFFF,
		0xFFFFFFFF,
		0xFFFFFFFF,
		0xFF,
		0xFFFF,
	}),
	MesgNumLap: reflect.ValueOf(LapMsg{
		0xFFFF,
		timeBase,
		0xFF,
		0xFF,
		timeBase,
		NewLatitudeInvalid(),
		NewLongitudeInvalid(),
		NewLatitudeInvalid(),
		NewLongitudeInvalid(),
		0xFFFFFFFF,
		0xFFFFFFFF,
		0xFFFFFFFF,
		0xFFFFFFFF,
		0xFFFF,
		0xFFFF,
		0xFFFF,
		0xFFFF,
		0xFF,
		0xFF,
		0xFF,
		0xFF,
		0xFFFF,
		0xFFFF,
		0xFFFF,
		0xFFFF,
		0xFF,
		0xFF,
		0xFF,
		0xFF,
		0xFFFF,
		0xFFFF,
		0xFFFF,
		0xFFFF,
		0xFFFF,
		0xFF,
		0xFF,
		0xFFFF,
		0xFFFFFFFF,
		0xFFFF,
		0xFFFF,
		0xFF,
		0x7FFF,
		0x7FFF,
		0x7FFF,
		0x7FFF,
		0x7FFF,
		0x7F,
		0x7F,
		0xFFFFFFFF,
		0x7FFF,
		0x7FFF,
		0x7FFF,
		0x7FFF,
		nil,
		nil,
		nil,
		nil,
		0xFFFF,
		0xFFFF,
		0xFF,
		0xFFFF,
		0xFFFF,
		nil,
		nil,
		0xFFFF,
		0xFFFF,
		0xFFFF,
		0xFF,
		0xFF,
		0xFF,
		0xFFFF,
		nil,
		nil,
		nil,
		nil,
		nil,
		nil,
		0xFFFFFFFF,
		0xFFFFFFFF,
		0xFFFFFFFF,
		0xFFFFFFFF,
		0xFFFFFFFF,
		0xFFFF,
	}),
	MesgNumLength: reflect.ValueOf(LengthMsg{
		0xFFFF,
		timeBase,
		0xFF,
		0xFF,
		timeBase,
		0xFFFFFFFF,
		0xFFFFFFFF,
		0xFFFF,
		0xFFFF,
		0xFF,
		0xFF,
		0xFF,
		0xFFFF,
		0xFF,
		0xFFFF,
		0xFFFF,
		nil,
		nil,
	}),
	MesgNumRecord: reflect.ValueOf(RecordMsg{
		timeBase,
		NewLatitudeInvalid(),
		NewLongitudeInvalid(),
		0xFFFF,
		0xFF,
		0xFF,
		0xFFFFFFFF,
		0xFFFF,
		0xFFFF,
		nil,
		0x7FFF,
		0xFF,
		0x7FFFFFFF,
		0xFF,
		0x7F,
		nil,
		0xFF,
		0xFFFFFFFF,
		0xFFFF,
		0xFFFFFFFF,
		0xFF,
		0xFF,
		0x7FFF,
		0xFFFF,
		0xFFFF,
		0xFFFF,
		0xFFFF,
		0xFF,
		0xFF,
		0xFF,
		0xFF,
		0xFF,
		0xFF,
		0xFF,
		0xFF,
		0xFF,
		0xFFFF,
		0xFFFF,
		0xFF,
		0xFFFF,
		0xFFFF,
		0xFFFF,
		0xFFFF,
		0xFFFF,
		0xFFFF,
		0xFF,
		0xFFFFFFFF,
		0xFFFFFFFF,
	}),
	MesgNumEvent: reflect.ValueOf(EventMsg{
		timeBase,
		0xFF,
		0xFF,
		0xFFFF,
		0xFFFFFFFF,
		0xFF,
		0xFFFF,
		0xFFFF,
		0x00,
		0x00,
		0x00,
		0x00,
	}),
	MesgNumDeviceInfo: reflect.ValueOf(DeviceInfoMsg{
		timeBase,
		0xFF,
		0xFF,
		0xFFFF,
		0x00000000,
		0xFFFF,
		0xFFFF,
		0xFF,
		0xFFFFFFFF,
		0xFFFF,
		0xFF,
		0xFF,
		"",
		0x00,
		0x0000,
		0xFF,
		0xFF,
		"",
	}),
	MesgNumTrainingFile: reflect.ValueOf(TrainingFileMsg{
		timeBase,
		0xFF,
		0xFFFF,
		0xFFFF,
		0x00000000,
		timeBase,
	}),
	MesgNumHrv: reflect.ValueOf(HrvMsg{
		nil,
	}),
	MesgNumWeatherConditions: reflect.ValueOf(WeatherConditionsMsg{
		timeBase,
		0xFF,
		0x7F,
		0xFF,
		0xFFFF,
		0xFFFF,
		0xFF,
		0x7F,
		0xFF,
		"",
		timeBase,
		NewLatitudeInvalid(),
		NewLongitudeInvalid(),
		0xFF,
		0x7F,
		0x7F,
	}),
	MesgNumWeatherAlert: reflect.ValueOf(WeatherAlertMsg{
		timeBase,
		"",
		timeBase,
		timeBase,
		0xFF,
		0xFF,
	}),
	MesgNumGpsMetadata:             reflect.ValueOf(GpsMetadataMsg{}),
	MesgNumCameraEvent:             reflect.ValueOf(CameraEventMsg{}),
	MesgNumGyroscopeData:           reflect.ValueOf(GyroscopeDataMsg{}),
	MesgNumAccelerometerData:       reflect.ValueOf(AccelerometerDataMsg{}),
	MesgNumMagnetometerData:        reflect.ValueOf(MagnetometerDataMsg{}),
	MesgNumThreeDSensorCalibration: reflect.ValueOf(ThreeDSensorCalibrationMsg{}),
	MesgNumVideoFrame:              reflect.ValueOf(VideoFrameMsg{}),
	MesgNumObdiiData:               reflect.ValueOf(ObdiiDataMsg{}),
	MesgNumNmeaSentence: reflect.ValueOf(NmeaSentenceMsg{
		timeBase,
		0xFFFF,
		"",
	}),
	MesgNumAviationAttitude: reflect.ValueOf(AviationAttitudeMsg{
		timeBase,
		0xFFFF,
		nil,
		nil,
		nil,
		nil,
		nil,
		nil,
		nil,
		nil,
		nil,
		nil,
	}),
	MesgNumVideo: reflect.ValueOf(VideoMsg{}),
	MesgNumVideoTitle: reflect.ValueOf(VideoTitleMsg{
		0xFFFF,
		0xFFFF,
		"",
	}),
	MesgNumVideoDescription: reflect.ValueOf(VideoDescriptionMsg{
		0xFFFF,
		0xFFFF,
		"",
	}),
	MesgNumVideoClip: reflect.ValueOf(VideoClipMsg{}),
	MesgNumCourse: reflect.ValueOf(CourseMsg{
		0xFF,
		"",
		0x00000000,
		0xFF,
	}),
	MesgNumCoursePoint: reflect.ValueOf(CoursePointMsg{
		0xFFFF,
		timeBase,
		NewLatitudeInvalid(),
		NewLongitudeInvalid(),
		0xFFFFFFFF,
		0xFF,
		"",
		0xFF,
	}),
	MesgNumSegmentId: reflect.ValueOf(SegmentIdMsg{
		"",
		"",
		0xFF,
		0xFF,
		0xFFFFFFFF,
		0xFFFFFFFF,
		0xFF,
		0xFF,
		0xFF,
	}),
	MesgNumSegmentLeaderboardEntry: reflect.ValueOf(SegmentLeaderboardEntryMsg{
		0xFFFF,
		"",
		0xFF,
		0xFFFFFFFF,
		0xFFFFFFFF,
		0xFFFFFFFF,
	}),
	MesgNumSegmentPoint: reflect.ValueOf(SegmentPointMsg{
		0xFFFF,
		NewLatitudeInvalid(),
		NewLongitudeInvalid(),
		0xFFFFFFFF,
		0xFFFF,
		nil,
	}),
	MesgNumSegmentLap: reflect.ValueOf(SegmentLapMsg{
		0xFFFF,
		timeBase,
		0xFF,
		0xFF,
		timeBase,
		NewLatitudeInvalid(),
		NewLongitudeInvalid(),
		NewLatitudeInvalid(),
		NewLongitudeInvalid(),
		0xFFFFFFFF,
		0xFFFFFFFF,
		0xFFFFFFFF,
		0xFFFFFFFF,
		0xFFFF,
		0xFFFF,
		0xFFFF,
		0xFFFF,
		0xFF,
		0xFF,
		0xFF,
		0xFF,
		0xFFFF,
		0xFFFF,
		0xFFFF,
		0xFFFF,
		0xFF,
		0xFF,
		NewLatitudeInvalid(),
		NewLongitudeInvalid(),
		NewLatitudeInvalid(),
		NewLongitudeInvalid(),
		"",
		0xFFFF,
		0xFFFF,
		0xFF,
		0xFFFFFFFF,
		0xFFFF,
		0xFFFF,
		0xFF,
		0x7FFF,
		0x7FFF,
		0x7FFF,
		0x7FFF,
		0x7FFF,
		0x7F,
		0x7F,
		0xFFFFFFFF,
		0x7FFF,
		0x7FFF,
		0x7FFF,
		0x7FFF,
		nil,
		nil,
		nil,
		nil,
		0xFFFF,
		0xFFFF,
		0xFF,
		0xFFFFFFFF,
		0xFFFF,
		0xFF,
		0xFF,
		0xFF,
		0xFF,
		0xFF,
		0xFF,
		0xFF,
		"",
		0xFF,
		0xFF,
		0xFF,
		0xFFFF,
		0xFFFF,
	}),
	MesgNumSegmentFile: reflect.ValueOf(SegmentFileMsg{
		0xFFFF,
		"",
		0xFF,
		0xFFFFFFFF,
		nil,
		nil,
		nil,
	}),
	MesgNumWorkout: reflect.ValueOf(WorkoutMsg{
		0xFF,
		0x00000000,
		0xFFFF,
		"",
		0xFF,
		0xFFFF,
		0xFF,
	}),
	MesgNumWorkoutSession: reflect.ValueOf(WorkoutSessionMsg{
		0xFFFF,
		0xFF,
		0xFF,
		0xFFFF,
		0xFFFF,
		0xFFFF,
		0xFF,
	}),
	MesgNumWorkoutStep: reflect.ValueOf(WorkoutStepMsg{
		0xFFFF,
		"",
		0xFF,
		0xFFFFFFFF,
		0xFF,
		0xFFFFFFFF,
		0xFFFFFFFF,
		0xFFFFFFFF,
		0xFF,
		"",
		0xFF,
	}),
	MesgNumSchedule: reflect.ValueOf(ScheduleMsg{
		0xFFFF,
		0xFFFF,
		0x00000000,
		timeBase,
		0xFF,
		0xFF,
		timeBase,
	}),
	MesgNumTotals: reflect.ValueOf(TotalsMsg{
		0xFFFF,
		timeBase,
		0xFFFFFFFF,
		0xFFFFFFFF,
		0xFFFFFFFF,
		0xFF,
		0xFFFFFFFF,
		0xFFFF,
		0xFFFFFFFF,
	}),
	MesgNumWeightScale: reflect.ValueOf(WeightScaleMsg{
		timeBase,
		0xFFFF,
		0xFFFF,
		0xFFFF,
		0xFFFF,
		0xFFFF,
		0xFFFF,
		0xFFFF,
		0xFF,
		0xFFFF,
		0xFF,
		0xFF,
		0xFFFF,
	}),
	MesgNumBloodPressure: reflect.ValueOf(BloodPressureMsg{
		timeBase,
		0xFFFF,
		0xFFFF,
		0xFFFF,
		0xFFFF,
		0xFFFF,
		0xFFFF,
		0xFF,
		0xFF,
		0xFF,
		0xFFFF,
	}),
	MesgNumMonitoringInfo: reflect.ValueOf(MonitoringInfoMsg{
		timeBase,
		timeBase,
	}),
	MesgNumMonitoring: reflect.ValueOf(MonitoringMsg{
		timeBase,
		0xFF,
		0xFFFF,
		0xFFFFFFFF,
		0xFFFFFFFF,
		0xFFFFFFFF,
		0xFF,
		0xFF,
		0xFFFF,
		0xFFFF,
		0xFFFF,
		timeBase,
	}),
	MesgNumHr: reflect.ValueOf(HrMsg{
		timeBase,
		0xFFFF,
		0xFF,
		nil,
		nil,
		nil,
	}),
	MesgNumMemoGlob:     reflect.ValueOf(MemoGlobMsg{}),
	MesgNumAntChannelId: reflect.ValueOf(AntChannelIdMsg{}),
	MesgNumAntRx: reflect.ValueOf(AntRxMsg{
		timeBase,
		0xFFFF,
		0xFF,
		nil,
		0xFF,
		nil,
	}),
	MesgNumAntTx: reflect.ValueOf(AntTxMsg{
		timeBase,
		0xFFFF,
		0xFF,
		nil,
		0xFF,
		nil,
	}),
	MesgNumExdScreenConfiguration: reflect.ValueOf(ExdScreenConfigurationMsg{
		0xFF,
		0xFF,
		0xFF,
		0xFF,
	}),
	MesgNumExdDataFieldConfiguration: reflect.ValueOf(ExdDataFieldConfigurationMsg{
		0xFF,
		0xFF,
		0xFF,
		0xFF,
		0xFF,
		nil,
	}),
	MesgNumExdDataConceptConfiguration: reflect.ValueOf(ExdDataConceptConfigurationMsg{
		0xFF,
		0xFF,
		0xFF,
		0xFF,
		0xFF,
		0xFF,
		0xFF,
		0xFF,
		0xFF,
		0xFF,
		0xFF,
	}),
	MesgNumFieldDescription: reflect.ValueOf(FieldDescriptionMsg{
		0xFF,
		0xFF,
		0xFF,
		nil,
		0xFF,
		"",
		0xFF,
		0x7F,
		nil,
		"",
		"",
		0xFFFF,
		0xFFFF,
		0xFF,
	}),
	MesgNumDeveloperDataId: reflect.ValueOf(DeveloperDataIdMsg{
		nil,
		nil,
		0xFFFF,
		0xFF,
		0xFFFFFFFF,
	}),
}

func getMesgAllInvalid(mn MesgNum) reflect.Value {
	val := reflect.New(msgsTypes[mn]).Elem()
	val.Set(msgsAllInvalid[mn])
	return val
}
// STRINGER TYPE INPUT
ActivityClass,ActivityLevel,ActivityMode,ActivitySubtype,ActivityType,AnalogWatchfaceLayout,AntNetwork,AntplusDeviceType,AttitudeStage,AttitudeValidity,AutoActivityDetect,AutoSyncFrequency,AutolapTrigger,Autoscroll,BacklightMode,BatteryStatus,BikeLightBeamAngleMode,BikeLightNetworkConfigType,BodyLocation,BpStatus,CameraEventType,CameraOrientationType,Checksum,CommTimeoutType,ConnectivityCapabilities,CourseCapabilities,CoursePoint,DateMode,DayOfWeek,DeviceIndex,DigitalWatchfaceLayout,DisplayHeart,DisplayMeasure,DisplayOrientation,DisplayPosition,DisplayPower,Event,EventType,ExdDataUnits,ExdDescriptors,ExdDisplayType,ExdLayout,ExdQualifiers,FileFlags,FileType,FitBaseType,FitBaseUnit,FitnessEquipmentState,GarminProduct,Gender,Goal,GoalRecurrence,GoalSource,HrType,HrZoneCalc,Intensity,Language,LanguageBits0,LanguageBits1,LanguageBits2,LanguageBits3,LanguageBits4,LapTrigger,LeftRightBalance,LeftRightBalance100,LengthType,LocaltimeIntoDay,Manufacturer,MesgCount,MesgNum,MessageIndex,PowerPhaseType,PwrZoneCalc,RiderPositionType,Schedule,SegmentDeleteStatus,SegmentLapStatus,SegmentLeaderboardType,SegmentSelectionType,SensorType,SessionTrigger,Side,SourceType,Sport,SportBits0,SportBits1,SportBits2,SportBits3,SportBits4,SportBits5,SportBits6,SportEvent,StrokeType,SubSport,SupportedExdScreenLayouts,SwimStroke,Switch,TimeIntoDay,TimeMode,TimeZone,TimerTrigger,TurnType,UserLocalId,WatchfaceMode,WeatherReport,WeatherSevereType,WeatherSeverity,WeatherStatus,Weight,WktStepDuration,WktStepTarget,WorkoutCapabilities,WorkoutEquipment,WorkoutHr,WorkoutPower
// MESSAGE NUMS WITHOUT MESSAGE
Pad
